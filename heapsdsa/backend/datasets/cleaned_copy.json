[
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: An AVL tree is a height-balanced binary search tree. For every node, the difference in height between its left and right subtrees (called balance factor) must be at most 1.",
        "target_text": "Question: An AVL tree is a self - balancing binary search tree, in which the heights of the two child sub trees of any node differ by __________\nChoices:\na) At least one\nb) At most one\nc) Two\nd) At most two\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a binary search tree (BST), in-order traversal visits nodes in the left-root-right order, which yields values in ascending sorted order.",
        "target_text": "Question: In a binary search tree, which of the following traversals would print the numbers in the ascending order?\nChoices:\na) Level-order traversal\nb) Pre-order traversal\nc) Post-order traversal\nd) In-order traversal\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Height-balanced binary trees like AVL trees maintain balance to prevent skewed shapes, which helps achieve faster access and insertion times, improving overall efficiency.",
        "target_text": "Question: Why we need to a binary tree which is height balanced?\nChoices:\na) to avoid formation of skew trees\nb) to save memory\nc) to attain faster memory access\nd) to simplify storing\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Open addressing handles collisions by probing alternative locations in the hash table. Common techniques include linear probing, quadratic probing, and double hashing. Rehashing, however, refers to resizing the hash table, not collision resolution.",
        "target_text": "Question: Which of the following is not a collision resolution strategy for open addressing?\nChoices:\na) Linear probing\nb) Quadratic probing\nc) Double hashing\nd) Rehashing\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a B+ tree with n pointers, the number of keys in a leaf node ranges from ceil((n-1)/2) to n-1. If the node can hold 7 pointers, it can hold up to 6 keys, with a minimum of ceil(6/2) = 3.",
        "target_text": "Question: A B+ tree can contain a maximum of 7 pointers in a node. What is the minimum number of keys in leaves?\nChoices:\na) 6\nb) 3\nc) 4\nd) 7\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In syntax trees or parse trees used by compilers, an in-order traversal returns the original infix expression, which is the same as the original input string.",
        "target_text": "Question: While evaluating the parse tree, which traversal technique is used to give the original input string?\nChoices:\na) Pre-order traversal\nb) In-order traversal\nc) Post-order traversal\nd) Breadth-first traversal\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Graph | Context: In a hypergraph, an incidence matrix is a binary matrix that indicates the membership of vertices in hyperedges. Each row represents a vertex, and each column a hyperedge.",
        "target_text": "Question: What would be the Incidence Matrix of the given HyperGraph?\nV = {x,y,z} E = {{x,y}{y}{x,z}{z,y}}\nChoices:\na) {{1,0,1,0},\n{1,1,0,1},\n{0,0,1,1}}\nb) {{1,1,0,0},\n{0,1,0,0},\n{1,1,1,0}}\nc) {{0,1,0,1},\n{0,0,1,0},\n{1,1,0,0}}\nd) None of the Mentioned\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: The maximum number of nodes in a binary tree of depth `d` is given by the formula 2^d - 1. For depth 5, it would be 2^5 - 1 = 31.",
        "target_text": "Question: The maximum number of nodes in a binary tree of depth 5 is __________\nChoices:\na) 31\nb) 16\nc) 32 \\n (A) 31 \\n (B) 16 \\n (C) 32\nd) 15\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Quadratic probing is a collision resolution method in open addressing. The hash function is adjusted using a quadratic function: Hash(x) = (hash(x) + c1*i + c2*i^2) % table_size, often simplified as (hash(x) + F(i^2)) mod table size.",
        "target_text": "Question: What is the formula used in quadratic probing?\nChoices:\na) Hash key = key mod table size\nb) Hash key=(hash(x)+F(i)) mod table size\nc) Hash key=(hash(x)+F(i2)) mod table size\nd) H(x) = x mod 17\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: The k-d tree (k-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. It was invented by Jon Bentley in 1975.",
        "target_text": "Question: Who invented k-d trees?\nChoices:\na) Arne Andersson\nb) Jon Bentley\nc) Jon Von Newmann\nd) Rudolf Bayer\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Prefix notation (Polish notation) places operators before their operands. The infix expression (p + q) - (r * t) is written as - + p q * r t in prefix form.",
        "target_text": "Question: The prefix form of an infix expression (p + q) - (r * t) is?\nChoices:\na) + pq - *rt\nb) - +pqr * t\nc) - +pq * rt\nd) - + * pqrt\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: A 2D search tree, also known as a k-d tree, uses alternate dimensions for comparison at different levels. At odd levels, comparisons are typically made using the first key.",
        "target_text": "Question: The 2d search tree has the simple property that branching on odd levels is done with respect to the first key.\nChoices:\na) True\nb) False\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Postfix expressions (Reverse Polish Notation) are evaluated using a stack. For `abc*+`, with a=1, b=2, c=3, it becomes 1 + (2 * 3) = 7.",
        "target_text": "Question: What is the result of the given postfix expression? abc*+ where a=1, b=2, c=3.\nChoices:\na) 4\nb) 5\nc) 6\nd) 7\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Postfix expressions are evaluated using a stack. The expression `6 3 2 4 + - *` evaluates as: 2 + 4 = 6, then 3 - 6 = -3, and finally 6 * (-3) = -18.",
        "target_text": "Question: 7. What is the value of the postfix expression 6 3 2 4 + - *?\nChoices:\na) 74\nb) -18\nc) 22\nd) 40\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: The Van Emde Boas tree, an advanced data structure that supports operations in O(log log u) time, was invented by Peter van Emde Boas in 1975.",
        "target_text": "Question: In which year was Van Emde Boas tree invented?\nChoices:\na) 1972\nb) 1973\nc) 1974\nd) 1975\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: A full binary tree is a binary tree in which every node other than the leaves has two children. A balanced full binary tree with `n` leaves has height ceil(log2(n)). For 8 leaves, height is log2(8) = 3, so height = 3 + 1 = 4.",
        "target_text": "Question: What will be the height of a balanced full binary tree with 8 leaves?\nChoices:\na) 8\nb) 5\nc) 6\nd) 4\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: A spanning tree is a subgraph that includes all vertices and is a tree. All spanning trees of a graph have the same number of vertices and exactly (V - 1) edges.",
        "target_text": "Question: All possible spanning trees of graph G:\nChoices:\na) have same number of edges and vertices.\nb) have same number of edges and but not vertices.\nc) have same number of vertices but not edges.\nd) depends upon algorithm being used.\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: A self-balancing binary search tree ensures logarithmic height. The minimum height for `n` nodes in such a tree is approximately log2(n).",
        "target_text": "Question: The minimum height of self balancing binary search tree with n nodes is __________\nChoices:\na) log2(n)\nb) n\nc) 2n + 1\nd) 2n - 1\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Random trees are generated using probabilistic algorithms. AVL trees are deterministic and follow strict balancing rules, making them non-random trees.",
        "target_text": "Question: Which of the following is not a random tree?\nChoices:\na) Treap\nb) Random Binary Tree\nc) Uniform Spanning Tree\nd) AVL Tree\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: XOR linked lists use a single pointer per node that stores the XOR of previous and next node addresses. This reduces memory usage compared to traditional doubly linked lists.",
        "target_text": "Question: Is it possible to create a doubly linked list using only one pointer with every node.\nChoices:\na) Not Possible\nb) Yes, possible by storing XOR of addresses of previous and next nodes.\nc) Yes, possible by storing XOR of current node and next node\nd) Yes, possible by storing XOR of current node and previous node\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a BFS traversal of an undirected graph, any non-tree edge (u, v) connects nodes that are at the same level or one level apart. A difference of more than 1 is not possible.",
        "target_text": "Question: Let G = (V, E) be a simple undirected graph, and s be a particular vertex in it called the source. For x is an element of V, let d(x) denote the shortest distance in G from s to x. A breadth first search (BFS) is performed starting at s. Let T be the resultant BFS tree. If (u, v) is an edge of G that is not in T, then which one of the following CANNOT be the value of d(u) - d(v)?\nChoices:\na) -1\nb) 0\nc) 1\nd) 2\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Arrays provide a way to store elements of the same data type in contiguous memory locations. They are simple to use and offer efficient indexing.",
        "target_text": "Question: 9. What are the advantages of arrays?\nChoices:\na) Objects of mixed data types can be stored\nb) Elements in an array cannot be sorted\nc) Index of first element of an array is 1\nd) Easier to store elements of same data type\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: A special sparse matrix has mostly zero elements but follows a specific structure. A band matrix is one such type, where non-zero elements are confined to a diagonal band.",
        "target_text": "Question: Which one of the following is a Special Sparse Matrix?\nChoices:\na) Band Matrix\nb) Skew Matrix\nc) Null matrix\nd) Unit matrix\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Deleting a node from a singly linked list requires adjusting the previous node's next pointer to skip over the node being deleted. The implementation must carefully check bounds and node existence.",
        "target_text": "Question: How would you delete a node in the singly linked list? The position to be deleted is given.\nChoices:\na) \npublic void delete(int pos)\n{\n if(pos < 0)\n pos = 0;\n if(pos > size)\n pos = size;\n if( size == 0)\n return;\n if(pos == 0)\n head = head.getNext();\n else\n {\n     Node temp = head;\n     for(int i=1; i<pos; i++)\n            {\n  temp = temp.getNext();\n            }\n     temp.setNext(temp.getNext().getNext());\n }\n     size--;\n}\npublic void delete(int pos)\n{\n if(pos < 0)\n pos = 0;\n if(pos > size)\n pos = size;\n if( size == 0)\n return;\n if(pos == 0)\n head = head.getNext();\n else\n {\n     Node temp = head;\n     for(int i=1; i<pos; i++)\n     {\n  temp = temp.getNext();\n     }\n     temp.setNext(temp.getNext());\n }\n     size--;\n}\npublic void delete(int pos)\n{\n        if(pos < 0)\n pos = 0;\n if(pos > size)\n pos = size;\n if( size == 0)\n return;\n if(pos == 0)\n head = head.getNext();\n else\n {\n     Node temp = head;\n     for(int i=1; i<pos; i++)\n     {\n  temp = temp.getNext().getNext();\n            }\n     temp.setNext(temp.getNext().getNext());\n }\n     size--;\n}\npublic void delete(int pos)\n{\n        if(pos < 0)\n        pos = 0;\n        if(pos > size)\n        pos = size;\n        if( size == 0)\n return;\n if(pos == 0)\n head = head.getNext();\n else\n {\n     Node temp = head;\n     for(int i=0; i<pos; i++)\n     {\n  temp = temp.getNext();\n     }\n     temp.setNext(temp.getNext().getNext());\n }\n size--;\n}\nd)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: XOR linked lists use a single field to store the XOR of the addresses of previous and next nodes. The first node XORs NULL and the address of the second node; the last node XORs its previous node and NULL.",
        "target_text": "Question: What does first and last nodes of a xor linked lists contain ? (let address of first and last be A and B)\nChoices:\na) NULL xor A and B xor NULL\nb) NULL and NULL\nc) A and B\nd) NULL xor A and B\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Simple uniform hashing assumes that every key is equally likely to hash into any of the available slots in the hash table, resulting in uniform distribution.",
        "target_text": "Question: What is simple uniform hashing?\nChoices:\na) Every element has equal probability of hashing into any of the slots\nb) A weighted probabilistic method is used to hash elements into the slots\nc) Elements has Random probability of hashing into array slots\nd) Elements are hashed based on priority\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: A suffix tree is a compressed trie used for efficient full-text searches, particularly in string processing and bioinformatics.",
        "target_text": "Question: Which of the following special type of trie is used for fast searching of the full texts?\nChoices:\na) Ctrie\nb) Hash tree\nc) Suffix tree\nd) T tree\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In queue data structures, attempting to insert an element into a full queue results in an overflow condition, especially in fixed-size implementations like arrays.",
        "target_text": "Question: What is the term for inserting into a full queue known as?\nChoices:\na) overflow\nb) underflow\nc) null pointer exception\nd) program won't be compiled\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: In array-based dequeue operations (double-ended queue), elements can be inserted and removed from both ends. Each element may be touched multiple times for shifting or reordering, potentially up to four times in certain implementations.",
        "target_text": "Question: Given an array of size n, let's assume an element is 'touched' if and only if some operation is performed on it(for example, for performing a pop operation the top element is 'touched'). Now you need to perform Dequeue operation. Each element in the array is touched atleast?\nChoices:\na) Once\nb) Twice\nc) Thrice\nd) Four times\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In C, memory allocated using `malloc` or `calloc` should be released using `free`. For deleting nodes in an expression tree, `free` is used to deallocate the memory.",
        "target_text": "Question: An expression tree's nodes can be deleted by calling?\nChoices:\na) malloc\nb) calloc\nc) delete\nd) free\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: In data structures and algorithms, a naive merge strategy can sometimes still apply in skewed merges, depending on the case. The claim that naive merge cannot be done is False.",
        "target_text": "Question: Naive merge cannot be done in a skew merge.\nChoices:\na) True\nb) False\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Prefix notation (Polish notation) expressions must include the expression itself. Without it, no solution is possible. This question appears to be missing the actual prefix expression.",
        "target_text": "Question: What would be the solution to the given prefix notation?\nChoices:\na) 14\nb) 15\nc) 18\nd) 12\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Reversing an array involves swapping pairs of elements from both ends toward the center. For an array of even length n, exactly n/2 swaps are required.",
        "target_text": "Question: How many swaps are required for reversing an array having n elements where n is an even number?\nChoices:\na) (n-1) / 2\nb) n/2\nc) (n/2) - 1\nd) (n+1)/2\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Height-balanced binary search trees (like AVL trees) can efficiently implement abstract data types such as sets and priority queues due to their balanced structure and fast lookup and update times.",
        "target_text": "Question: Which of the following data structures can be efficiently implemented using height balanced binary search tree?\nChoices:\na) sets\nb) priority queue\nc) heap\nd) both sets and priority queue\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: A leftist heap is a variant of a binary heap that is designed to support efficient merging of two heaps. Merging is the fundamental operation upon which others like insertion and deletion are based.",
        "target_text": "Question: What is the fundamental operation on leftist heap?\nChoices:\na) insertion\nb) merging\nc) deletion\nd) swapping\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a doubly linked list, inserting a node at the front shifts the current head to the second position. If `6` is inserted at the beginning of the list `1-2-3-4-5`, the result will be `6-1-2-3-4`, assuming the last element is removed.",
        "target_text": "Question: Consider the following doubly linked list: head-1-2-3-4-5-tail. What will be the list after performing the given sequence of operations?\nChoices:\na) head-6-1-2-3-4-5-tail\nb) head-6-1-2-3-4-tail\nc) head-1-2-3-4-5-6-tail\nd) head-1-2-3-4-5-tail\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a binary search tree, the number of different search paths to a specific key depends on the structure of the tree. For searching key `60`, the order of traversal over 7 nodes can occur in C(7,3) = 35 ways.",
        "target_text": "Question: When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root to the node containing the value 60?\nChoices:\na) 35\nb) 64\nc) 128\nd) 5040\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Balanced symbol expressions ensure that every opening bracket has a corresponding closing bracket of the same type and properly nested. An expression like `((A+B)+(C+D)` is unbalanced.",
        "target_text": "Question: Which of the following statement is invalid with respect to balancing symbols?\nChoices:\na) [(A+B) + (C-D)]\nb) [{A+B}-{C-[D+E]}]\nc) ((A+B) + (C+D)\nd) {(A+B) + [C+D]}\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: Insertion Sort is efficient for nearly sorted data because it performs fewer comparisons and shifts compared to other algorithms. Bubble Sort, though simple, is less efficient in general.",
        "target_text": "Question: Which of the following sorting methods would be most suitable for sorting a list which is almost sorted?\nChoices:\na) Bubble Sort\nb) Insertion Sort\nc) Selection Sort\nd) Quick Sort\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: A palindrome is a word that reads the same backward as forward. 'Maadam' is not a palindrome due to its asymmetric spelling.",
        "target_text": "Question: Which among the following is not a palindrome?\nChoices:\na) Madam\nb) Dad\nc) Malayalam\nd) Maadam\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Bit arrays are commonly used in applications like Bloom filters and bitmaps. To find the first occurrence of a `1` in a bit array, a `Find First One` operation is typically used.",
        "target_text": "Question: Which one of the following operations returns the first occurrence of bit 1 in bit arrays?\nChoices:\na) Find First Zero\nb) Find First One\nc) Counting lead Zeroes\nd) Counting lead One\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: The Jaccard Coefficient is a statistical measure used to compare the similarity between two sets. It is defined as the size of the intersection divided by the size of the union of the sets.",
        "target_text": "Question: Which indicator is used for similarity between two sets?\nChoices:\na) Rope Tree\nb) Jaccard Coefficient\nc) Tango Tree\nd) MinHash Coefficient\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: A binary tree supports three primary traversal orders: in-order, pre-order, and post-order. Level-order traversal is also applicable, but generally the number of basic traversal orders is considered to be 3.",
        "target_text": "Question: How many orders of traversal are applicable to a binary tree (In General)?\nChoices:\na) 1\nb) 4\nc) 2\nd) 3\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In any K-ary tree, the root node is always at depth 0. Depth is defined as the number of edges from the root to a given node.",
        "target_text": "Question: What is the depth of the root node of K-ary tree?\nChoices:\na) 2\nb) 1\nc) 0\nd) 3\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: The average depth of a binary tree gives an idea of how far nodes are from the root on average. It is often approximated by O(sqrt(N)) in randomly constructed binary trees.",
        "target_text": "Question: The average depth of a binary tree is given as?\nChoices:\na) O(N)\nb) O(log N)\nc) O(M log N)\nd) O(sqrt(N))\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a B-tree of minimum degree t, each node can have at most 2t children (pointers), and hence a maximum of 2t pointers.",
        "target_text": "Question: A B-tree of minimum degree t can maximum __________ pointers in a node.\nChoices:\na) t-1\nb) 2t-1\nc) 2t\nd) t\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a singly or doubly linked list, searching requires sequential traversal from the head node, leading to a linear time complexity of O(n).",
        "target_text": "Question: The time required to search an element in a linked list of length n is\nChoices:\na) O (log n)\nb) O (n)\nc) O (1)\nd) O (n2)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Splay trees are self-adjusting binary search trees. They are used in applications such as cache implementation where frequently accessed elements are moved closer to the root.",
        "target_text": "Question: Which of the following options is an application of splay trees?\nChoices:\na) cache Implementation\nb) networks\nc) send values\nd) receive values\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Graph | Context: A graph is bipartite if and only if it does not contain any cycles of odd length. This is a necessary and sufficient condition for bipartiteness.",
        "target_text": "Question: A graph 'G' with 'n' nodes is bipartite if it contains __________\nChoices:\na) n edges\nb) a cycle of odd length\nc) no cycle of odd length\nd) n2 edges\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A queue is a linear data structure where insertion (enqueue) occurs at the rear and deletion (dequeue) occurs at the front. This behavior classifies it as FIFO.",
        "target_text": "Question: A linear list of elements in which deletion can be done from one end (front) and insertion can take place only at the other end (rear) is known as __________\nChoices:\na) Queue\nb) Stack\nc) Tree\nd) Linked list\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: When a node with two children is deleted in a binary search tree, it is typically replaced with its in-order successor (the next larger node) to maintain the BST properties.",
        "target_text": "Question: If a node having two children is deleted from a binary tree, it is replaced by its __________\nChoices:\na) In-order predecessor\nb) In-order successor\nc) Pre-order predecessor\nd) None of these\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Queue | Context: A priority queue allows elements to be processed based on priority. While it efficiently handles priority-based operations, arbitrary deletions (deleting any element) are not straightforward or efficient.",
        "target_text": "Question: Which of the following is not an advantage of a priority queue?\nChoices:\na) Easy to implement\nb) Processes with different priority can be efficiently handled\nc) Applications with differing requirements\nd) Easy to delete elements in any case\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Heaps are typically complete binary trees, which are well-suited to array representations. Arrays provide better memory efficiency and caching compared to linked tree structures.",
        "target_text": "Question: Why is heap implemented using array representations than tree(linked list) representations though both tree representations and heaps have same complexities?\nThen why go with array representation when both are having same values ?\nChoices:\na) arrays can store trees which are complete and heaps are not complete\nb) lists representation takes more memory hence memory efficiency is less and go with arrays and arrays have better caching\nc) lists have better caching\nd) In lists insertion and deletion is difficult\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Open addressing and separate chaining are two methods to resolve hash collisions. Open addressing can be easier to implement because it does not require additional data structures like linked lists.",
        "target_text": "Question: Which of the following is an advantage of open addressing over separate chaining?\nChoices:\na) it is simpler to implement\nb) table never gets full\nc) it is less sensitive to hash function\nd) it has better cache performance\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a binary search tree (BST), the minimum element is found by traversing left from the root until the leftmost node is reached.",
        "target_text": "Question: How will you find the minimum element in a binary search tree?\nChoices:\na) \npublic void min(Tree root)\n{\n while(root.left() != null)\n {\n  root = root.left();\n }\n System.out.println(root.data());\n}\npublic void min(Tree root)\n{\n while(root != null)\n {\n  root = root.left();\n }\n System.out.println(root.data());\n}\npublic void min(Tree root)\n{\n while(root.right() != null)\n {\n  root = root.right();\n }\n System.out.println(root.data());\n}\npublic void min(Tree root)\n{\n while(root != null)\n {\n  root = root.right();\n }\n System.out.println(root.data());\n}\nd)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In threaded binary trees, null pointers are replaced with references to in-order predecessors and successors to allow for efficient non-recursive traversal.",
        "target_text": "Question: What are null nodes filled with in a threaded binary tree?\nChoices:\na) inorder predecessor for left node and inorder successor for right node information\nb) right node with inorder predecessor and left node with inorder successor information\nc) they remain null\nd) some other values randomly\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a d-heap (a generalization of a binary heap where each node has d children), most operations like insert and delete are efficient, but merging two d-heaps is not efficient without specialized data structures.",
        "target_text": "Question: Which operation is not efficiently performed in a d-heap?\nChoices:\na) insert\nb) delete\nc) find\nd) merge\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a circular linked list representation of a queue, maintaining a single pointer to the rear node allows both enQueue (insert at rear) and deQueue (delete from front) operations to be performed in constant time.",
        "target_text": "Question: A circularly linked list is used to represent a Queue. A single variable p is used to access the Queue. To which node should p point such that both the operations enQueue and deQueue can be performed in constant time? (GATE 2004) \nChoices:\na) rear node\nb) front node\nc) not possible with a single pointer\nd) node next to front\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: A binomial heap supports efficient union operations, unlike binary heaps. It consists of a collection of binomial trees, allowing union in logarithmic time.",
        "target_text": "Question: The main distinguishable characterstic of a binomial heap from a binary heap is that\nChoices:\na) it allows union operations very efficiently\nb) it does not allow union operations that could easily be implemented in binary heap\nc) the heap structure is not similar to complete binary tree\nd) the location of child node is not fixed i.e child nodes could be at level (h-2) or (h-3), where h is height of heap and h>4\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: For pre-order and post-order traversals to be the same, the tree must have only one node. With more than one node, the traversal orders will differ.",
        "target_text": "Question: The maximum number of nodes in a tree for which post-order and pre-order traversals may be equal is __________\nChoices:\na) 3\nb) 1\nc) 2\nd) any number\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: If a Directed Acyclic Graph (DAG) has more than one valid topological sort, then it cannot have exactly one Hamiltonian path. A unique topological sort would imply exactly one such path.",
        "target_text": "Question: If there are more than 1 topological sorting of a DAG is possible, which of the following is True.\nChoices:\na) Many Hamiltonian paths are possible\nb) No Hamiltonian path is possible\nc) Exactly 1 Hamiltonian path is possible\nd) Given information is insufficient to comment anything\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: AVL trees are more strictly balanced than Red-Black trees, which may result in more rotations during insertion and deletion. Red-Black trees allow faster updates but are less balanced.",
        "target_text": "Question: Which of the following is True\nChoices:\na) The AVL trees are more balanced compared to Red Black Trees, but they may cause more rotations during insertion and deletion.\nb) Heights of AVL and Red-Black trees are generally same, but AVL Trees may cause more rotations during insertion and deletion.\nc) Red Black trees are more balanced compared to AVL Trees, but may cause more rotations during insertion and deletion.\nd) Heights of AVL and Red-Black trees are generally same, but Red Black trees may cause more rotations during insertion and deletion.\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: A Hash tree (or Merkle tree) uses hashing to support direct access and data integrity verification. It does not provide sequential access.",
        "target_text": "Question: Which of the following is True for a Hash tree?\nChoices:\na) Hashing is used for sequential access\nb) Indexing is used for direct access\nc) Hash tree allows only sequential access\nd) Hashing is used for direct access\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A triply linked list is an extension of doubly linked lists and is dynamic in nature, allowing flexible memory usage. It supports forward and backward traversal and an additional pointer for special operations.",
        "target_text": "Question: Which of the following is True about a triply linked list?\nChoices:\na) Dynamic in nature\nb) Allows random access\nc) Less memory wastage\nd) Reverse traversing is difficult\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Graph | Context: A graph can consist of only vertices and no edges (called an edgeless graph). However, it cannot contain edges without vertices, since edges must connect vertices.",
        "target_text": "Question: Which of the following is True?\nChoices:\na) A graph may contain no edges and many vertices\nb) A graph may contain many edges and no vertices\nc) A graph may contain no edges and no vertices\nd) A graph may contain no vertices and many edges\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: The number of inversions in an array indicates how far the array is from being sorted. A common method to compute inversions efficiently is via a modified merge sort algorithm.",
        "target_text": "Question: Choose the correct function from the following which determines the number of inversions in an array?\nChoices:\na) Using bubble sort comparisons\nb) Using merge sort with inversion count logic\nc) Using simple count of unequal elements\nd) Using linear scan for each element\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: A B+ tree is a type of self-balancing tree structure that allows both rapid sequential access (via leaf node chaining) and rapid random access (through internal indexing).",
        "target_text": "Question: Which of the following is True?\nChoices:\na) B + tree allows only the rapid random access\nb) B + tree allows only the rapid sequential access\nc) B + tree allows rapid random access as well as rapid sequential access\nd) B + tree allows rapid random access and slower sequential access\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Priority queues can be implemented using multiple queues for different priority levels. A minimum of 2 queues is required--one for high and one for low priority elements.",
        "target_text": "Question: Minimum number of queues required for priority queue implementation?\nChoices:\na) 5\nb) 4\nc) 3\nd) 2\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Standard operator precedence rules apply: division and multiplication before addition. The expression `a/b + c*d` with values a=4, b=2, c=2, d=1 becomes 2 + 2 = 4.",
        "target_text": "Question: Evaluate the following and choose the correct answer.\na/b+c*d where a=4, b=2, c=2, d=1.\nChoices:\na) 1\nb) 4\nc) 5\nd) 2\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Threaded binary trees use null pointers to link to in-order predecessor and successor nodes, allowing all standard traversals (in-order, pre-order, post-order) to be performed efficiently.",
        "target_text": "Question: Which of the following tree traversals work if the null left pointer pointing to the predecessor and null right pointer pointing to the successor in a binary tree?\nChoices:\na) inorder, postorder, preorder traversals\nb) inorder\nc) postorder\nd) preorder\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In expression trees, evaluating and converting them to infix form involves recursive traversal. This problem assumes a correct traversal and evaluation path to yield 12.",
        "target_text": "Question: From the given expression tree, identify the infix expression, evaluate it and choose the correct result.\nChoices:\na) 5\nb) 10\nc) 12\nd) 16\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: When implementing a queue with a linked list, inserting at one end (e.g., rear) and deleting from the other (e.g., front) maintains FIFO order. Option a describes this behavior correctly.",
        "target_text": "Question: Which of the following is True about linked list implementation of queue?\nChoices:\na) In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end\nb) In push operation, if new nodes are inserted at the beginning, then in pop operation, nodes must be removed from the beginning\nc) In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from end\nd) In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from beginning\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: According to operator precedence, multiplication is done before addition and subtraction. The expression `1+2*3-2` evaluates as `1 + 6 - 2 = 5`.",
        "target_text": "Question: Evaluate the following statement using infix evaluation algorithm and choose the correct answer. 1+2*3-2\nChoices:\na) 3\nb) 6\nc) 5\nd) 4\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In Binary Search Tree deletion, when a node has two children, it's replaced with its inorder successor or predecessor. The inorder successor is either a leaf or has no left child.",
        "target_text": "Question: In delete operation of BST, we need inorder successor (or predecessor) of a node when the node to be deleted has both left and right child as non-empty. Which of the following is True about inorder successor needed in delete operation?\nChoices:\na) Inorder Successor is always a leaf node\nb) Inorder successor is always either a leaf node or a node with empty left child\nc) Inorder successor may be an ancestor of the node\nd) Inorder successor is always either a leaf node or a node with empty right child\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Post-order traversal of an expression tree prints operands first, followed by operators. For (7 - (4 * 5)) + (9 / 3), the post-order is 745*-93/+.",
        "target_text": "Question: For the expression (7-(4*5))+(9/3) which of the following is the post order tree traversal?\nChoices:\na) *745-93/+\nb) 93/+745*-\nc) 745*-93/+\nd) 74*+593/-\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Stack implemented with arrays has fixed size; resizing requires reallocation. This limits flexibility and is the main drawback of array-based stacks.",
        "target_text": "Question: Array implementation of Stack is not dynamic, which of the following statements supports this argument?\nChoices:\na) space allocation for array is fixed and cannot be changed during run-time\nb) user unable to give the input for stack operations\nc) a runtime exception halts execution\nd) improper program compilation\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: The Move-To-Front heuristic reorganizes data to improve access time. However, it may bring infrequently accessed nodes to the front, potentially decreasing performance.",
        "target_text": "Question: Which of the following is True about the Move-To-Front Method for rearranging nodes?\nChoices:\na) node with highest access count is moved to head of the list\nb) requires extra storage\nc) may over-reward infrequently accessed nodes\nd) requires a counter for each node\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Searching in AVL trees is \u03b8(log n) due to their balanced nature, while unbalanced BSTs may degrade to O(n) in worst case.",
        "target_text": "Question: Which of the following is TRUE?\nChoices:\na) The cost of searching an AVL tree is \u03b8 (log n) but that of a binary search tree is O(n)\nb) The cost of searching an AVL tree is \u03b8 (log n) but that of a complete binary tree is \u03b8 (n log n)\nc) The cost of searching a binary search tree is O (log n ) but that of an AVL tree is \u03b8(n)\nd) The cost of searching an AVL tree is \u03b8 (n log n) but that of a binary search tree is O(n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack operations like push and pop must respect stack size. The given sequence respects the size limit and does not cause overflow or underflow.",
        "target_text": "Question: Consider the following operations performed on a stack of size 5 : Push (a); Pop() ; Push(b); Push(c); Pop(); Push(d); Pop();Pop(); Push (e) Which of the following statements is correct?\nChoices:\na) Underflow occurs\nb) Stack operations are performed smoothly\nc) Overflow occurs\nd) None of the above\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In a linked list implementation of a queue, you can insert at the beginning and remove from the end, or vice versa, depending on your implementation. Both configurations are valid.",
        "target_text": "Question: Which of the following is True about linked list implementation of queue?\nChoices:\na) In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end.\nb) In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from the beginning.\nc) Both of the above\nd) None of the above\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In B-trees, the higher the order (maximum number of children), the more keys each node can hold. This reduces the frequency of splits because nodes can accommodate more insertions.",
        "target_text": "Question: Which of the following is True?\nChoices:\na) larger the order of B-tree, less frequently the split occurs\nb) larger the order of B-tree, more frequently the split occurs\nc) smaller the order of B-tree, more frequently the split occurs\nd) smaller the order of B-tree, less frequently the split occurs\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Using standard operator precedence (exponentiation > multiplication/division > addition/subtraction), evaluate a + b * c - d / e ^ f with given values: 1 + 2*3 - 4/4 = 1 + 6 - 1 = 6.",
        "target_text": "Question: Evaluate the following infix expression using algorithm and choose the correct answer. a+b*c-d/e^f where a=1, b=2, c=3, d=4, e=2, f=2.\nChoices:\na) 6\nb) 8\nc) 9\nd) 7\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: String | Context: In a trie (prefix tree), strings are stored such that the path from the root to a leaf represents a string. Each node contains character edges to its children.",
        "target_text": "Question: Which of the following is True about the trie?\nChoices:\na) root is letter a\nb) path from root to the leaf yields the string\nc) children of nodes are randomly ordered\nd) each node stores the associated keys\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In normal binary trees, many pointers in the structure may be null (especially in leaf nodes), which leads to space inefficiency. Threaded binary trees solve this by reusing null pointers.",
        "target_text": "Question: What are the disadvantages of normal binary tree traversals?\nChoices:\na) there are many pointers which are null and thus useless\nb) there is no traversal which is efficient\nc) complexity in implementing\nd) improper traversals\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: In evaluating `a^b + c` with a=2, b=2, c=2, we compute 2^2 + 2 = 4 + 2 = 6.",
        "target_text": "Question: Using the evaluation of infix expression, evaluate a^b+c and choose the correct answer. (a=2, b=2, c=2)\nChoices:\na) 12\nb) 8\nc) 10\nd) 6\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Binary trees can be both complete and full, but not all binary trees satisfy these properties. Therefore, none of the listed options are universally True.",
        "target_text": "Question: Which of the following is True about Binary Trees?\nChoices:\na) Every binary tree is either complete or full.\nb) Every complete binary tree is also a full binary tree.\nc) Every full binary tree is also a complete binary tree.\nd) No binary tree is both complete and full.', 'E\\nNone of the above\nAnswer: E\nNone of the above"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Standard infix evaluation respects operator precedence: multiplication/division before addition/subtraction. The expression `4*2 + 3 - 5/5` = `8 + 3 - 1` = `10`.",
        "target_text": "Question: Evaluate the following statement using infix evaluation algorithm and choose the correct answer. 4*2+3-5/5\nChoices:\na) 10\nb) 11\nc) 16\nd) 12\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a weak-heap, each right child has a greater value than its parent. It is a relaxed version of the min-heap with specific rules enabling better performance in certain cases.",
        "target_text": "Question: Choose the correct properties of weak-heap.\nChoices:\na) Every node has value greater than the value of child node\nb) Every right child of node has greater value than parent node\nc) Every left child of node has greater value than parent node\nd) Every left and right child of node has same value as parent node\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Stack | Context: A threaded binary tree replaces null pointers with pointers to in-order predecessor or successor, enabling traversal without stacks or queues.",
        "target_text": "Question: What is a threaded binary tree traversal?\nChoices:\na) a binary tree traversal using stacks\nb) a binary tree traversal using queues\nc) a binary tree traversal using stacks and queues\nd) a binary tree traversal without using stacks and queues\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: To evaluate an expression tree (or syntax tree), post-order traversal is used because it first visits subtrees (operands) before applying the operator (root).",
        "target_text": "Question: Which tree traversal technique is used to evaluate the expression represented by syntax tree?\nChoices:\na) Pre-order traversal\nb) In-order traversal\nc) Post-order traversal\nd) Breadth first traversal\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: If delete and decrease-key operations are rare and provided with direct access, an unsorted array allows O(1) insertions and direct deletions, making it optimal for minimizing total cost.",
        "target_text": "Question: An algorithm performs (logN)^1/2 find operations, N insert operations, (logN)^1/2 delete operations, and (logN)^1/2 decrease-key operations on a set of data items with keys drawn from a linearly ordered set. For a delete operation, a pointer is provided to the record that must be deleted. For the decrease-key operation, a pointer is provided to the record that has its key decreased. Which one of the following data structures is the most suited for the algorithm to use, if the goal is to achieve the best total asymptotic complexity considering all the operations?\nChoices:\na) Unsorted array\nb) Min-heap\nc) Sorted array\nd) Sorted doubly linked list\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: In a hash table with chaining using a list head, deleting an element pointed to by a reference is done in constant time, giving a time complexity of O(1).",
        "target_text": "Question: What is the time complexity of delete function in the hash table using list head?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: AA-Trees are balanced binary search trees with worst-case time complexity for operations like search, insert, and delete being O(log N), similar to AVL or Red-Black trees.",
        "target_text": "Question: What is the worst case analysis of an AA-Tree?\nChoices:\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(N^2)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a ternary heap, each node has 3 children. The height is log base 3 of n. Decreasing a key may involve bubbling down the tree, taking O(3 * log n / log 3) time in the worst case.",
        "target_text": "Question: What is the time complexity for decreasing priority of key in a maximum ternary heap of n elements?\nChoices:\na) O(log n / log 3)\nb) O(3 log n / log 3)\nc) O(n)\nd) O(1)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a circular linked list, searching for a specific element still requires traversing up to n elements in the worst case, giving a time complexity of O(n).",
        "target_text": "Question: What is the time complexity of searching for an element in a circular linked list?\nChoices:\na) O(n)\nb) O(nlogn)\nc) O(1)\nd) O(n^2)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Finding all tandem repeats (repeated substrings appearing consecutively) can be done using suffix trees in O(n log n + z), where z is the number of such repeats.",
        "target_text": "Question: What is a time complexity for finding all the tandem repeats?\nChoices:\na) \u0398(n)\nb) \u0398(n!)\nc) \u0398(1)\nd) O(n log n + z)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: While hash tables offer O(1) average-case time complexity, self-balancing BSTs offer O(log n). Hence, BSTs are worse than hash tables in the average case.",
        "target_text": "Question: Self - balancing binary search trees have a much better average-case time complexity than hash tables.\nChoices:\na) True\nb) False\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Generalized suffix trees can be used to find the longest palindromic substring in linear time using clever traversal and string manipulations.",
        "target_text": "Question: What is a time complexity for finding the longest palindromic substring in a string by using the generalized suffix tree?\nChoices:\na) Linear Time\nb) Exponential Time\nc) Logarithmic Time\nd) Cubic Time\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Dynamic arrays provide amortized O(1) time complexity for insertion at the end. But resizing may take O(n), so worst case is O(n).",
        "target_text": "Question: What is the time complexity of inserting at the end in dynamic arrays?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) Either O(1) or O(n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: When using separate chaining with a list head in a hash table, if a key is present at the head, it can be found in constant time O(1) on average.",
        "target_text": "Question: What is the time complexity of search function in a hash table using list head?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Finding the minimum number of steps to reach the end of an array (e.g., jump game) can be solved using greedy or dynamic programming in O(n) time.",
        "target_text": "Question: What is the minimum possible time complexity to find the number of steps to reach the end of an array?\nChoices:\na) O(n)\nb) O(n^2)\nc) O(n^{3/2})\nd) O(1)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Appending to a variable-length array may cause reallocation when capacity is exceeded, leading to O(n) time in the worst case.",
        "target_text": "Question: Which among the following is the worst-case time complexity for appending an element in a variable-length array?\nChoices:\na) O(n)\nb) O(1)\nc) O(n^2)\nd) O(log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: A Van Emde Boas (vEB) tree can store up to M elements with linear space O(M). It offers fast operations like insert, delete, and search in O(log log M) time.",
        "target_text": "Question: What is the time complexity for storing the maximum number of elements in Van Emde Boas tree if M is the maximum number of elements?\nChoices:\na) O(log M)\nb) O(M!)\nc) O(M)\nd) O(1)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a ternary heap, each node has up to 3 children. The height of the heap is log base 3 of n, so inserting takes O(log n / log 3) time in the worst case.",
        "target_text": "Question: What is the time complexity for inserting a new item in a ternary heap of n elements?\nChoices:\na) O(log n / log 3)\nb) O(n!)\nc) O(n)\nd) O(1)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Implementing a stack using queues (especially a single queue) can lead to O(n) time complexity for some operations, making it inefficient for large datasets.",
        "target_text": "Question: Why is implementation of stack operations on queues not feasible for a large dataset (Assume the number of elements in the stack to be n)?\nChoices:\na) Because of its time complexity O(n)\nb) Because of its time complexity O(log(n))\nc) Extra memory is not required\nd) There are no problems\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: Merge Sort is a divide-and-conquer algorithm with a guaranteed worst-case time complexity of O(n log n), unlike other elementary sorts like Bubble or Insertion Sort.",
        "target_text": "Question: Which of the following sorting algorithms does not have a worst case running time of O(n^2) ?\nChoices:\na) Insertion sort\nb) Merge sort\nc) Quick sort\nd) Bubble sort\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a singly or doubly linked list, searching for a specific element requires traversing the list from the head to the desired node, resulting in O(n) time in the worst case.",
        "target_text": "Question: What would be the asymptotic time complexity to find an element in the linked list?\nChoices:\na) O(1)\nb) O(n)\nc) O(n^2)\nd) O(n^4)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Inserting at the second position in a linked list requires only a single traversal step and pointer adjustment, which takes constant time, i.e., O(1).",
        "target_text": "Question: What would be the asymptotic time complexity to insert an element at the second position in the linked list?\nChoices:\na) O(1)\nb) O(n)\nc) O(n^2)\nd) O(n^3)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a binary min-heap, the maximum element is not necessarily at the root and could be in any of the leaf nodes. To find it requires scanning up to n/2 leaf nodes, giving \u03b8(n) time.",
        "target_text": "Question: Let H be a binary min-heap consisting of n elements implemented as an array. What is the worst case time complexity of an optimal algorithm to find the maximum element in H?\nChoices:\na) \u03b8(1)\nb) \u03b8(logn)\nc) \u03b8(n)\nd) \u03b8(nlogn)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: In separate chaining, the worst-case scenario occurs when all elements hash to the same bucket, resulting in a linear search through a linked list. This gives O(n) worst-case search time.",
        "target_text": "Question: What is the worst case search time of a hashing using separate chaining algorithm?\nChoices:\na) O(n log n)\nb) O(n)\nc) O(n^2)\nd) O(n^3)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: The Build Heap operation for constructing a binary heap from an array of n elements has a time complexity of O(n), not O(n log n), due to the reduced cost of heapifying lower levels.",
        "target_text": "Question: What is the time complexity of Build Heap operation? \n(Build Heap is used to build a max(or min) binary heap from a given array. Build Heap is used in Heap Sort as a first step for sorting.)\nChoices:\na) O(n log n)\nb) O(n^2)\nc) O(n)\nd) O(log n)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Graph | Context: If an adjacency matrix is used to represent a graph, checking for the existence of an edge between two vertices takes O(1) time, and does not depend on the number of vertices or edges.",
        "target_text": "Question: On which of the following statements does the time complexity of checking if an edge exists between two particular vertices not depend?\nChoices:\na) Depends on the number of edges\nb) Depends on the number of vertices\nc) Is independent of both the number of edges and vertices\nd) It depends on both the number of edges and vertices\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: When a binary search tree is used for chaining in a hash table, insertion into the tree (assuming it is balanced) takes O(log n), but inserting at the head or tail of a list in chaining takes O(1).",
        "target_text": "Question: What is the time complexity of insert function in a hash table using a binary tree?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Splay trees provide amortized time complexity guarantees. A sequence of j operations on a splay tree with at most h nodes takes O(j log h) time in the worst case.",
        "target_text": "Question: Which of the following property of splay tree is correct?\nChoices:\na) it holds probability usage of the respective sub trees\nb) any sequence of j operations starting from an empty tree with h nodes at most, takes O(j log h) time complexity\nc) sequence of operations with h nodes can take O(log h) time complexity\nd) splay trees are unstable trees\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Project scheduling can be modeled using optimization techniques such as Dynamic Programming, especially when overlapping subproblems are involved.",
        "target_text": "Question: Project scheduling is an example of __________\nChoices:\na) Greedy programming\nb) Dynamic programming \\n (A) Greedy programming \\n (B) Dynamic programming\nc) Divide and conquer\nd) None of the above.\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Inserting n^2 elements into an AVL tree with n initial elements involves multiple insertions, each costing O(log n), leading to a total time complexity of \u03b8(n^2 log n).",
        "target_text": "Question: What is the worst case time complexity of inserting n^2 elements into an AVL-tree with n elements initially ?\nChoices:\na) \u03b8(n^4)\nb) \u03b8(n^2)\nc) \u03b8(n^2 log n)\nd) \u03b8(n^3)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a circular linked list, to count nodes we loop until we reach the head again. The correct method must check `while(temp != head)` and increment the count properly.",
        "target_text": "Question: How do you count the number of elements in the circular linked list?\nChoices:\na) \npublic int length(Node head)\n{\n int length = 0;\n if( head == null)\n  return 0;\n Node temp = head.getNext();\n while(temp != head)\n {\n  temp = temp.getNext();\n  length++;\n }\n return length;\n}\npublic int length(Node head)\n{\n int length = 0;\n if( head == null)\n  return 0;\n Node temp = head.getNext();\n while(temp != null)\n {\n  temp = temp.getNext();\n  length++;\n }\n return length;\n}\npublic int length(Node head)\n{\n int length = 0;\n if( head == null)\n  return 0;\n Node temp = head.getNext();\n while(temp != head && temp != null)\n {\n  temp = head.getNext();\n  length++;\n }\n return length;\n}\npublic int length(Node head)\n{\n int length = 0;\n if( head == null)\n  return 0;\n Node temp = head.getNext();\n while(temp != head && temp == null)\n {\n  temp = head.getNext();\n  length++;\n }\n return length;\n}\nd)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Level order traversal visits nodes breadth-first, processing each node once. The total complexity is linear in the number of nodes, O(n).",
        "target_text": "Question: What is the time complexity of level order traversal?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Red-black trees are preferred over hash tables when ordered data or range queries are needed. Hash tables require resizing and do not maintain order.",
        "target_text": "Question: Why Red-black trees are preferred over hash tables though hash tables have constant time complexity?\nChoices:\na) no they are not preferred\nb) because of resizing issues of hash table and better ordering in red-black trees\nc) because they can be implemented using trees\nd) because they are balanced\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a singly linked list, deleting a node given only a pointer to it requires traversal from the head to find the previous node, making the worst-case time complexity O(n).",
        "target_text": "Question: Let P be a singly linked list. Let Q be the pointer to an intermediate node x in the list. What is the worst-case time complexity of the best known algorithm to delete the node Q from the list?\nChoices:\na) O(n)\nb) O(log^2 n)\nc) O(log n)\nd) O(1)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash tables generally have lower average-case time complexity for insert, search, and delete compared to Binary Search Trees (BST), which may degrade to O(n) in the worst case.",
        "target_text": "Question: What is the disadvantage of BST over the hash table?\nChoices:\na) BST is easier to implement\nb) BST can get the keys sorted by just performing inorder traversal\nc) BST can perform range query easily\nd) Time complexity of hash table in inserting, searching and deleting is less than that of BST\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Search | Context: The Van Emde Boas (vEB) tree provides extremely fast operations for search, insert, and delete, with time complexity O(log log M), where M is the universe size.",
        "target_text": "Question: What is the time complexity for searching a key or integer in Van Emde Boas data structure?\nChoices:\na) O(log M!)\nb) O(M!)\nc) O(M^2)\nd) O(log log M)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Skip lists improve over linked lists by allowing fast search, insertion, and deletion in expected O(log n) time, compared to O(n) in regular linked lists.",
        "target_text": "Question: What is the time complexity improvement of skip lists from linked lists in insertion and deletion?\nChoices:\na) O(n) to O(log n) where n is number of elements\nb) O(n) to O(1) where n is number of elements\nc) no change\nd) O(n) to O(n^2) where n is number of elements\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Inserting a node at the end of a singly linked list requires traversing all nodes from the head unless a tail pointer is maintained, resulting in O(n) time.",
        "target_text": "Question: What would be the asymptotic time complexity to add a node at the end of singly linked list, if the pointer is initially pointing to the head of the list?\nChoices:\na) O(1)\nb) O(n)\nc) \u03b8(n)\nd) Both O(n) and \u03b8(n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In heapsort, multiple heapify operations may be required depending on element swaps. The array snapshot suggests at least two heapify operations were done at the root.",
        "target_text": "Question: Suppose we are sorting an array of eight integers using heapsort, and we have just finished some heapify (either maxheapify or minheapify) operations. The array now looks like this: 16 14 15 10 12 27 28. How many heapify operations have been performed on root of heap?\nChoices:\na) 1\nb) 2\nc) 3 or 4\nd) 5 or 6\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a skewed binary search tree (like a linked list), all operations--search, insert, and delete--take linear time in the number of nodes, i.e., O(n).",
        "target_text": "Question: What is the worst case time complexity for search, insert and delete operations in a general Binary Search Tree for a skewed tree ?\nChoices:\na) O(n) for all\nb) O(log n) for all\nc) O(log n) for search and insert, and O(n) for delete\nd) O(log n) for search, and O(n) for insert and delete\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: The best-case height of a B-tree with k keys and order n is log\u2099(k+1) - 1. This occurs when the tree is perfectly balanced and maximally filled.",
        "target_text": "Question: What is the best case height of a B-tree of order n and which has k keys?\nChoices:\na) log\u2099(k+1) - 1\nb) nk\nc) log\u2096(n+1) - 1\nd) k log n\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Circular linked lists are suitable for implementing both stacks and queues due to their ability to cycle through elements without needing null termination.",
        "target_text": "Question: A circular linked list can be used for __________\nChoices:\na) Stack\nb) Queue \\n (A) Stack \\n (B) Queue\nc) Both Stack & Queue\nd) Neither Stack or Queue\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: In sparse matrix addition, only the non-zero elements need to be processed. Hence, the worst-case time complexity is O(n), where n is the number of non-zero elements.",
        "target_text": "Question: Is O(n) the Worst case Time Complexity for addition of two Sparse Matrix?\nChoices:\na) True\nb) False\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Both the reversal algorithm and the juggling algorithm for array rotation have linear time complexity O(n), though they use different approaches and space.",
        "target_text": "Question: Reversal algorithm and juggling algorithm for array rotation have the same time complexity.\nChoices:\na) True\nb) False\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: To count the number of elements in a singly or circular linked list, each node must be visited once. This results in linear time complexity, O(n).",
        "target_text": "Question: What is the time complexity to count the number of elements in the linked list?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n^2)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: String | Context: Using suffix automaton or enhanced string techniques, it is possible to find the longest common prefix between any suffix in constant time, i.e., \u03b8(1), after preprocessing.",
        "target_text": "Question: What is a time complexity for finding the longest prefix that is common between suffix in a string?\nChoices:\na) \u03b8(n)\nb) \u03b8(n!)\nc) \u03b8(1)\nd) O(log n!)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Merging two max-heaps of size n can be done by copying elements from both into an array and using Build-Heap, which has a linear time complexity of O(n).",
        "target_text": "Question: Given two max heaps of size n each, what is the minimum possible time complexity to make a one max-heap of size from elements of two max heaps?\nChoices:\na) O(n^2)\nb) O(n log log n)\nc) O(n)\nd) O(n log n)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Skew heaps are self-adjusting heaps where operations like insert and delete have an amortized time of O(log n), but the worst-case time complexity can reach O(n).",
        "target_text": "Question: The worst case running time of all operations in a skew heap is given as?\nChoices:\na) O(n)\nb) O(n log n)\nc) O(n^2)\nd) O(m log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: When searching through k+1 auxiliary trees, such as in the union-find structure with trees, the time complexity per operation can be O(log log n), making total complexity (k+1)*O(log log n).",
        "target_text": "Question: What is the time complexity for searching k+1 auxiliary trees?\nChoices:\na) (k+2) O(log log n)\nb) (k+1) O(log n)\nc) (k+2) O(log n)\nd) (k+1) O(log log n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: String | Context: Substring checking (e.g., using KMP or Rabin-Karp algorithms) can be done in linear time, i.e., O(n), where n is the length of the string.",
        "target_text": "Question: What is a time complexity for checking a string of length n is substring or not?\nChoices:\na) O(log n!)\nb) O(n!)\nc) O(n^2)\nd) O(n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: In the worst case, a query operation over a set of n elements (e.g., a linear scan or unindexed search) can take O(n) time.",
        "target_text": "Question: What is the worst case time complexity of query operation (n is the number of candidates)?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In simple chaining used for hash tables, a doubly linked list can make deletion more efficient by allowing constant-time removal without needing to search for the previous node.",
        "target_text": "Question: In simple chaining, what data structure is appropriate?\nChoices:\na) Singly linked list\nb) Doubly linked list\nc) Circular linked list\nd) Binary trees\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a circular linked list, inserting at the head takes O(n) if there's no tail pointer. Thus, it's not O(1) unless special conditions apply, making option b False.",
        "target_text": "Question: Which of the following is False about a circular linked list?\nChoices:\na) Every node has a successor\nb) Time complexity of inserting a new node at the head of the list is O(1)\nc) Time complexity for deleting the last node is O(n)\nd) We can traverse the whole circular linked list by starting from any point\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: Binary search has a worst-case complexity of O(log n), which is significantly better than linear search. However, in edge cases (like unsorted data), both may fall back to linear scanning.",
        "target_text": "Question: The worst case complexity of binary search matches with __________\nChoices:\na) interpolation search\nb) linear search\nc) merge sort\nd) none of the above\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Building a heap from an array using the bottom-up approach (heapify) has time complexity O(n), but if each insert is done individually, the complexity is O(n log n).",
        "target_text": "Question: An array consists of n elements. We want to create a heap using the elements. The time complexity of building a heap will be in order of\nChoices:\na) O(n^2 log n)\nb) O(n log n)\nc) O(n^2)\nd) O(n log^2 n)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Tango trees are a type of binary search tree that achieve a competitive ratio of O(log log n) using preferred path decomposition and auxiliary trees.",
        "target_text": "Question: What is the time complexity of for achieving competitive ratio by tango tree?\nChoices:\na) O(log n)\nb) O(n^2)\nc) O(n!)\nd) O(log log n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Graph | Context: In an adjacency list representation, checking if an edge exists between two vertices may require scanning the list of one vertex, resulting in O(degree) = O(E) in worst case.",
        "target_text": "Question: Time complexity to check if an edge exists between two vertices would be __________\nChoices:\na) O(V^2)\nb) O(V + E)\nc) O(1)\nd) O(E)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Deleting an arbitrary node from a binary heap involves locating the node (O(n)), replacing it with the last node, and then heapifying (O(log n)). Combined worst-case: O(n).",
        "target_text": "Question: The worst case complexity of deleting any arbitrary node value element from heap is __________\nChoices:\na) O(log n)\nb) O(n)\nc) O(n log n)\nd) O(n^2)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: If each bin has a constant number of candidates and m bins are checked, the time complexity of insertion is proportional to the number of bins: O(m).",
        "target_text": "Question: What will be the time complexity of insertion operation if all the candidates are evenly spaced so that each bin has constant no. of candidates? (m = number of bins intersecting candidate intersects)\nChoices:\na) O(1)\nb) O(m)\nc) O(m^2)\nd) O(log m)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Inserting an alphabet into a tree-like structure using a hash map can be done in constant time assuming ideal hashing and constant-time insert in each map level.",
        "target_text": "Question: What is a time complexity for inserting an alphabet in the tree using hash maps?\nChoices:\na) O(log n!)\nb) O(n!)\nc) O(n^2)\nd) O(1)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: Quick Sort is a classic example of the Divide and Conquer design paradigm where the array is divided into parts based on a pivot, and each part is recursively sorted.",
        "target_text": "Question: The quick sort algorithm exploit __________ design technique.\nChoices:\na) Greedy\nb) Dynamic programming\nc) Divide and Conquer\nd) Backtracking\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: Segregating positive and negative numbers in an array can be done using a partitioning approach similar to Quick Sort's partition step, achieving linear time O(N).",
        "target_text": "Question: Consider an array consisting of -ve and +ve numbers. What would be the worst case time complexity of an algorithm to segregate the numbers having same sign altogether i.e all +ve on one side and then all -ve on the other ?\nChoices:\na) O(N)\nb) O(N Log N)\nc) O(N * N)\nd) O(N Log Log N)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: The Van Emde Boas tree supports insertion, deletion, and search operations in O(log log M) time, where M is the size of the universe of keys.",
        "target_text": "Question: What is the time complexity for deleting a key or integer in Van Emde Boas data structure?\nChoices:\na) O(log M!)\nb) O(log log M)\nc) O(M!)\nd) O(M^2)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Reversing a word using a stack involves pushing each character and then popping them to reverse the order. This process takes linear time O(N).",
        "target_text": "Question: What is the time complexity of reversing a word using stack algorithm?\nChoices:\na) O(N log N)\nb) O(N^2)\nc) O(N)\nd) O(M log N)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: String | Context: Rope data structures are used for efficient string manipulation, especially insertions and concatenations, which can be done in O(log n) time.",
        "target_text": "Question: What is the time complexity for inserting the string and forming a new string in the rope data structure?\nChoices:\na) O(log n)\nb) O(n!)\nc) O(n^2)\nd) O(1)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Using two stacks to implement a double-ended queue (deque) involves constant time O(1) for operations at the top, but may require O(n) for operations at the opposite end due to shifting.",
        "target_text": "Question: A double-ended queue supports operations like adding and removing items from both the sides of the queue. They support four operations like addFront(adding item to top of the queue), addRear(adding item to the bottom of the queue), removeFront(removing item from the top of the queue) and removeRear(removing item from the bottom of the queue). You are given only stacks to implement this data structure. You can implement only push and pop operations. What's the time complexity of performing addFront and addRear? (Assume 'm' to be the size of the stack and 'n' to be the number of elements)\nChoices:\na) O(m) and O(n)\nb) O(1) and O(n)\nc) O(n) and O(1)\nd) O(n) and O(m)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Merge Sort is the most suitable sorting algorithm for linked lists due to its efficient O(n log n) time and ability to be implemented without random access.",
        "target_text": "Question: Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity?\nChoices:\na) Insertion Sort\nb) Quick Sort\nc) Heap Sort\nd) Merge Sort\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: When chaining is implemented using a list head, the worst-case scenario occurs when all keys hash to the same bucket, requiring a linear search through a linked list, giving O(n) time for insertion.",
        "target_text": "Question: What is the worst case time complexity of insert function in the hash table when the list head is used for chaining?\nChoices:\na) O(1)\nb) O(n log n)\nc) O(log n)\nd) O(n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In a queue implemented with an array or linked list, enqueue (insertion at the rear) takes constant time O(1) in the average and worst case.",
        "target_text": "Question: What is the time complexity of enqueue operation?\nChoices:\na) O(log n)\nb) O(n log n)\nc) O(n)\nd) O(1)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: If elements are evenly distributed among bins, deletion from a bin takes O(m), where m is the number of bins intersected during deletion.",
        "target_text": "Question: What will be the time complexity of delete operation if all the candidates are evenly spaced so that each bin has constant number of candidates? (m = number of bins intersecting candidate intersects)\nChoices:\na) O(1)\nb) O(m)\nc) O(m^2)\nd) O(log m)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: One key advantage of chained hashing (external hashing) over open addressing is ease of deletion, as linked list operations allow direct removal without shifting elements.",
        "target_text": "Question: An advantage of chained hash table (external hashing) over the open addressing scheme is\nChoices:\na) Worst case complexity of search operations is less\nb) Space used is less\nc) Deletion is easier\nd) None of the above\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: String | Context: Rope data structures allow efficient editing of large strings. Deletion in a rope takes O(log n) time by splitting and concatenating balanced tree nodes.",
        "target_text": "Question: What is the time complexity for deleting the string to form a new string in the rope data structure?\nChoices:\na) O(n^2)\nb) O(n!)\nc) O(log n)\nd) O(1)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In a priority queue, inserting a node based on position (priority) may require traversing or adjusting elements, resulting in worst-case linear time complexity O(n).",
        "target_text": "Question: What is the time complexity to insert a node based on position in a priority queue?\nChoices:\na) O(n log n)\nb) O(log n)\nc) O(n)\nd) O(n^2)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash tables typically offer constant average-case time complexity for insert, delete, and search operations, which is better than the O(log n) average of balanced BSTs.",
        "target_text": "Question: What is the advantage of a hash table over BST?\nChoices:\na) hash table has a better average time complexity for performing insert, delete and search operations\nb) hash table requires less space\nc) range query is easy with hash table\nd) easier to implement\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: Selection sort has the same time complexity in best, average, and worst cases--O(n^2)--making it the slowest among common algorithms even in the best case.",
        "target_text": "Question: Which of the sorting techniques has highest best-case runtime complexity?\nChoices:\na) Quick sort\nb) Selection sort\nc) Insertion sort\nd) Bubble sort\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Circular linked lists are commonly used in CPU scheduling (Round Robin) because they allow the scheduler to cycle through processes efficiently.",
        "target_text": "Question: Which of the following application makes use of a circular linked list?\nChoices:\na) Undo Operation\nb) Recursive function calls\nc) Allocating CPU to resources\nd) Implement Hash Tables\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In the worst case, searching a singly linked list requires traversing all n nodes to find a specific element, resulting in O(n) comparisons.",
        "target_text": "Question: In the worst case, the number of comparisons needed to search a singly linked list of length n for a given element is\nChoices:\na) log(2*n)\nb) n/2\nc) log(2*n) - 1\nd) n\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: The average-case height of a binary search tree is O(log n) when nodes are inserted in random order, making searches and updates efficient.",
        "target_text": "Question: What is the average case time complexity for finding the height of the binary tree?\nChoices:\na) h = O(log log n)\nb) h = O(n log n)\nc) h = O(n)\nd) h = O(log n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: In a hash table using a binary tree (e.g., in chaining), delete operations in a balanced binary search tree take O(log n) time, not constant.",
        "target_text": "Question: What is the time complexity of the delete function in the hash table using a binary tree?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: A hash tree (Merkle tree) is used for data synchronization and verification. In the worst case, all nodes may need to be compared, resulting in O(n) time complexity.",
        "target_text": "Question: Hash tree is used in data synchronisation. In the worst case the data synchronisation takes __________ time.\nChoices:\na) O(log n)\nb) O(n^2)\nc) O(n log n)\nd) O(n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a ternary heap, each node has three children, so the height is log base 3 of n. Deleting the root requires bubbling down and comparing up to 3 children per level, giving time complexity O(3 log n / log 3).",
        "target_text": "Question: What is the time complexity for deleting root key in a ternary heap of n elements?\nChoices:\na) O(log n / log 3)\nb) O(3 log n / log 3)\nc) O(n)\nd) O(1)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Balancing parentheses requires traversing the string once and using a stack or counter, resulting in O(n) time complexity where n is the string length.",
        "target_text": "Question: What is the time complexity of balancing parentheses algorithm?\nChoices:\na) O(n)\nb) O(n log n)\nc) O(m log n)\nd) O(n^2)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Given a postorder traversal of a BST, it is possible to reconstruct the unique tree in O(n) time using a stack and recursion-based strategy.",
        "target_text": "Question: You are given the postorder traversal, P, of a binary search tree on the n elements 1, 2, ..., n. You have to determine the unique binary search tree that has P as its postorder traversal. What is the time complexity of the most efficient algorithm for doing this?\nChoices:\na) O(log n)\nb) O(n)\nc) O(n log n)\nd) None of the above, as the tree cannot be uniquely determined.\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Binary tree sort using a self-balancing BST ensures sorted output and guarantees O(n log n) time in the worst case by keeping the tree balanced.",
        "target_text": "Question: The binary tree sort implemented using a self-balancing binary search tree takes __________ time in worst case.\nChoices:\na) O(n log n)\nb) O(n)\nc) O(n^2)\nd) O(log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a circular linked list, all nodes are connected in a circle, making it appear as though there is no True beginning or end.",
        "target_text": "Question: In a circular linked list:\nChoices:\na) Components are all linked together in some sequential manner.\nb) There is no beginning and no end.\nc) Components are arranged hierarchically.\nd) Forward and backward traversal within the list is permitted.\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Search | Context: In a self-organizing list with linear search, the worst-case scenario requires traversing all elements, giving O(n) time complexity.",
        "target_text": "Question: The worst case running time of a linear search on the self-organizing list is __________\nChoices:\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n^2)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Search | Context: Linear search checks each element sequentially until the target is found or the end is reached, resulting in a worst-case time complexity of \u03b8(n).",
        "target_text": "Question: What is the worst case time complexity of linear search algorithm?\nChoices:\na) \u03b8(1)\nb) \u03b8(n)\nc) \u03b8(log n)\nd) \u03b8(n^2)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a ternary heap, each node has 3 children. Increasing the priority of a key involves bubbling it up the tree, which takes O(log n / log 3) time.",
        "target_text": "Question: What is the time complexity for increasing priority of key in a maximum ternary heap of n elements?\nChoices:\na) O(log n / log 3)\nb) O(n!)\nc) O(n)\nd) O(1)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: The worst case of Quick Sort occurs when the pivot selection leads to unbalanced partitions, causing O(n^2) time complexity.",
        "target_text": "Question: The worst case of quick sort has order __________.\nChoices:\na) O(n^2)\nb) O(n)\nc) O(n log^2 n)\nd) O(log^2 n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Fibonacci Series (with memoization), Tower of Hanoi (recursive), and Dijkstra's algorithm all demonstrate dynamic programming principles when overlapping subproblems exist.",
        "target_text": "Question: Which of the following is an example of dynamic programming approach?\nChoices:\na) Fibonacci Series\nb) Tower of Hanoi\nc) Dijkstra's Shortest Path\nd) All of the above\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Chaining in hashing is less sensitive to the choice of hash function because collisions are handled using separate lists rather than probing schemes.",
        "target_text": "Question: What is the advantage of hashing with chaining?\nChoices:\na) cache performance is good\nb) uses less space\nc) less sensitive to hash function\nd) has a time complexity of O(n) in the worst case\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Red-black tree constraints (black height balance, red child rule) ensure logarithmic tree height, guaranteeing O(log n) time complexity for operations.",
        "target_text": "Question: Why do we impose restrictions like:\n- root property is black\n- every leaf is black\n- children of red node are black\n- all leaves have same black height\nChoices:\na) to get logarithm time complexity\nb) to get linear time complexity\nc) to get exponential time complexity\nd) to get constant time complexity\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Both AVL trees and B-trees maintain balanced structures that ensure logarithmic time complexity O(log n) in the worst case for insertion and deletion.",
        "target_text": "Question: B-tree and AVL tree have the same worst case time complexity for insertion and deletion.\nChoices:\na) True\nb) False\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: The juggling algorithm for array rotation performs element swaps based on the greatest common divisor (GCD) of the array size and rotation steps. Its time complexity is O(n).",
        "target_text": "Question: What is the time complexity of the juggling algorithm to rotate an array?\nChoices:\na) O(1)\nb) O(n)\nc) O(d)\nd) O(n*d)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Converting infix expressions to postfix (Reverse Polish Notation) using a stack-based algorithm can be done in linear time O(n), where n is the length of the expression.",
        "target_text": "Question: What is the time complexity of an infix to postfix conversion algorithm?\nChoices:\na) O(n log n)\nb) O(n)\nc) O(n^2)\nd) O(m log n)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Inserting into a doubly linked list takes O(1) time if the pointer to the insertion point is known. However, finding the correct position can take O(n) in the worst case.",
        "target_text": "Question: What is the worst case time complexity of inserting a node in a doubly linked list?\nChoices:\na) O(n log n)\nb) O(log n)\nc) O(n)\nd) O(1)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: String | Context: Finding the most frequent substring of a given minimum length can be done using a sliding window and hashmap or suffix tree in linear time O(n).",
        "target_text": "Question: What is a time complexity for finding frequently occurring substring of minimum length in a string?\nChoices:\na) \u03b8(n)\nb) \u03b8(n!)\nc) O(n^2 + n)\nd) O(log n!)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a balanced binary search tree with 2\u207f elements, search operations take time proportional to the tree height, which is O(log n). So the worst-case time is \u03b8(log n).",
        "target_text": "Question: The worst case running time to search for an element in a balanced binary search tree with n = 2^k elements is:\nChoices:\na) \u03b8(n log n)\nb) \u03b8(n*2\u207f)\nc) \u03b8(n)\nd) \u03b8(log n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: String | Context: Reversing a string involves swapping characters from both ends toward the center, which takes O(n) time where n is the string length.",
        "target_text": "Question: What is the time complexity to reverse a string?\nChoices:\na) O(n^2)\nb) O(1)\nc) O(log n)\nd) O(n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: In rope data structures, creating a new node and concatenating ropes are done using tree operations that can take O(1) time when no balancing is required.",
        "target_text": "Question: What is the time complexity for creating a new node and then performing concatenation in the rope data structure?\nChoices:\na) O(log n)\nb) O(n!)\nc) O(n^2)\nd) O(1)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: Bubble Sort performs pairwise comparisons and swaps in nested loops, giving a worst-case time complexity of O(n^2).",
        "target_text": "Question: Consider that n elements are to be sorted. What is the worst case time complexity of Bubble sort?\nChoices:\na) O(1)\nb) O(log^2 n)\nc) O(n)\nd) O(n^2)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Floyd's Cycle Detection algorithm (also known as the Tortoise and Hare algorithm) detects cycles using two pointers moving at different speeds, making it highly efficient.",
        "target_text": "Question: Consider a small circular linked list. How to detect the presence of cycles in this list effectively?\nChoices:\na) Keep one node as head and traverse another temp node till the end to check if its 'next' points to head\nb) Have fast and slow pointers with the fast pointer advancing two nodes at a time and slow pointer advancing by one node at a time\nc) Cannot determine, you have to pre-define if the list contains cycles\nd) Circular linked list itself represents a cycle. So no new cycles cannot be generated\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In circular linked lists, nodes are linked in a loop without a terminating NULL, and traversal can start at any point. Valid statements about their structure often include loop-based properties like P1 and P4.",
        "target_text": "Question: Which of the following Statement is correct about Circular Linked List?\nChoices:\na) Only P4\nb) Only P1\nc) P1 and P2\nd) P1 and P4.\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Array | Context: In array-based stack implementations, the pop operation simply decrements the index (top pointer) and is therefore done in constant time, O(1).",
        "target_text": "Question: What is the time complexity of pop() operation when the stack is implemented using an array?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Inserting a node at the beginning of a linked list requires changing the head pointer and the next pointer of the new node, which is a constant time O(1) operation.",
        "target_text": "Question: What is the time complexity to insert a node at the beginning of the list?\nChoices:\na) O(log n)\nb) O(n)\nc) O(1)\nd) None\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a hash table with chaining using doubly linked lists, insertions occur at the head or tail of the list and take constant time, i.e., O(1).",
        "target_text": "Question: What is the time complexity of insert function in a hash table using a doubly linked list?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Implementing a queue using two stacks requires moving all elements during the dequeue operation. If `m` elements exist, dequeue takes O(m) time in the worst case.",
        "target_text": "Question: You are asked to perform a queue operation using a stack. Assume the size of the stack is some value 'n' and there are 'm' number of variables in this stack. The time complexity of performing deQueue operation is (Using only stack operations like push and pop) (Tightly bound).\nChoices:\na) O(m)\nb) O(n)\nc) O(m*n)\nd) Data is insufficient\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: The worst-case height of an AVL tree is approximately 1.44 log2(n), where n is the number of nodes. This follows from AVL balancing rules.",
        "target_text": "Question: What is the worst case possible height of AVL tree?\nChoices:\na) 2 log n (Assume base of log is 2)\nb) 1.44 log n (Assume base of log is 2)\nc) Depends upon implementation\nd) \u03b8(n)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: In a hash tree (e.g., Merkle tree), insertion can involve O(log\u2096(n)) time, where k is the arity of the tree and n is the number of elements.",
        "target_text": "Question: What is the worst case time complexity of the insertion in the hash tree?\nChoices:\na) O(log\u2096(n))\nb) O(n^2)\nc) O(n log\u2096(n))\nd) O(k*n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a suffix tree, the number of nodes in the worst case is 2n where n is the length of the string, because each suffix may form a new branch.",
        "target_text": "Question: For what size of nodes, the worst case of usage of space in suffix tree seen?\nChoices:\na) n Nodes\nb) 2n Nodes\nc) 2n nodes\nd) n! nodes\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a ternary heap, increasing a key's priority may require bubbling it up through levels. The height is log base 3 of n, and with up to 3 comparisons per level, time is O(3 log n / log 3).",
        "target_text": "Question: What is the time complexity for increasing priority of key in a minimum ternary heap of n elements?\nChoices:\na) O(log n / log 3)\nb) O(3 log n / log 3)\nc) O(n)\nd) O(1)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Graph | Context: To check if a graph is bipartite using an adjacency matrix, we perform BFS or DFS which runs in O(V^2) time due to the dense matrix representation.",
        "target_text": "Question: What would the time complexity to check if an undirected graph with V vertices and E edges is Bipartite or not given its adjacency matrix?\nChoices:\na) O(E^2)\nb) O(V^2)\nc) O(E)\nd) O(V)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Dynamic Programming uses memoization to store intermediate results of subproblems, which helps avoid redundant computations and improve efficiency.",
        "target_text": "Question: Which of the following uses memorization?\nChoices:\na) Greedy approach\nb) Divide and conquer approach\nc) Dynamic programming approach\nd) None of the above\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a balanced BST, reporting all elements in a range [a, b] requires a traversal to the range (O(log n)) and printing k elements, resulting in \u03b8(log n + k) time.",
        "target_text": "Question: In a balanced binary search tree with n elements, what is the worst-case time complexity of reporting all elements in the range [a,b]? Assume that the number of reported elements is k.\nChoices:\na) \u03b8(log n)\nb) \u03b8(log n + k)\nc) \u03b8(k log n)\nd) \u03b8(n log k)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: The Van Emde Boas tree supports operations like finding the minimum and maximum in constant O(1) time due to its structure and recursive splitting of the universe.",
        "target_text": "Question: What is the time complexity for finding a maximum and minimum integer in Van Emde Boas data structure?\nChoices:\na) O(log M!)\nb) O(M!)\nc) O(1)\nd) O(log log M)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: String | Context: Finding all maximal palindromes in a string can be done in linear time O(n) using Manacher's algorithm.",
        "target_text": "Question: What is a time complexity for finding all the maximal palindrome in a string?\nChoices:\na) \u03b8(n)\nb) \u03b8(n!)\nc) \u03b8(1)\nd) O(log n!)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Building a ternary heap (heap with 3 children per node) using a bottom-up heapify approach takes linear time O(n), similar to binary heaps.",
        "target_text": "Question: What is the time complexity for creating a ternary heap using swapping?\nChoices:\na) O(log n / log 3)\nb) O(n!)\nc) O(n)\nd) O(1)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: Interpolation search is efficient on uniformly distributed, sorted data. It achieves a time complexity of \u03b8(log log n) in the best case when distribution is ideal.",
        "target_text": "Question: If the data collection is in sorted form and equally distributed then the run time complexity of interpolation search is __________\nChoices:\na) \u03b8(n)\nb) \u03b8(1)\nc) \u03b8(log n)\nd) \u03b8(log log n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Inserting at the beginning of a triply linked list (similar to a doubly linked list but with an extra pointer) still takes O(1) time when the pointer to the head is known.",
        "target_text": "Question: Which among the following is the time complexity for inserting at the beginning of a triply linked list?\nChoices:\na) O(n)\nb) O(1)\nc) O(log n)\nd) O(n^2)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: String | Context: Rope data structures enable efficient string manipulation. Splitting a string in a rope (balanced binary tree) can be done in O(log n) time.",
        "target_text": "Question: What is the time complexity for splitting the string into two new strings in the rope data structure?\nChoices:\na) O(n^2)\nb) O(n!)\nc) O(log n)\nd) O(1)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Finding x-pattern occurrences of length n can be done in \u03b8(n + x) time using pattern matching algorithms like KMP or Aho-Corasick.",
        "target_text": "Question: What is a time complexity for x pattern occurrence of length n?\nChoices:\na) O(log n!)\nb) \u03b8(n!)\nc) O(n^2)\nd) \u03b8(n + x)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Skip lists offer logarithmic time complexities similar to balanced binary search trees for insert, delete, and search operations.",
        "target_text": "Question: To which data structure are skip lists similar in terms of time complexities in worst and best cases?\nChoices:\na) balanced binary search trees\nb) binary search trees\nc) binary trees\nd) linked lists\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Graph | Context: In an adjacency matrix, each vertex is checked against all others, resulting in O(V^2) time to compute or count edges.",
        "target_text": "Question: The time complexity to calculate the number of edges in a graph whose information is stored in form of an adjacency matrix is __________\nChoices:\na) O(V)\nb) O(E^2)\nc) O(E)\nd) O(V^2)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: Quick Sort uses the Divide and Conquer paradigm, where the array is partitioned recursively based on pivots.",
        "target_text": "Question: Quick sort algorithm is an example of __________.\nChoices:\na) Greedy approach\nb) Improved binary search\nc) Dynamic Programming\nd) Divide and conquer\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a singly linked list, deleting a node is O(1) if a pointer to the node and its previous node is already available. This is the best-case time complexity.",
        "target_text": "Question: What is the best case time complexity of deleting a node in a Singly Linked list?\nChoices:\na) O(n)\nb) O(n^2)\nc) O(n log n)\nd) O(1)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: In the worst case, deleting an element from an unsorted data structure may require scanning all elements, resulting in O(n) time.",
        "target_text": "Question: What is the worst case time complexity of delete operation (n is the number of candidates)?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a hash table using chaining with doubly linked lists, insertion is done at the head or tail in O(1) time, and search operations can also be optimized to O(1) under ideal hashing.",
        "target_text": "Question: What is the time complexity of search function in a hash table using a doubly linked list?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Stack | Context: A skew heap uses recursion to perform merges. A recursive implementation can fail if the stack depth exceeds limits, especially in degenerate cases. Hence, stack space becomes a limitation.",
        "target_text": "Question: Why would a recursive implementation fail in skew heaps?\nChoices:\na) skew heaps are self adjusting\nb) efficiency gets reduced\nc) lack of stack space\nd) time complexity\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Red-Black Trees provide logarithmic time complexity for insert, delete, and search operations, including finding predecessor and successor.",
        "target_text": "Question: What are the operations that could be performed in O(log n) time complexity by red-black tree?\nChoices:\na) insertion, deletion, finding predecessor, successor\nb) only insertion\nc) only finding predecessor, successor\nd) for sorting\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Free memory blocks in memory management systems are typically maintained in a circular linked list and organized by increasing address to support merging of adjacent blocks.",
        "target_text": "Question: How are free blocks linked together mostly and in what addressing order?\nChoices:\na) circular linked list and increasing addressing order\nb) linked list and decreasing addressing order\nc) linked list and in no addressing order\nd) none of the mentioned\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Performing \u03b8(N) delete, O(log N) insert and find, and \u03b8(N) decrease-key operations on a sorted doubly linked list gives an overall complexity of O(N log N).",
        "target_text": "Question: N items are stored in a sorted doubly linked list. For a delete operation, a pointer is provided to the record to be deleted. For a decrease-key operation, a pointer is provided to the record on which the operation is to be performed. An algorithm performs the following operations on the list in this order: \u03b8(N) delete, O(log N) insert, O(log N) find, and \u03b8(N) decrease-key. What is the time complexity of all these operations put together?\nChoices:\na) O(log^2 N)\nb) O(N)\nc) O(N log N)\nd) \u03b8(N^2 log N)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Circular linked lists are often used in CPU scheduling, such as round-robin schedulers, to allocate time slices to multiple processes in a loop.",
        "target_text": "Question: Which of the following application makes use of a circular linked list?\nChoices:\na) Recursive function calls\nb) Undo operation in a text editor\nc) Implement Hash Tables\nd) Allocating CPU to resources\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: The naive nearest neighbor search in an unsorted list of N items requires scanning all points, resulting in O(N) time in the worst case.",
        "target_text": "Question: What is the worst case time complexity of finding the nearest neighbour?\nChoices:\na) O(N)\nb) O(N log N)\nc) O(log N)\nd) O(N^3)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Maintaining dynamic sets of weighted trees using advanced data structures (like union-find with union by rank and path compression) can be achieved in O(log n) time.",
        "target_text": "Question: What is the time complexity for maintaining a dynamic set of weighted trees?\nChoices:\na) O(n)\nb) O(n^2)\nc) O(log n)\nd) O(n!)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a circular linked list, the last node's 'next' pointer points back to the head instead of NULL, ensuring the list loops continuously.",
        "target_text": "Question: What differentiates a circular linked list from a normal linked list?\nChoices:\na) You cannot have the 'next' pointer point to null in a circular linked list\nb) It is faster to traverse the circular linked list\nc) In a circular linked list, each node points to the previous node instead of the next node\nd) Head node is known in circular linked list\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In an unrolled linked list, insertion may require shifting elements in the array part or splitting nodes, which could take linear time O(n) in the worst case.",
        "target_text": "Question: Which among the following is the time complexity for inserting an element in an unrolled linked list?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n^2)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a ternary heap (where each node has 3 children), decreasing a key's priority involves bubbling up, taking O(log n / log 3) time.",
        "target_text": "Question: What is the time complexity for decreasing priority of key in a minimum ternary heap of n elements?\nChoices:\na) O(log n / log 3)\nb) O(n!)\nc) O(n)\nd) O(1)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In a priority queue implemented using a linear array, insertion based on key requires scanning for the correct position, leading to O(n) time complexity.",
        "target_text": "Question: What is the time complexity to insert a node based on key in a priority queue?\nChoices:\na) O(n log n)\nb) O(log n)\nc) O(n)\nd) O(n^2)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Pairing heaps are self-adjusting heaps. Their time complexity analysis was inspired by that of splay trees, which also use amortized analysis.",
        "target_text": "Question: Pairing heaps time complexity was inspired by that of?\nChoices:\na) splay tree\nb) treap\nc) red-black tree\nd) avl tree\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: In chaining with a list head, inserting at the beginning of the linked list takes constant time O(1) under ideal hashing assumptions.",
        "target_text": "Question: What is the time complexity of insert function in a hash table using list head?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Search | Context: Van Emde Boas trees offer fast operations for search, insert, and delete in O(log log M) time, where M is the universe size.",
        "target_text": "Question: What is the time complexity for searching a key or integer in Van Emde Boas data structure?\nChoices:\na) O(M!)\nb) O(log M!)\nc) O(log log M)\nd) O(M^2)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hashing provides O(1) time complexity on average for search operations, assuming a good hash function and low collision rate.",
        "target_text": "Question: Which searching technique takes O(1) time complexity for searching the data?\nChoices:\na) Binary Search\nb) Linear Search\nc) AVL Tree Search\nd) Hashing\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Sorting | Context: In the worst case (e.g., sorted input), Quick Sort's partitioning may lead to unbalanced recursion, giving time complexity O(n^2/2).",
        "target_text": "Question: In worst case Quick Sort has order __________.\nChoices:\na) O(n log n)\nb) O(n^2/2)\nc) O(log n)\nd) O(n^2/4)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In dynamic tree structures like auxiliary trees (used in link-cut trees), update operations (e.g., link, cut) can have amortized time complexity of O(log log n), depending on implementation.",
        "target_text": "Question: What is the time complexity for the update cost on auxiliary trees?\nChoices:\na) O(log log n)\nb) (k-1) O(log n)\nc) k^2 O(log n)\nd) (k+1) O(log log n)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Graph | Context: In a Directed Acyclic Word Graph (DAWG), checking if S1 is a substring of S2 takes O(|S1|) time as it depends only on the length of the pattern string.",
        "target_text": "Question: What is the time complexity to check if a string (length S1) is a substring of another string (length S2) stored in a Directed Acyclic Word Graph, given S2 > S1?\nChoices:\na) O(S1)\nb) O(S2)\nc) O(S1 + S2)\nd) O(1)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Inserting n elements into a sorted linked list one by one requires traversal for each insert, resulting in a total time of \u03b8(n^2) in the worst case.",
        "target_text": "Question: What is the worst case time complexity of inserting n elements into an empty linked list, if the linked list needs to be maintained in sorted order?\nChoices:\na) \u03b8(n)\nb) \u03b8(n log n)\nc) \u03b8(n^2)\nd) \u03b8(1)\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Converting prefix notation to infix using a stack-based approach processes each token once, resulting in O(n) time where n is the number of symbols.",
        "target_text": "Question: The time complexity of converting a prefix notation to infix notation is __________\nChoices:\na) O(n) where n is the length of the equation\nb) O(n) where n is number of operands\nc) O(1)\nd) O(log n) where n is length of the equation\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: The Tower of Hanoi problem has exponential time complexity O(2\u207f), making it one of the slowest recursive algorithms with the highest runtime.",
        "target_text": "Question: Program with highest run-time complexity is __________\nChoices:\na) Tower of Hanoi\nb) Fibonacci Series\nc) Prime Number Series\nd) None of these\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Van Emde Boas trees support operations like insert, delete, and search in O(log log M) time, where M is the universe size.",
        "target_text": "Question: What is the time complexity for inserting a key or integer in Van Emde Boas data structure?\nChoices:\na) O(log M!)\nb) O(M!)\nc) O(M^2)\nd) O(log log M)\nAnswer: d"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Inserting an element at the front of a linked list when the head is known is a constant-time operation, as no traversal is needed.",
        "target_text": "Question: What would be the asymptotic time complexity to insert an element at the front of the linked list (head is known)?\nChoices:\na) O(1)\nb) O(n)\nc) O(n^2)\nd) O(n^3)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: The \u03b8 (\u0398) notation in asymptotic analysis represents the tight bound, usually associated with the average case but also applies when upper and lower bounds match.",
        "target_text": "Question: The \u03b8 notation in asymptotic evaluation represents __________\nChoices:\na) Base case\nb) Average case\nc) Worst case\nd) NULL case\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: The Floyd-Warshall algorithm is a dynamic programming-based algorithm used to find the shortest paths between all pairs of vertices in O(V^3) time.",
        "target_text": "Question: Floyd Warshall Algorithm used to solve the shortest path problem has a time complexity of __________\nChoices:\na) O(V^2)\nb) O(V^3)\nc) O(E*V)\nd) O(E^2)\nAnswer: b"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: Red-Black trees are preferred over AVL trees in scenarios with frequent insertions and deletions because they require fewer rotations and offer faster amortized performance.",
        "target_text": "Question: When would it be optimal to prefer Red-black trees over AVL trees?\nChoices:\na) when there are more insertions or deletions\nb) when more search is needed\nc) when tree must be balanced\nd) when log(nodes) time complexity is needed\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a hash table using chaining with doubly linked lists, deletion is efficient and performed in constant time O(1) if a pointer to the node is provided.",
        "target_text": "Question: What is the time complexity of delete function in the hash table using a doubly linked list?\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: Evaluating a postfix expression (Reverse Polish Notation) using a stack processes each token once, leading to linear time complexity O(n).",
        "target_text": "Question: What is the time complexity of evaluation of postfix expression algorithm?\nChoices:\na) O(N)\nb) O(N log N)\nc) O(N^2)\nd) O(M log N)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: The Floyd-Warshall algorithm applies dynamic programming to solve the all-pairs shortest path problem in a weighted graph.",
        "target_text": "Question: The Floyd-Warshall algorithm for all-pair shortest paths computation is based on:\nChoices:\na) Greedy paradigm.\nb) Divide-and-Conquer paradigm.\nc) Dynamic Programming paradigm.\nd) None of the above.\nAnswer: c"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Theory | Context: In naive merging of two sorted arrays (or lists), each element must be compared and placed into a new array, resulting in a worst-case time complexity of O(N).",
        "target_text": "Question: The worst case analysis for a naive merge is given as?\nChoices:\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(N^2)\nAnswer: a"
    },
    {
        "input_text": "Generate a data structure MCQ | Topic: Tree | Context: In a binary search tree (BST), the worst case occurs when the tree becomes skewed, leading to O(n) complexity. The average case for balanced BSTs is O(log n).",
        "target_text": "Question: What are the worst case and average case complexities of a binary search tree?\nChoices:\na) O(n), O(n)\nb) O(log n), O(log n)\nc) O(log n), O(n)\nd) O(n), O(log n)\nAnswer: d"
    }
]