[
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where each element, called a node, contains data and a pointer to the next node. Functions that traverse linked lists can use different traversal patterns (e.g., skipping nodes, recursion) to print or manipulate data. Understanding recursive access to every second node helps in reasoning about output in such cases.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the output of the following function in which start is pointing to the first node of the linked list 1->2->3->4->5->6?\n\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node() { data = 0; next = nullptr; } \n};\n\nvoid fun(Node* start) {\n    if (start == nullptr)\n        return;\n    cout << start->data << \"  \";\n    \n    if (start->next != nullptr)\n        fun(start->next->next);\n    cout << start->data << \"  \";\n}\n\nChoices:\nA) 1 4 6 6 4 1\nB) 1 3 5 1 3 5\nC) 1 2 3 5\nD) 1 3 5 5 3 1\nAnswer: D"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: An array is a data structure that stores elements in contiguous memory locations. Each element in an array can be accessed directly using its index, making access time constant (O(1)). This direct access means elements are accessed randomly using their indices, unlike structures such as linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Elements in an array are accessed _____________\na) randomly\nb) sequentially\nc) exponentially\nd) logarithmically\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: An array is a data structure that stores elements in contiguous memory locations. Each element in an array can be accessed directly using its index, making access time constant (O(1)). This direct access means elements are accessed randomly using their indices, unlike structures such as linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Elements in an array are accessed _____________\na) randomly\nb) sequentially\nc) exponentially\nd) logarithmically\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A heap is a special tree-based data structure that satisfies the heap property. In a max-heap, each parent node is greater than or equal to its children, while in a min-heap, each parent is less than or equal to its children. A leftist heap is a variant of a binary heap that is implemented as a binary tree and is optimized for efficient merging of two heaps. It maintains a special property called the null path length (npl), ensuring that the right child of any node has the shortest npl.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A leftist heap is also said to be a binary heap.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle. It is commonly used in parsing expressions, managing function calls, and checking for balanced symbols like parentheses, braces, and brackets. When validating balanced expressions, opening symbols are pushed onto the stack, and when a corresponding closing symbol is encountered, the stack is popped to check for a match.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If the corresponding end bracket/braces/parentheses is encountered, which of the following is done?\na) push it on to the stack\nb) pop the stack\nc) throw an error\nd) treated as an exception\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a non-linear hierarchical data structure widely used to represent relationships between elements. Specialized trees like suffix trees are used in string processing tasks. A suffix tree is a compressed trie of all the suffixes of a given string and is commonly used in applications such as text editors, search engines, and bioinformatics for pattern matching and substring queries.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Can suffix tree be used in string problems occurring in a text editor?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A binary tree is a hierarchical data structure in which each node has at most two children. Deleting a node from a binary tree requires careful handling to maintain the tree's structure. A common approach is to locate the node to be deleted, replace its value with that of the deepest (rightmost) node, and then delete the deepest node. This ensures that the properties of the binary tree remain intact.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The following lines talk about deleting a node in a binary tree (the tree property must not be violated after deletion):\ni) From root, search for the node to be deleted\n ii)\n iii) Delete the node at\nWhat must be statement ii) and fill up statement iii)?\na) ii)- Find random node, replace with node to be deleted. iii)- Delete the node\nb) ii)- Find node to be deleted. iii)- Delete the node at found location\nc) ii)- Find deepest node, replace with node to be deleted. iii)- Delete a node\nd) ii)- Find deepest node, replace with node to be deleted. iii)- Delete the deepest node\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Graphs are generalizations of tree structures that may include cycles and weights on edges. In a weighted graph, the shortest path from a source to a destination may not be unique unless additional constraints apply. For example, if all edge weights are unique, there may still be multiple paths of equal total weight due to different combinations of edges. Hence, uniqueness of edge weights does not guarantee a unique shortest path.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is the following statement valid?\n\nGiven a weighted graph where weights of all edges are unique (no two edges have the same weights), there is always a unique shortest path from a source to destination in such a graph.\n\nChoices:\nA) True\nB) False\n\nAnswer: B"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a dynamic data structure consisting of nodes that contain data and a pointer to the next node. In compiler design, the syntax analysis phase (also called parsing) uses data structures to represent the syntactic structure of code. Although trees (especially abstract syntax trees) are common, linked lists are also used internally to manage tokens and other dynamic sequences of elements during parsing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure is used in the syntax analysis phase of the compiler?\na) Tree\nb) Stack\nc) Linked List\nd) Queue\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: An array is a linear data structure that stores elements in contiguous memory locations. Inversions in an array are pairs of elements that are out of their natural order (i.e., a pair (i, j) such that i < j and arr[i] > arr[j]). A completely sorted array has zero such inversions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many inversions does a sorted array have?\na) 0\nb) 1\nc) 2\nd) cannot be determined\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are used in many algorithmic applications including number system conversions. To convert a decimal number to binary, repeated division by 2 is performed, and the remainders are stored in an array. The binary representation is obtained by reading the remainders in reverse order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following code snippet is used to convert decimal to binary numbers?\na)\n\npublic void convertBinary(int num)\n{\n     int bin[] = new int[50];\n     int index = 0;\n     while(num > 0)\n     {\n       bin[index++] = num%2;\n       num = num/2;\n     }\n     for(int i = index-1;i >= 0;i--)\n     {\n       System.out.print(bin[i]);\n     }\n}\nb)\n\npublic void convertBinary(int num)\n{\n     int bin[] = new int[50];\n     int index = 0;\n     while(num > 0)\n     {\n       bin[++index] = num%2;\n       num = num/2;\n     }\n     for(int i = index-1;i >= 0;i--)\n     {\n       System.out.print(bin[i]);\n     }\n}\nc)\n\npublic void convertBinary(int num)\n{\n     int bin[] = new int[50];\n     int index = 0;\n     while(num > 0)\n     {\n         bin[index++] = num/2;\n         num = num%2;\n     }\n     for(int i = index-1;i >= 0;i--)\n     {\n         System.out.print(bin[i]);\n     }\n}\nd)\n\npublic void convertBinary(int num)\n {\n     int bin[] = new int[50];\n     int index = 0;\n     while(num > 0)\n     {\n         bin[++index] = num/2;\n         num = num%2;\n     }\n     for(int i = index-1;i >= 0;i--)\n     {\n         System.out.print(bin[i]);\n     }\n  }\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a LIFO (Last-In-First-Out) data structure used in various applications including function call management in programming languages. Recursion, which involves a function calling itself, uses the call stack to keep track of active function calls. Each recursive call consumes stack space, making recursion more memory-intensive than iteration.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Recursion uses more memory space than iteration because ………\nChoices:\nA) it uses stack instead of queue.\nB) every recursive call has to be stored.\nC) both A & B are true.\nD) None of the above.\n\nAnswer: B\nevery recursive call has to be stored."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A binary tree is a hierarchical data structure where each node has at most two children. An almost complete binary tree of depth 'd' is a tree in which all levels are completely filled except possibly the last, and the last level has all keys as left as possible. Properties of almost complete trees are important in data structures like heaps.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A binary tree of depth “d” is an almost complete binary tree if:\nChoices:\nA) Each leaf in the tree is either at level “d” or at level “d–1”\nB) For any node “n” in the tree with a right descendant at level “d”, all the left descendants of “n” that are leaves, are also at level “d”\nC) Both (A) & (B)\nD) None of the above\n\nAnswer: C\nBoth (A) & (B)"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: Sorting algorithms are used to reorder elements in a list based on comparison criteria. Merging two sorted arrays is a common subroutine in merge sort and takes linear time proportional to the sum of the sizes of the arrays. If two sorted lists of sizes m and n are merged, it takes O(m + n) time to combine them into one sorted list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Time required to merge two sorted lists of size m and n, is ……\nChoices:\nA) O(m | n)\nB) O(m + n)\nC) O(m log n)\nD) O(n log m)\n\nAnswer: B\nO(m + n)"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A graph is Eulerian if it contains a closed trail that visits every edge exactly once. A necessary and sufficient condition for a graph to be Eulerian is that it is connected and every vertex has an even degree. This property helps determine whether an Eulerian circuit exists in a given graph.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For which of the following combinations of the degrees of vertices would the connected graph be Eulerian?\na) 1,2,3\nb) 2,3,4\nc) 2,4,5\nd) 1,3,5\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure consisting of nodes, where each node contains data and a reference (or pointer) to the next node in the sequence. It enables efficient insertion and deletion of elements and is widely used in dynamic memory management.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A linear collection of data elements where the linear node is given by means of pointer is called?\na) Linked list\nb) Node list\nc) Primitive list\nd) Unordered list\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A complete undirected graph with n vertices contains n(n−1)/2 edges. A spanning tree of a graph connects all vertices with exactly (n−1) edges and no cycles. In a weighted graph, a minimum spanning tree (MST) is a tree with the lowest possible sum of edge weights. The maximum possible weight of an MST occurs when the (n−1) smallest edges are chosen.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let G be a complete undirected graph on 4 vertices, having 6 edges with weights being 1, 2, 3, 4, 5, and 6. The maximum possible weight that a minimum weight spanning tree of G can have is:\nChoices:\nA) 6\nB) 7\nC) 8\nD) 9\n\nAnswer: B\n7"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: During the compilation of a program, symbol tables are used to store information about variables, functions, objects, etc. Efficient implementations of symbol tables often use self-organizing lists, which adjust dynamically based on access patterns to reduce average lookup time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Symbol tables during compilation of program is efficiently implemented using __________\na) a singly linked list\nb) a doubly linked list\nc) a self organizing list\nd) an array\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix (Reverse Polish Notation) expressions eliminate the need for parentheses by using operator precedence and associativity rules. Operators with higher precedence are applied before those with lower precedence, and associativity determines the order when precedence is equal. Understanding these rules is key to converting between postfix and infix forms.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the postfix expression 4 5 6 a b 7 8 a c, where a, b, c are operators. Operator a has higher precedence over operators b and c. Operators b and c are right associative. Then, equivalent infix expression is:\na) 4 a 5 6 b 7 8 a c\nb) 4 a 5 c 6 b 7 a 8\nc) 4 b 5 a 6 c 7 a 8\nd) 4 a 5 b 6 c 7 a 8\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a dynamic data structure composed of nodes, each containing data and a pointer to the next node. In C/C++, passing a pointer to the head of a linked list into a function by value does not affect the original head outside the function, but if not handled carefully, the function may modify the pointer, leading to confusion in code behavior.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following function to traverse a linked list:\n// C++ version of traverse function\nvoid traverse(Node *head) {\n    while (head != NULL) {\n        printf(\"%d  \", head->data);\n        head = head->next;\n    }\n}\nChoices:\nA) The function may crash when the linked list is empty\nB) The function doesn't print the last node when the linked list is not empty\nC) The function is implemented incorrectly because it changes head\nD) None of the above\n\nAnswer: C\nThe function is implemented incorrectly because it changes head"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: A hash tree, also known as a Merkle tree, is a tree in which each leaf node contains a hash of a data block, and each non-leaf node contains a hash of its child nodes. It is widely used in blockchain and distributed systems to verify data integrity efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Hash tree is also known as _____\na) Merkle tree\nb) T -tree\nc) Hash table\nd) Bx-tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A priority queue is a special type of queue in which elements are ordered based on their priority. A Cartesian tree is a binary tree derived from a sequence of numbers, combining properties of both binary search trees and heaps. By combining a Cartesian tree with a priority queue and removing the minimum element at each step, the sequence can be sorted, mimicking the behavior of a priority queue sort.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What happens if we apply the below operations on an input sequence?\ni. Construct a Cartesian tree for input sequence\nii. Put the root element of above tree in a priority queue\niii. if(priority queue is not empty) then\niv. Search and delete minimum value in priority queue\nv. Add that to output\nvi. Add Cartesian tree children of above node to priority queue\n\na) Constructs a Cartesian tree\nb) Sorts the input sequence\nc) Does nothing\nd) Produces some random output\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A memory-efficient doubly linked list can be implemented using XOR (exclusive OR) of previous and next node addresses. This technique, known as XOR linked list, saves space by storing a single pointer per node that encodes both previous and next pointers using bitwise XOR.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you calculate the pointer difference in a memory-efficient doubly linked list?\na) head xor tail\nb) pointer to previous node xor pointer to next node\nc) pointer to previous node – pointer to next node\nd) pointer to next node – pointer to previous node\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: In postfix expression evaluation (Reverse Polish Notation), operands are pushed onto the stack. When an operator is encountered, the last two operands are popped, the operation is applied, and the result is pushed back onto the stack. This method is commonly used in compilers and calculators.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: While evaluating a postfix expression, when an operator is encountered, what is the correct operation to be performed?\na) Push it directly onto the stack\nb) Pop 2 operands, evaluate them, and push the result onto the stack\nc) Pop the entire stack\nd) Ignore the operator\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A weight-balanced tree is a type of balanced binary tree in which the weight (often measured by the number of nodes or size of subtrees) of left and right subtrees at each node maintains a specific proportion. This is governed by a balance factor 'a', ensuring the tree remains efficiently balanced for operations like insertions and deletions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the condition for a tree to be weight-balanced, where a is a factor and n is a node?\na) weight[n.left] >= a*weight[n] and weight[n.right] >= a*weight[n]\nb) weight[n.left] >= a*weight[n.right] and weight[n.right] >= a*weight[n]\nc) weight[n.left] >= a*weight[n.left] and weight[n.right] >= a*weight[n]\nd) weight[n] is a non-zero\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are fixed-size data structures that allow direct access to elements using indices. However, they have some limitations, such as fixed size and inefficient insertions or deletions at arbitrary positions. Random access, on the other hand, is a major advantage as it allows constant-time retrieval.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not a disadvantage to the usage of array?\na) Fixed size\nb) There are chances of wastage of memory space if elements inserted in an array are lesser than the allocated size\nc) Insertion based on position\nd) Accessing elements at specified positions\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing, a collision occurs when two different keys are mapped to the same hash value or index in a hash table. Collisions are inherent in hash functions and are typically handled through techniques like chaining or open addressing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Collision is caused due to the presence of two keys having the same value.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A min heap is a complete binary tree where the value of each node is less than or equal to the values of its children. This ensures that the smallest element is always at the root, and such trees are used in priority queues and efficient sorting algorithms.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Min heap is a complete binary tree.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A treap is a data structure that combines properties of binary search trees and heaps. It is also called a randomized binary search tree. Each node has a key (for BST property) and a randomly assigned priority (for heap property). The structure maintains both properties simultaneously.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A treap is a cartesian tree with ___________\na) additional value, which is a priority value to the key generated randomly\nb) additional value, which is a priority value to the key generated sequentially\nc) additional heap rule\nd) additional operations like remove a range of elements\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A queue is a FIFO (First-In-First-Out) data structure. When implemented using recursion, elements can be removed from the front and reinserted at the rear to reverse the order of elements. This technique can be used to reverse a queue using recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose you are given an implementation of a queue of integers.\nConsider the following function:\n\nvoid f(queue<int> &Q) {\n    int i;\n    if (!Q.empty()) {\n        i = Q.front();\n        Q.pop();\n        f(Q);\n        Q.push(i);\n    }\n}\n\nChoices:\nA) Leaves the queue Q unchanged\nB) Reverses the order of the elements in the queue Q\nC) Deletes the element at the front of the queue Q and inserts it at the rear keeping the other elements in the same order\nD) Empties the queue Q\n\nAnswer: B\nReverses the order of the elements in the queue Q"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a binary tree, internal nodes are nodes that have at least one child. A node of degree 1 has only one child, and a node of degree 2 has two children. The number of leaf nodes in a binary tree can be derived from the structure using various tree properties and formulas.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a binary tree, the number of internal nodes of degree 1 is 5, and the number of internal nodes of degree 2 is 10. The number of leaf nodes in the binary tree is:\nChoices:\nA) 10\nB) 11\nC) 12\nD) 15\n\nAnswer: B\n11"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays in C++ are fixed-size containers for storing sequential elements. Recursive functions can manipulate arrays by modifying their elements. A classic problem is to reverse an array using recursion, where the function swaps elements from both ends and recurses toward the center.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following code?\n\n#include <bits/stdc++.h> \nusing namespace std; \n\nvoid func(int arr[], int left, int right) \n{ \n    if (left >= right) \n        return; \n\n    int temp = arr[left];  \n    arr[left] = arr[right]; \n    arr[right] = temp; \n\n    func(arr, left + 1, right - 1);  \n}      \n\nvoid printArray(int arr[], int size) \n{ \n    for (int i = 0; i < size; i++) \n        cout << arr[i] << \" \"; \n} \n\nint main() \n{ \n    int arr[] = {1,2,3,4}; \n    int n = sizeof(arr) / sizeof(arr[0]); \n    func(arr, 0, n-1); \n    printArray(arr, n); \n    return 0; \n}\n\nChoices:\na) 1 2 3 4\nb) 4 3 2 1\nc) 1 4 2 3\nd) 4 1 2 3\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix (Reverse Polish) expressions are evaluated using a stack. Operands are pushed onto the stack, and when an operator is encountered, the appropriate number of operands are popped, the operation is applied, and the result is pushed back. In the expression ab*cd*+, values are substituted and operations follow the postfix order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the result of the following postfix expression?\nab*cd*+ where a=2, b=2, c=3, d=4.\na) 16\nb) 12\nc) 14\nd) 10\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In graph theory, a multigraph allows multiple edges between the same set of vertices. When such graphs also allow self-loops—edges that connect a vertex to itself—they are referred to as pseudographs. These structures are useful in modeling certain real-world networks and edge-weighted systems.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: MultiGraphs having self-loops are called PseudoGraphs?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Recursive functions are functions that call themselves with modified parameters. The function in the question calculates the factorial of a number. The factorial of a number n (denoted as n!) is the product of all positive integers less than or equal to n.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What value does function mystery return when called with a value of 4?\n\nint mystery ( int number ) {\n    if ( number <= 1 )\n        return 1;\n    else\n        return number * mystery( number – 1 );\n}\n\nChoices:\nA) 0\nB) 1\nC) 4\nD) 24\n\nAnswer: D\n24"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In dynamic programming and combinatorics, reaching the end of an array can be modeled by counting the number of valid jumps from each position based on allowed step values. This type of problem appears in variants of the staircase or jump game problems.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In how many different ways can we reach the end of the array arr[]={1,3,5,8,9}?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Reversing an array involves swapping elements from the two ends toward the center. The number of swaps required is ⌊n/2⌋ for an array of length n. If n is odd, the middle element doesn't require a swap.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many swaps are required for reversing an array having n elements where n is an odd number?\na) (n-1)/2\nb) n/2\nc) (n/2) – 1\nd) (n+1)/2\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Quick sort is a divide-and-conquer sorting algorithm that selects a pivot and partitions the array such that elements less than or equal to the pivot go to the left, and those greater go to the right. This partitioning process is repeated recursively to sort the array efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The sorting technique where array to be sorted is partitioned again and again in such a way that all elements less than or equal to partitioning element appear before it and those which are greater appear after it, is called ……\nChoices: ['A\\nMerge sort', 'B\\nQuick sort \\n (A) Merge sort \\n (B) Quick sort', 'C\\nSelection sort', 'D\\nNone of these']\n\nAnswer: B\nQuick sort \n (A) Merge sort \n (B) Quick sort"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: AA-trees are a form of balanced binary search tree that simplify the balancing logic of red-black trees. Though they perform fewer types of rotations (only right and left skew), they may require more frequent rotations to maintain balance, particularly in worst-case insertion sequences.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: AA-Trees make more rotations than a red-black tree.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: Heap allocation refers to memory that is dynamically allocated at runtime. Programming languages that allow dynamic data structures (e.g., linked lists, trees) require heap allocation because the size and structure of such data are not known at compile time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which languages necessarily need heap allocation in the runtime environment?\nChoices: ['A\\nThose that support recursion', 'B\\nThose that use dynamic scoping', 'C\\nThose that use global variables', 'D\\nThose that allow dynamic data structures']\n\nAnswer: D\nThose that allow dynamic data structures"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Reversing an array inverts the order of its elements, while rotation shifts the elements cyclically. The output of reversal and rotation differs in most cases, as they are fundamentally different operations. Therefore, applying both will not consistently produce the same result.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When array reversal and rotation are applied to the same array, the output produced will also be the same every time.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a complete binary tree, every level is completely filled except possibly the last. A full binary tree with n leaf nodes contains 2n - 1 total nodes, based on the structural properties of binary trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A full binary tree with n leaf nodes contains how many total nodes?\nChoices: ['A\\nn nodes', 'B\\nlog 2 n nodes', 'C\\n2n –1 node', 'D\\n2 n nodes']\n\nAnswer: C\n2n –1 node"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A hash tree, also known as a Merkle tree, is used in blockchain systems and digital currencies like Bitcoin and Ethereum to efficiently and securely verify the integrity of large datasets. Each non-leaf node is a hash of its child nodes, enabling quick and tamper-evident verification.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Where is the hash tree used?\na) in digital currency\nb) in sorting of large data\nc) for indexing in databases\nd) in encryption of data\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A complete binary tree is a binary tree in which all levels are fully filled except possibly the last, which is filled from left to right. If a complete binary tree has n leaf nodes, it has a total of 2n - 1 nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A complete binary tree with n leaf nodes has ________\nChoices: ['A\\nn+1 nodes', 'B\\n2n-1 nodes', 'C\\n2n+1 nodes', 'D\\nn(n-1)/2 nodes']\n\nAnswer: B\n2n-1 nodes"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A skew heap is a variant of a binary heap that is self-adjusting, with no structural constraints like leftist heaps. This makes the relationship between skew heaps and leftist heaps similar to that between splay trees (self-adjusting) and AVL trees (strictly balanced).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The relationship of skew heaps to leftist heaps is analogous to that of?\na) Splay tree and AVL tree\nb) Red black tree and AVL tree\nc) Binary tree and Splay tree\nd) Binary tree and Red black tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A balanced binary tree ensures that the height of the tree remains logarithmic with respect to the number of elements. This allows for efficient search, insertion, and deletion operations, all of which run in O(log n) worst-case time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A balanced binary tree with n items allows the lookup of an item in ____ worst-case time.\na) O(log n)\nb) O(nlog 2)\nc) O(n)\nd) O(1)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In C, arrays can be initialized during declaration using curly braces and a comma-separated list of values. The correct syntax for initializing an array of three integers is `int arr[3] = {1, 2, 3};`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you initialize an array in C?\na) int arr[3] = (1,2,3);\nb) int arr(3) = {1,2,3};\nc) int arr[3] = {1,2,3};\nd) int arr(3) = (1,2,3);\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A simple connected graph with n vertices and n edges forms a single cycle. The number of different spanning trees in such a graph depends on how many edges can be removed without disconnecting the graph. It can be shown that such a graph has at least 3 spanning trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the largest integer m such that every simple connected graph with n vertices and n edges contains at least m different spanning trees?\nChoices: ['A\\n1', 'B\\n2', 'C\\n3', 'D\\nn']\n\nAnswer: C\n3"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack can be used to reverse a string. In a palindrome check, each character is pushed onto a stack and then popped to reverse the string. If the original string and the reversed string match, it is a palindrome.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Select the appropriate code which tests for a palindrome.\na)\n<code with proper stack pop reversal logic>\nb)\n<code using peek instead of pop>\nc)\n<code with extra pop causing string truncation>\nd)\n<code with incorrect reverse logic and reversed condition>\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Linear probing is a collision resolution technique in open addressing where the next index is computed as `(hash + f(i)) mod table_size`, where `f(i) = i`. So the probing function is linear, and the hash function used is typically `H(x) = (key + i) % table_size`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the hash function used in linear probing?\na) H(x)= key mod table size\nb) H(x)= (key+ F(i2)) mod table size\nc) H(x)= (key+ F(i)) mod table size\nd) H(x)= X mod 17\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: An inversion in an array is a pair of indices (i, j) such that i < j and A[i] > A[j]. The expected number of inversions in a randomly ordered array of n distinct elements is n(n-1)/4, which is half of the worst-case (reversed array) count.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let A[1...n] be an array of n distinct numbers. If i < j and A[i] > A[j], then the pair (i, j) is called an inversion of A. What is the expected number of inversions in any permutation on n elements?\nChoices: ['A\\nn(n-1)/2', 'B\\nn(n-1)/4', 'C\\nn(n+1)/4', 'D\\n2n[logn]']\n\nAnswer: B\nn(n-1)/4"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A skew heap is a form of self-adjusting heap that does not impose any structural constraints like leftist heaps. Swapping during merge operations is done unconditionally, without maintaining specific balance factors, hence no fixed constraints are required.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In skew heaps, certain constraints are to be met in order to perform swapping.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a Last-In-First-Out (LIFO) data structure. When reading characters of a string and pushing them onto a stack, popping them out results in reversing the string. This is a common technique used to reverse strings or check for palindromes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following pseudocode that uses a stack:\n\n# Declare a stack of characters\nword = \"example\"  # Replace with the word you want to read\nchar_stack = []\n\n# While there are more characters in the word to read\nfor c in word:\n    char_stack.append(c)  # Push the character on the stack\n\n# While the stack is not empty\nwhile char_stack:\n    c = char_stack.pop()  # Pop a character off the stack\n    print(c, end='')  # Write the character to the screen\n\nChoices: ['A\\ngeeksquizgeeksquiz', 'B\\nziuqskeeg', 'C\\ngeeksquiz', 'D\\nziuqskeegziuqskeeg']\n\nAnswer: B\nziuqskeeg"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: When finding both the smallest and largest elements in an array, a more efficient approach than scanning twice can be used. By comparing elements in pairs, the number of comparisons can be reduced. The optimal method requires about n + (n/2 - 1) comparisons.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The total comparisons in finding both smallest and largest elements are:\na) 2*n + 2\nb) n + ((n+1)/2) - 2\nc) n + logn\nd) n^2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Tree traversals define the order in which nodes are visited. In postorder traversal, the left subtree is visited first, then the right subtree, and finally the node itself. This is often used in deleting trees or evaluating postfix expressions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following piece of code do?\n\npublic void func(Tree root)\n{\n    func(root.left());\n    func(root.right());\n    System.out.println(root.data());\n}\n\na) Preorder traversal\nb) Inorder traversal\nc) Postorder traversal\nd) Level order traversal\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Infix expressions use standard operator precedence and parentheses. To convert an infix expression to postfix (Reverse Polish Notation), operators are placed after their operands according to precedence and associativity. This avoids the need for parentheses.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the corresponding postfix expression for the given infix expression?\n\nChoices:\na) ab*cdef/^*g-h+\nb) abcdef^/*g*h*+\nc) abcd*^ed/g*-h*+\nd) abc*de^fg/*-*h+\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A plane graph is a graph drawn on a plane without any edge crossings. Euler’s formula states that for any connected plane graph, V - E + R = 2. If a plane graph has multiple connected components, the formula generalizes to V - E + R = C + 1, where C is the number of components.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given a plane graph, G having 2 connected components, 6 vertices, 7 edges and 4 regions, what will be the number of connected components?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The given C++ program performs a depth-first traversal (DFS) on a graph represented by an adjacency matrix. Starting from vertex 0, it recursively visits all unvisited neighbors. The output corresponds to the order in which the DFS visits the vertices based on the adjacency matrix.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the output of the following C++ program if the given input is:\n\n0 0 0 1 1\n0 0 0 0 1\n0 0 0 1 0\n1 0 1 0 0\n1 1 0 0 0\n\n<code snippet follows DFS on a 5x5 matrix>\n\nChoices:\na) 0 2 3 1 4\nb) 0 3 2 4 1\nc) 0 2 3 4 1\nd) 0 3 2 1 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a Last-In-First-Out (LIFO) data structure. When reading characters of a string and pushing them onto a stack, popping them out results in reversing the string. This is a common technique used to reverse strings or check for palindromes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following pseudocode that uses a stack:\n\n# Declare a stack of characters\nword = \"example\"  # Replace with the word you want to read\nchar_stack = []\n\n# While there are more characters in the word to read\nfor c in word:\n    char_stack.append(c)  # Push the character on the stack\n\n# While the stack is not empty\nwhile char_stack:\n    c = char_stack.pop()  # Pop a character off the stack\n    print(c, end='')  # Write the character to the screen\n\nChoices: ['A\\ngeeksquizgeeksquiz', 'B\\nziuqskeeg', 'C\\ngeeksquiz', 'D\\nziuqskeegziuqskeeg']\n\nAnswer: B\nziuqskeeg"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: When finding both the smallest and largest elements in an array, a more efficient approach than scanning twice can be used. By comparing elements in pairs, the number of comparisons can be reduced. The optimal method requires about n + (n/2 - 1) comparisons.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The total comparisons in finding both smallest and largest elements are:\na) 2*n + 2\nb) n + ((n+1)/2) - 2\nc) n + logn\nd) n^2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Tree traversals define the order in which nodes are visited. In postorder traversal, the left subtree is visited first, then the right subtree, and finally the node itself. This is often used in deleting trees or evaluating postfix expressions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following piece of code do?\n\npublic void func(Tree root)\n{\n    func(root.left());\n    func(root.right());\n    System.out.println(root.data());\n}\n\na) Preorder traversal\nb) Inorder traversal\nc) Postorder traversal\nd) Level order traversal\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Infix expressions use standard operator precedence and parentheses. To convert an infix expression to postfix (Reverse Polish Notation), operators are placed after their operands according to precedence and associativity. This avoids the need for parentheses.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the corresponding postfix expression for the given infix expression?\n\nChoices:\na) ab*cdef/^*g-h+\nb) abcdef^/*g*h*+\nc) abcd*^ed/g*-h*+\nd) abc*de^fg/*-*h+\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A plane graph is a graph drawn on a plane without any edge crossings. Euler’s formula states that for any connected plane graph, V - E + R = 2. If a plane graph has multiple connected components, the formula generalizes to V - E + R = C + 1, where C is the number of components.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given a plane graph, G having 2 connected components, 6 vertices, 7 edges and 4 regions, what will be the number of connected components?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The given C++ program performs a depth-first traversal (DFS) on a graph represented by an adjacency matrix. Starting from vertex 0, it recursively visits all unvisited neighbors. The output corresponds to the order in which the DFS visits the vertices based on the adjacency matrix.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the output of the following C++ program if the given input is:\n\n0 0 0 1 1\n0 0 0 0 1\n0 0 0 1 0\n1 0 1 0 0\n1 1 0 0 0\n\n<code snippet follows DFS on a 5x5 matrix>\n\nChoices:\na) 0 2 3 1 4\nb) 0 3 2 4 1\nc) 0 2 3 4 1\nd) 0 3 2 1 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In an infix expression, operators are placed between operands. This is the common human-readable format for arithmetic expressions. The recursive pattern of producing left expression → operator → right expression characterizes infix notation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The expression obtained by recursively producing a left expression, followed by an operator, followed by recursively producing a right expression is called?\na) prefix expression\nb) infix expression\nc) postfix expression\nd) parenthesized expression\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: The Rope data structure is a binary tree used to efficiently store and manipulate very long strings. In programming, a Rope is also known as a Cord. It allows for efficient concatenation and substring operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is also known as Rope data structure?\na) Cord\nb) String\nc) Array\nd) Linked List\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Two balanced binary search trees with m and n elements can be merged into one balanced BST in O(m+n) time. The process typically involves converting both trees to sorted arrays, merging them, and reconstructing a balanced BST from the merged array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Two balanced binary trees are given with m and n elements respectively. They can be merged into a balanced binary search tree in ____ time.\na) O(m+n)\nb) O(mn)\nc) O(m)\nd) O(mlog n)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The number of binary trees that can be formed with a given set of nodes and a specific traversal sequence depends on the properties of binary trees and Catalan numbers. For 3 nodes with a fixed postorder traversal (e.g., N, M, L), only a limited number of trees can match that sequence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the possible number of binary trees that can be created with 3 nodes, giving the sequence N, M, L when traversed in post-order?\na) 15\nb) 3\nc) 5\nd) 8"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In C, arrays are initialized using curly braces. The correct syntax to initialize a three-element integer array is `int arr[3] = {1, 2, 3};`. Using parentheses instead of braces is syntactically incorrect.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you initialize an array in C?\na) int arr[3] = (1,2,3);\nb) int arr(3) = {1,2,3};\nc) int arr[3] = {1,2,3};\nd) int arr(3) = (1,2,3);\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A full binary tree is a tree in which every node has either 0 or 2 children. In such a tree, if the number of internal nodes is I, then the number of leaves (L) is always L = I + 1. This is a fundamental property derived from the structure of full binary trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a full binary tree if number of internal nodes is I, then number of leaves L are?\na) L = 2*I\nb) L = I + 1\nc) L = I – 1\nd) L = 2*I – 1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In a singly linked list, accessing the k-th element from the beginning can be done in O(1) time if a pointer to the head is maintained and traversed. However, finding the k-th element from the end generally requires a full traversal of the list or use of two pointers, making the time complexity O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the time complexities of finding 8th element from beginning and 8th element from end in a singly linked list? Let n be the number of nodes in linked list, you may assume that n > 8.\nChoices: ['A\\nO(n) and O(n)', 'B\\nO(1) and O(1)', 'C\\nO(n) and O(1)', 'D\\nO(1) and O(n)']\n\nAnswer: D\nO(1) and O(n)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: B-trees and B+ trees are used in databases and file systems to maintain sorted data and allow searches, insertions, and deletions in logarithmic time. B+ trees usually have a greater fanout than B-trees and support simpler deletion. However, B+ trees do not necessarily have greater depth than B-trees, making that statement false.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is false?\na) Compared to B-tree, B+ -tree has larger fanout\nb) Deletion in B-tree is more complicated than in B+ -tree\nc) B+ -tree has greater depth than corresponding B-tree\nd) Both B-tree and B+ -tree have same search and insertion efficiencies\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: AA-trees are a form of balanced binary search trees that simplify the balancing operations of red-black trees. The tree structure is designed to consider only two shapes when performing rotations: skew and split, which simplifies rebalancing. Thus, only 2 structural shapes need to be handled.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many different shapes does maintenance of AA-Tree need to consider?\na) 7\nb) 5\nc) 2\nd) 3\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A suffix tree is a specialized data structure that allows efficient operations on substrings of a string, such as pattern matching, longest repeated substring, or finding substrings in linear time. This makes it ideal for fast string operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which tree allows fast implementation of string operation?\na) Rope Tree\nb) Suffix Tree\nc) Tango Tree\nd) Top Tree\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Separate chaining is a method used in hashing to handle collisions by maintaining a linked list of all elements that hash to the same index. Although effective in managing collisions, this technique requires additional memory due to the use of pointers and linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a disadvantage of using separate chaining using linked lists?\na) It requires many pointers\nb) It requires linked lists\nc) It uses array\nd) It does not resolve collision\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: An edge cluster in graph theory typically refers to a grouping of edges that are densely connected or form a small subgraph. If an edge cluster is defined as a minimal group, it usually starts with a single edge connecting two vertices.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many edges are present in Edge cluster?\na) 0\nb) 1\nc) 2\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A Cartesian tree is a binary tree derived from a sequence of values where the in-order traversal yields the original sequence and each node follows heap property. It is not height-balanced, and if the input values are distinct, the Cartesian tree is uniquely determined.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the below statements are true?\ni. Cartesian tree is not a height balanced tree\nii. Cartesian tree of a sequence of unique numbers can be uniquely generated\n\na) both statements are true\nb) only i. is true\nc) only ii. is true\nd) both are false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: In Java, the Stack class from `java.util` throws an `EmptyStackException` if a pop operation is attempted on an empty stack. This exception is a subclass of `RuntimeException` and is thrown at runtime.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What happens when you pop from an empty stack while implementing using the Stack ADT in Java?\na) Undefined error\nb) Compiler displays a warning\nc) EmptyStackException is thrown\nd) NoStackException is thrown\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A 2-3 tree is a balanced search tree in which every internal node has either two or three children. The height of a 2-3 tree with n elements lies between log base 3 of (n+1) and log base 2 of (n+1), ensuring logarithmic search time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The height of a 2-3 tree with n elements is ______\na) between (n/2) and (n/3)\nb) (n/6)\nc) between (n) and log2(n + 1)\nd) between log3(n + 1) and log2(n + 1)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A sparse array is a data structure that efficiently stores and processes arrays with a large number of zero or default values. Instead of allocating space for every element, it stores only non-zero values and their positions, making it memory-efficient compared to a naive array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the difference between a normal (naive) array and a sparse array?\na) Sparse array can hold more elements than a normal array\nb) Sparse array is memory efficient\nc) Sparse array is dynamic\nd) A naive array is more efficient\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Parentheses matching is a common problem in compiler design and expression parsing. A stack data structure is ideal for this task, as it allows tracking of opening symbols and matching them with closing ones in a Last-In-First-Out (LIFO) manner.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following data structures can be used for parentheses matching?\na) n-ary tree\nb) queue\nc) priority queue\nd) stack\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: To print the right view of a binary tree, level order traversal using a queue is used. The rightmost node at each level is printed. In the provided C++ code, the queue must be properly initialized with the root node. If not, the traversal won't begin.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is wrong in the below code of printing Right View of a binary tree using the Queue data structure?\n\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nvoid printRightView(Node* root) {\n    if (root == nullptr) return;\n\n    queue<Node*> q;\n    q.push(root);\n    while (!q.empty()) {\n        int n = q.size();\n        for (int i = 0; i < n; i++) {\n            Node* x = q.front();\n            q.pop();\n            if (i == n - 1) {\n                cout << x->data << \" \";\n            }\n            if (x->left) {\n                q.push(x->left);\n            }\n            if (x->right) {\n                q.push(x->right);\n            }\n        }\n    }\n}\n\nChoices: ['A\\nWe have not initialized anything in the Queue', 'B\\nQueue will never be empty.', 'C\\nleft and right nodes of the tree are null.', 'D\\nNone']\n\nAnswer: A\nWe have not initialized anything in the Queue"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a balanced binary search tree, summing all elements between two values L and H requires traversing only relevant branches. The tightest time bound depends on the number of such elements (m) and the tree's properties, leading to a time complexity involving logarithmic and linear components.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose we have a balanced binary search tree T holding n numbers. We are given two numbers L and H and wish to sum up all the numbers in T that lie between L and H. Suppose there are m such numbers in T. If the tightest upper bound on the time to compute the sum is O(n^a log^b n + m·log^d n), the value of a + 10b + 100c + 1000d is ____.\nChoices: ['A\\n60', 'B\\n110', 'C\\n210', 'D\\n50']\n\nAnswer: B\n110"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: The trace of a matrix is defined as the sum of its diagonal elements from the top-left to the bottom-right. This is commonly calculated by iterating over the matrix where row and column indices are equal (i == j).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following piece of code do?\n\nfor(int i = 0; i < row; i++)\n{  \n    for(int j = 0; j < column; j++)\n    {\n        if(i == j)\n            sum = sum + (array[i][j]);\n    }\n}\nSystem.out.println(sum);\n\na) Normal of a matrix\nb) Trace of a matrix\nc) Square of a matrix\nd) Transpose of a matrix\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: In separate chaining hashing, collisions are resolved using linked lists. The load factor is defined as the number of elements divided by the number of buckets. A load factor of 1 is typically optimal, meaning the number of elements is equal to the number of buckets.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What should be the load factor for separate chaining hashing?\na) 0.5\nb) 1\nc) 1.5\nd) 2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Rotating an array by k positions involves moving the elements such that each element shifts by k places. For example, rotating [1, 2, 3, 4, 5] by 2 positions to the left results in [3, 4, 5, 1, 2].\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the resulting array after rotating arr[]={1, 2, 3, 4, 5} by 2?\na) 2, 1, 3, 4, 5\nb) 3, 4, 5, 1, 2\nc) 4, 5, 1, 2, 3\nd) 1, 2, 3, 5, 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Universal hashing is a method where the hash function is chosen at random from a family of functions. This randomization provides good average-case performance and protects against worst-case scenarios caused by poor hash function choices.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which scheme uses a randomization approach?\na) hashing by division\nb) hashing by multiplication\nc) universal hashing\nd) open addressing\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A doubly linked list allows traversal in both forward and backward directions using two pointers per node. While more flexible, it requires extra space and pointer handling, making it more complex to implement than a singly linked list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is false about a doubly linked list?\na) We can navigate in both the directions\nb) It requires more space than a singly linked list\nc) The insertion and deletion of a node take a bit longer\nd) Implementing a doubly linked list is easier than singly linked list\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a Directed Acyclic Graph (DAG), the shortest paths from a single source can be computed efficiently using topological sorting. Once the vertices are sorted, the shortest paths can be calculated in linear time with respect to the number of vertices and edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following algorithms can be used to efficiently calculate single source shortest paths in a Directed Acyclic Graph?\nChoices: ['A\\nDijkstra', 'B\\nBellman-Ford', 'C\\nTopological Sort', 'D\\nStrongly Connected Component']\n\nAnswer: C\nTopological Sort"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Many recursive algorithms can be rewritten in a non-recursive way using an explicit stack. This is common when converting recursive implementations to iterative versions for better memory control or performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What data structure would you most likely see in non-recursive implementation of a recursive algorithm?\na) Stack\nb) Linked List\nc) Tree\nd) Queue\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: To convert a decimal number to binary using a stack, the number is repeatedly divided by 2, and the remainders are pushed onto the stack. Popping the stack gives the binary representation in the correct order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Using stacks, how do you obtain the binary representation of a number?\n<Options contain multiple code snippets>\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In the linked list implementation of a queue, the `rear` pointer is updated when a new node is inserted. The `front` pointer remains unchanged unless the queue is empty before insertion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In linked list implementation of a queue, front and rear pointers are tracked. Which of these pointers will change during an insertion into a NONEMPTY queue?\na) Only front pointer\nb) Only rear pointer\nc) Both front and rear pointer\nd) No pointer will be changed\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Balanced parentheses can be verified using a stack by pushing opening brackets and popping when matching closing brackets are found. If the stack is empty at the end and no mismatch occurred, the string is balanced. Time complexity is O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Write a piece of code which returns true if the string contains balanced parenthesis, false otherwise.\n<Options contain multiple Java code snippets>\n\na) O(logn)\nb) O(n)\nc) O(1)\nd) O(nlogn)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In Java, arrays are instantiated using the `new` keyword followed by the type and size in square brackets. For example: `int arr[] = new int[3];` allocates an array of 3 integers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you instantiate an array in Java?\na) int arr[] = new int(3);\nb) int arr[];\nc) int arr[] = new int[3];\nd) int arr() = new int(3);\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A circular queue is a linear data structure in which the last position is connected back to the first to make a circle. It is also known as a ring buffer and is used in buffering and scheduling.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Circular Queue is also known as ________\na) Ring Buffer\nb) Square Buffer\nc) Rectangle Buffer\nd) Curve Buffer\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a Last-In-First-Out (LIFO) data structure, meaning the last element pushed onto the stack is the first one to be popped off. So if A, B, C, and D are pushed in that order, the removal order will be D, C, B, A.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If the elements “A”, “B”, “C” and “D” are placed in a stack and are deleted one at a time, what is the order of removal?\na) ABCD\nb) DCBA\nc) DCAB\nd) ABDC\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: When merging multiple sorted files, the number of comparisons depends on the total number of elements and the strategy used. Optimal merging of 4 files with 15, 3, 9, and 8 elements minimizes comparisons to 15 when using an efficient strategy like Huffman coding or binary merging trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The total number of comparisons required to merge 4 sorted files containing 15, 3, 9 and 8 records into a single sorted file is ______.\nChoices: ['A\\n66', 'B\\n39', 'C\\n15', 'D\\n3']\n\nAnswer: C\n15"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In a binary search tree (BST), the left child has a value less than its parent, but in general binary trees this condition may not hold. Thus, the statement only applies to BSTs, not to all trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Left child of parent node has value lesser than the parent node.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a max-heap, the largest key is always located at the root node because each parent must be greater than or equal to its children. This structure supports efficient maximum retrieval in constant time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a max-heap, the element with the greatest key is always in which node?\na) Leaf node\nb) First node of left sub tree\nc) Root node\nd) First node of right sub tree\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The Top Tree data structure is used to dynamically maintain information in trees. It relies on the divide and conquer paradigm by breaking trees into clusters and solving problems in a recursive fashion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which algorithm is used in the top tree data structure?\na) Divide and Conquer\nb) Greedy\nc) Backtracking\nd) Branch\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A full binary tree is a binary tree in which every node has either 0 or 2 children. In such trees, the number of total nodes is given by the formula 2n - 1, where n is the number of leaves.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A full binary tree with n leaves contains ______.\nChoices: ['A\\nn nodes', 'B\\nlog n2 nodes', 'C\\n2n – 1 nodes', 'D\\n2n nodes']\n\nAnswer: C\n2n – 1 nodes"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: In algorithms that use stacks (e.g., expression evaluation, syntax checking), it is expected that the stack is empty at the end if all operations are properly matched. If the stack is not empty, it indicates an error such as unbalanced parentheses.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An error is reported when the stack is not empty at the end.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: An Inverter Graph is a type of Directed Acyclic Graph (DAG), used in applications like digital logic and dataflow modeling where the graph represents dependencies that must not form cycles.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An Inverter Graph is a type of __________\na) Multigraph\nb) Cyclic Graph\nc) Directed Acyclic Graph\nd) Directed Acyclic Word Graph\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Linked lists are dynamic data structures ideal for situations where data sizes change frequently. They allow for efficient insertion and deletion operations, making them well-suited for structures that frequently grow and shrink.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Linked lists are best suited ______\nA. for relatively permanent collections of data.\nB. for the size of the structure and the data in the structure are constantly changing.\nC. data structure\nD. for none of the above situations\n\nAnswer: B"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: In linked list implementation of a queue, available nodes are often managed using a separate free list called the AVAIL list. When inserting a new node, one is taken from this AVAIL list and linked into the queue.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In case of insertion into a linked queue, a node borrowed from the __________ list is inserted in the queue.\na) AVAIL\nb) FRONT\nc) REAR\nd) NULL\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A pseudograph is a graph that allows both multiple edges between nodes and loops (edges that connect a vertex to itself). In an adjacency matrix, loops are indicated by non-zero entries along the diagonal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given Adjacency matrices, determine which of them are PseudoGraphs?\ni) {{1,0} {0,1}}\nii) {{0,1} {1,0}}\niii) {{0,0,1} {0,1,0} {1,0,0}}\na) only i)\nb) ii) and iii)\nc) i) and iii)\nd) i), ii), and iii)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a decision tree that sorts n elements, the height of the tree corresponds to the minimum number of comparisons needed in the worst case. Since at least n - 1 comparisons are required, the height is in Ω(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Any decision tree that sorts n elements has height\nChoices: ['A\\nΩ(n)', 'B\\nΩ(log n)', 'C\\nΩ(n log n)', 'D\\nΩ(n²)']\n\nAnswer: A\nΩ(n)"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In a hypergraph, an edge (called a hyperedge) can connect any number of vertices. The degree of a vertex is the number of hyperedges it belongs to. The degree sequence is the list of vertex degrees sorted in non-increasing order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the degree sequence of the given HyperGraph, in non-increasing order?\nV = {v1,v2,v3,v4,v5,v6}, E = {{v1,v4,v5}, {v2,v3,v4,v5}, {v2}, {v1}, {v1,v6}}\na) 3,2,1,1,1,1\nb) 3,2,2,2,1,1\nc) 3,2,2,2,2,1\nd) 3,2,2,1,1,1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A queue can be implemented using two stacks. One stack is used for enqueue operations and the other for dequeue, allowing the queue to maintain its First-In-First-Out (FIFO) property using Last-In-First-Out (LIFO) stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The minimum number of stacks needed to implement a queue is:\nChoices: ['A\\n3', 'B\\n1', 'C\\n2', 'D\\n4']\n\nAnswer: C\n2"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: Topological sorting of a Directed Acyclic Graph (DAG) involves ordering its vertices such that for every directed edge u → v, u appears before v. It can be done in linear time using Depth First Search (DFS) or Kahn’s algorithm.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The topological sorting of any DAG can be done in ________ time.\na) cubic\nb) quadratic\nc) linear\nd) logarithmic\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The number of distinct binary search trees (BSTs) that can be formed with n distinct keys is given by the nth Catalan number. For 4 keys, the number is C(4) = 14.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many distinct binary search trees can be created out of 4 distinct keys?\nChoices: ['A\\n4', 'B\\n14', 'C\\n24', 'D\\n42']\n\nAnswer: B\n14"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A priority queue is a special type of queue where each element has a priority. Elements with higher priority are dequeued before those with lower priority. Priority queues can be implemented as ascending or descending order queues depending on whether the highest or lowest value has the highest priority.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the type of priority queue?\nChoices: ['A\\nAscending Order Priority Queue', 'B\\nDescending order Priority Queue', 'C\\nDeque', 'D\\nBoth A and B.']\n\nAnswer: D\nBoth A and B."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A binary tree is a binary search tree (BST) if an in-order traversal of the tree results in a sorted (non-decreasing) sequence of values. This property helps distinguish BSTs from other binary trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: One can determine whether a binary tree is a binary search tree by traversing it in ________.\nChoices: ['A\\nPre-order', 'B\\nIn-order', 'C\\nPost-order', 'D\\nAny of these']\n\nAnswer: B\nIn-order"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: DNA sequence alignment is commonly solved using dynamic programming algorithms like Needleman-Wunsch or Smith-Waterman, not traditional string-matching algorithms like Rabin-Karp or KMP, which are better suited for exact matching rather than similarity-based alignment.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In DNA sequence alignment, which string-matching algorithm is commonly used to identify similarities between two DNA sequences efficiently?\nChoices: ['A\\nRabin-Karp algorithm', 'B\\nKnuth-Morris-Pratt algorithm', 'C\\nZ function', 'D\\nNone of the above']\n\nAnswer: D\nNone of the above"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays allow fast random access due to contiguous memory allocation and have better cache locality. Linked lists allow faster insertion and deletion but lack random access and generally have higher access time due to pointer traversal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following points is/are not true about linked list data structure when it is compared with an array?\na) Arrays have better cache locality that can make them better in terms of performance\nb) It is easy to insert and delete elements in linked list\nc) Random access is not allowed in a typical implementation of linked lists\nd) Access of elements in linked list takes less time than compared to arrays\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A skip list is a data structure that allows fast search within an ordered sequence of elements. It uses multiple layers of linked lists to achieve average-case logarithmic time complexity for search, insertion, and deletion operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a skip list?\na) A linked list with size value in nodes\nb) A linked list that allows faster search within an ordered sequence\nc) A linked list that allows slower search within an ordered sequence\nd) A tree which is in the form of linked list\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are data structures used to store multiple elements of the same type in contiguous memory. They support indexing, which makes access efficient, and are preferred when working with homogeneous data.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the advantages of arrays?\na) Objects of mixed data types can be stored\nb) Elements in an array cannot be sorted\nc) Index of first element of an array is 1\nd) Easier to store elements of same data type\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In the array representation of a complete binary tree (1-indexed), the children of a node at index w are located at indices 2w and 2w + 1. This layout allows efficient traversal without using pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the children for node ‘w’ of a complete-binary tree in an array representation?\na) 2w and 2w+1\nb) 2+w and 2-w\nc) w+1/2 and w/2\nd) w-1/2 and w+1/2\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a binary search tree (BST), the maximum element is always found by traversing the rightmost path starting from the root, since all right children have greater values.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How will you find the maximum element in a binary search tree?\na)\n\npublic void max(Tree root)\n{\n while(root.left() != null)\n {\n  root = root.left();\n }\n System.out.println(root.data());\n}\nb)\n\npublic void max(Tree root)\n{\n while(root != null)\n {\n  root = root.left();\n }\n System.out.println(root.data());\n}\nc)\n\npublic void max(Tree root)\n{\n while(root.right() != null)\n {\n  root = root.right();\n }\n System.out.println(root.data());\n}\nd)\n\npublic void max(Tree root)\n{\n while(root != null)\n {\n  root = root.right();\n }\n System.out.println(root.data());\n}\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Two graphs are isomorphic if there exists a one-to-one correspondence between their vertex sets that preserves edge connectivity. If their incidence matrices (vertex-edge representation) are structurally the same under some permutation, they are isomorphic.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The graphs G1 and G2 with their incidence matrices given are isomorphic.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Red-Black trees and AVL trees are both self-balancing binary search trees. Red-Black trees are less rigidly balanced but require fewer rotations. AVL trees store balance factors in each node, which can increase space and time complexity for updates.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Why prefer red-black trees over AVL trees?\na) Because red-black is more rigidly balanced\nb) AVL tree stores balance factor in every node which costs space\nc) AVL tree fails at scale\nd) Red-black is more efficient\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: If the weights of all edges in a graph are multiplied by a positive constant, the relative order of path weights remains the same. Therefore, the shortest path remains unchanged; only the total cost scales accordingly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is the following statement valid about shortest paths? Given a graph, suppose we have calculated shortest path from a source to all other vertices. If we modify the graph such that weights of all edges become double the original weight, then the shortest path remains same, only the total weight of path changes.\nChoices: ['A\\nTrue', 'B\\nFalse']\n\nAnswer: A\nTrue"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A graph can be drawn in many ways, with different visual representations based on layout, orientation, and position of nodes and edges. However, the structure (connectivity) remains the same. Hence, a graph does not have a unique drawing representation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: All graphs have unique representation on paper.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In the complete graph with 100 vertices and edge weights equal to the absolute difference of vertex indices, the minimum spanning tree (MST) can be formed by connecting consecutive nodes: (v1, v2), (v2, v3), ..., (v99, v100). The sum of these 99 edges is the weight of the MST.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a graph G = (V, E), where V = {v1, v2, ..., v100}, E = {(vi, vj) | 1 ≤ i < j ≤ 100} and the weight of edge (vi, vj) is |i − j|. The weight of the minimum spanning tree of G is ________.\nChoices: ['A\\n99', 'B\\n100', 'C\\n98', 'D\\n101']\n\nAnswer: A\n99"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: A hash table is a data structure that allows efficient insertion, deletion, and search of data. It maps keys to values using a hash function and is commonly used in associative arrays and databases.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following operations are done in a hash table?\na) Insert only\nb) Search only\nc) Insert and search\nd) Replace\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Auxiliary space refers to extra space or temporary space used by an algorithm. In the given code, a temporary array of size `d` is used to rotate the elements, so the auxiliary space complexity is O(d).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the auxiliary space complexity of the following code?\n\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int arr[] = {1,2,3,4,5,6};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int d = 4;\n    int temp[10];\n\n    for (int i = 0; i < d; i++)\n        temp[i] = arr[i];\n\n    int j = 0;\n    for (int i = d; i < n; i++, j++)\n        arr[j] = arr[i];\n\n    int k = 0;\n    for (int i = n - d; i < n; i++, k++)\n        arr[i] = temp[k];\n\n    for (int i = 0; i < n; i++)\n        cout << arr[i] << \" \";\n    return 0;\n}\n\na) O(1)\nb) O(n)\nc) O(d)\nd) O(n*d)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In Java, the `BitSet` class from the `java.util` package can be used to represent a bit array, where individual bits can be set, cleared, and queried efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which class in Java can be used to represent bit array?\na) BitSet\nb) BitVector\nc) BitArray\nd) BitStream\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In formal language theory, each parse tree corresponds to a leftmost and a rightmost derivation. Therefore, the number of parse trees equals the number of leftmost and rightmost derivation trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is correct with respect to a parse tree for a given grammar?\na) n parse tree = n leftmost derivation tree = n rightmost derivation tree\nb) n parse tree = n leftmost derivation tree\nc) n parse tree = n rightmost derivation tree\nd) n parse tree = n non-terminals\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A d-heap is a generalization of a binary heap where each node can have d children. Operations like insert, delete, and create can be performed efficiently. However, finding an arbitrary element (not the min/max) is not directly supported.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which operation cannot be directly performed in a d-heap?\na) insert\nb) delete\nc) find\nd) create\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Easy\nContext: A palindrome is a string that reads the same backward as forward. Examples include “madam” and “racecar”. This property can be checked by comparing the string with its reversed version.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a palindromic string?\nChoices: ['A\\nThe string of length 0', 'B\\nThe string having a special character.', 'C\\nThe string having an uppercase letter', 'D\\nThe string whose reversed string is equal to the original string.']\n\nAnswer: D\nThe string whose reversed string is equal to the original string."
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A triply linked list is a variation of a linked list where each node contains three pointers—previous, next, and top. Proper initialization of these pointers and head/tail references is crucial for maintaining structure during insertion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following algorithm to insert an element in a triply linked list.\n\ninitializing previous, next and top pointers to null\npointing the head and tail to the node created\npointing previous, next and top pointers to the node created\ninitializing the head and tail to null\ninitializing previous, next and top pointers to null\ninitializing the head and tail to null\npointing previous, next and top pointers to the node\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Dijkstra and Bellman-Ford algorithms both compute the shortest path in weighted graphs with positive weights. Although the actual path may differ, the total weight of the shortest path from a source to a destination remains the same.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is the following statement valid?\nGiven a graph where all edges have positive weights, the shortest paths produced by Dijkstra and Bellman-Ford algorithms may be different, but the path weight would always be the same.\nChoices: ['A\\nTrue', 'B\\nFalse']\n\nAnswer: A\nTrue"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In a doubly linked list, each node has two pointers—`prev` and `next`. When inserting a node, four pointers are typically updated: the new node’s two pointers and one each from its neighboring nodes. Thus, the number of affected pointers is 4.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a doubly linked list, the number of pointers affected for an insertion operation will be:\nChoices: ['A\\n5', 'B\\n0', 'C\\n1', 'D\\nNone of these']\n\nAnswer: D\nNone of these"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The provided code inserts a new node at the end of a singly linked list by traversing from the head to the last node and updating the last node’s `next` pointer to point to the new node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the following code?\n\npublic void function(Node node)\n{\n if(size == 0)\n  head = node;\n else\n {\n  Node temp, cur;\n  for(cur = head; (temp = cur.getNext()) != null; cur = temp);\n  cur.setNext(node);\n }\n size++;\n}\n\na) Inserting a node at the beginning of the list\nb) Deleting a node at the beginning of the list\nc) Inserting a node at the end of the list\nd) Deleting a node at the end of the list\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Splay trees are a type of self-adjusting binary search tree where recently accessed elements are moved to the root. This provides better performance for sequences of non-uniform access and simplifies implementation compared to more strictly balanced trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Why prefer splay trees?\na) Easier to program\nb) Space efficiency\nc) Easier to program and faster access to recently accessed items\nd) Quick searching\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a K-ary tree, the height is defined as the number of edges from the root to the deepest leaf. If the tree has only the root node, the height is 0 since there are no edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the height of a K-ary tree having only a root node?\na) 1\nb) 0\nc) 2\nd) 3\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Transposing a matrix involves swapping elements across its diagonal, i.e., converting row elements to column elements and vice versa. The given code snippet does this by swapping A[i][j] with A[j][i] for all i < j.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let A be a matrix of size n x n. Consider the following program. What is the expected output?\n\nvoid fun(int A[][N])\n{\n    for (int i = 0; i < N; i++)\n        for (int j = i + 1; j < N; j++)\n            swap(A[i][j], A[j][i]);\n}\n\nChoices: ['A\\nMatrix A', 'B\\nDiagonal of matrix A', 'C\\nTranspose of matrix A', 'D\\nNone']\n\nAnswer: C\nTranspose of matrix A"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used in digital signature systems, not to encrypt or decrypt the signature directly, but to generate a fixed-size hash of the message that is encrypted with a private key. This allows verification using the corresponding public key.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Hashing can be used to encrypt and decrypt digital signatures.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In expressions, operator precedence and associativity determine the order of evaluation. Operators like ^ (exponentiation) have higher precedence than *, +, and -; associativity determines how operators of the same precedence are grouped. Postfix conversion uses this to generate correct operator placement.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Assume that the operators +, -, × are left associative and ^ is right associative. The order of precedence (from highest to lowest) is ^, ×, +, -. The postfix expression for the infix expression a + b × c – d ^ e ^ f is?\na) a b c × + d e f ^ ^ –\nb) a b c × + d e ^ f ^ –\nc) a b + c × d – e ^ f ^\nd) – + a × b c ^ ^ d e f\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a B-tree, the number of disk accesses required for a search operation depends on the height of the tree. The height h is logarithmic in the number of keys n with respect to the minimum degree t, giving a complexity of Θ(logₜ n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of disk page accesses in a B-tree search, where h is height, n is the number of keys, and t is the minimum degree, is:\nChoices: ['A\\nΘ(logn h * t)', 'B\\nΘ(logt n * h)', 'C\\nΘ(logh n)', 'D\\nΘ(logt n)']\n\nAnswer: D\nΘ(logt n)"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Linked lists are ideal for dynamic memory usage and efficient insertions or deletions. However, they are not well-suited for binary search since binary search relies on random access, which linked lists do not support.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Linked lists are not suitable for the implementation of ___________\na) Insertion sort\nb) Radix sort\nc) Polynomial manipulation\nd) Binary search\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: An AA-tree is a form of balanced binary search tree that simulates red-black tree behavior by using levels instead of colors. Recursive coding is a programming preference, not a structural rule of AA-trees, which is why that option is incorrect.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Of the following rules that are followed by an AA-tree, which of the following is incorrect?\n1- Only right children can be red\n2- Procedures are coded recursively\n3- Instead of storing colors, the level of a node is stored\n4- There should not be any left children\n\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In a binary min-heap, the parent node must always be less than or equal to its child nodes. If a line in the construction violates this heap property (e.g., a parent is greater than a child), that line is considered incorrect.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For construction of a binary heap with the property that the parent node has value less than child node, which line is incorrect? (Lines indexed from 1)\na) Line – 3\nb) Line – 5\nc) Line – 6\nd) Line – 7\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: A treap is a binary search tree (based on keys) that also maintains heap property based on priority. The root node always has the highest priority because it must be greater than its children with respect to heap ordering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which node has the lowest priority in a treap?\na) Root node\nb) Leaf node\nc) Null node\nd) Centre node\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Operator precedence determines the order in which operators are evaluated in expressions. Among the given options, the bitwise NOT '~' and XOR '^' have higher precedence than arithmetic operators like '+' and '*'.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of these operators have the highest order of precedence?\na) ‘(‘ and ‘)’\nb) ‘*’ and ‘/’\nc) ‘~’ and ‘^’\nd) ‘+’ and ‘-‘\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A suffix array is a sorted array of all suffixes of a string. If constructed using comparison-based sorting algorithms like merge sort, it will take O(n² log n) time due to repeated comparisons of strings of length up to n.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If a comparison-based sorting algorithm is used to construct the suffix array, what will be the time required to construct the suffix array?\na) O(n log n)\nb) O(n²)\nc) O(n² log n)\nd) O(n²) + O(log n)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: When simulating a stack using a priority queue, to ensure LIFO behavior, elements inserted later must have higher priority. This is achieved by assigning strictly decreasing keys to newer elements so that they are removed first using DELETEMIN.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A priority queue Q is used to implement a stack S that stores characters. PUSH(C) is implemented as INSERT(Q, C, K), where K is an integer key chosen by the implementation. POP is implemented as DELETEMIN(Q). For a sequence of operations, the keys chosen are in:\nChoices: ['A\\nNon-increasing order', 'B\\nNon-decreasing order', 'C\\nStrictly increasing order', 'D\\nStrictly decreasing order']\n\nAnswer: D\nStrictly decreasing order"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: In a linked list-based stack implementation, the pop operation removes the top element by accessing the first node and moving the reference to the next node. This maintains correct LIFO behavior and avoids skipping nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given below is the Node class to perform basic list operations and a Stack class with a no-arg constructor.\nSelect from the options the appropriate pop() operation that can be included in the Stack class. Also, ‘first’ is the top-of-the-stack.\n\n<Multiple pop() implementations provided>\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A 2-d tree (or kd-tree in 2 dimensions) is an extension of a binary search tree where each level alternates the key used for comparison (e.g., x and y coordinates). Insertion follows similar logic as a binary search tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Insertion into a 2-d tree is a trivial extension of insertion into a binary search tree.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Prefix expressions (also known as Polish notation) are evaluated from right to left. The expression +-9 2 7 is interpreted as: subtract 2 from 7, then add -9 to the result: -9 + (2 - 7) = -9 + (-5) = -14.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Using the evaluation of prefix algorithm, evaluate +-9 2 7.\na) 10\nb) 4\nc) 17\nd) 14\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Linked lists differ from arrays in that they allow dynamic resizing and efficient insertions/deletions, but they lack random access. Arrays, on the other hand, offer better cache performance and allow direct element access by index.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following points is/are true about Linked List data structure when it is compared with array?\nChoices: ['A\\nArrays have better cache locality that can make them better in terms of performance.', 'B\\nIt is easy to insert and delete elements in Linked List', 'C\\nRandom access is not allowed in a typical implementation of Linked Lists', 'D\\nThe size of array has to be pre-decided, linked lists can change their size any time.', 'E\\nAll of the above']\n\nAnswer: E\nAll of the above"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In binomial heaps or Fibonacci heaps, merging two trees of order k results in a single tree of order k+1, which has a height increased by one due to the new root-child relationship.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the order of the resultant heap after merging two trees of order k?\na) 2*k\nb) k+1\nc) k*k\nd) k+logk\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: A hash function satisfies the simple uniform hashing condition if each key is equally likely to be hashed to any of the slots. The function h(k) = floor(km), where m is a constant and 0 < m < 1, is an example that attempts to spread keys uniformly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which hash function satisfies the condition of simple uniform hashing?\na) h(k) = lowerbound(km)\nb) h(k) = upperbound(mk)\nc) h(k) = lowerbound(k)\nd) h(k) = upperbound(k)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: When parsing expressions using a stack to match brackets or parentheses, failure to find a matching closing or opening bracket indicates an imbalance, which is treated as an error in the parser or compiler.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When the corresponding end bracket/braces/parentheses is not found, what happens?\na) The stack is popped\nb) Ignore the parentheses\nc) An error is reported\nd) It is treated as an exception\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: A good hashing function distributes keys uniformly across the hash table, avoiding clustering caused by predictable patterns. Therefore, a good hash should be independent of any patterns in the data.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A good hash approach is to derive the hash value that is expected to be dependent on any patterns that might exist in the data.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The provided C++ code reverses the first `k` elements in an array if `k <= n`. It swaps the values symmetrically within the first `k` elements. For the input {1, 2, 3, 4, 5} and k = 3, it produces {3, 2, 1, 4, 5}.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following code?\n\n#include <bits/stdc++.h> \nusing namespace std; \nvoid func(int a[], int n, int k) \n{ \n if (k <= n) \n { \n  for (int i = 0; i < k/2; i++) \n  swap(a[i], a[k-i-1]); \n } \n} \nint main() \n{ \n int a[] = {1, 2, 3, 4, 5}; \n int n = sizeof(a) / sizeof(int), k = 3; \n func(a, n, k); \n for (int i = 0; i < n; ++i) \n  cout << a[i]<<\" \";\n return 0; \n}\n\na) 3 2 1 4 5\nb) 5 4 3 2 1\nc) 1 2 5 4 3\nd) error\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: An AVL tree is a self-balancing binary search tree where the height is logarithmic in the number of nodes. The maximum height for `p` nodes is O(log p), ensuring fast search, insertion, and deletion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum height of an AVL tree with p nodes?\na) p\nb) log(p)\nc) log(p)/2\nd) p⁄2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In a normal array, all elements including nulls are counted in the size. In contrast, a sparse array efficiently stores only non-null or non-zero elements. So, the size is 6 in the normal case and 2 in the sparse representation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose the contents of an array A are, A = {1, null, null, null, null, 10};\nWhat would be the size of the array considering it as a normal array and a sparse array?\na) 6 and 6\nb) 6 and 2\nc) 2 and 6\nd) 2 and 2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In an undirected graph, an adjacency list uses O(V + E) space, where V is the number of vertices and E is the number of edges. This is more space-efficient than adjacency matrices for sparse graphs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Space complexity for an adjacency list of an undirected graph having large values of V (vertices) and E (edges) is ___________\na) O(E)\nb) O(V*V)\nc) O(E + V)\nd) O(V)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: To check if an expression has balanced parentheses, a stack is used. Each time an opening symbol is encountered, it is pushed to the stack. A closing symbol pops the top element. If the stack is empty at the end, the expression is balanced.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The data structure required to check whether an expression contains a balanced parenthesis is?\na) Queue\nb) Stack\nc) Tree\nd) Array\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A heap is a complete binary tree that satisfies the heap property. In a max-heap, the parent node is greater than or equal to its children. In a min-heap, the parent is less than or equal to its children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Heap exhibits the property of a binary tree?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix (or Reverse Polish Notation) expressions do not require parentheses and can be evaluated from left to right using a stack, making them easier and faster for computers to process than infix expressions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: It is easier for a computer to process a postfix expression than an infix expression.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A XOR linked list is a memory-efficient version of a doubly linked list where each node stores the XOR of the memory addresses of the previous and next nodes. This allows traversal in both directions using XOR operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does a XOR linked list have?\na) Every node stores the XOR of addresses of previous and next nodes\nb) Actual memory address of the next node\nc) Every node stores the XOR of addresses of previous and next two nodes\nd) Every node stores XOR of 0 and the current node address\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In circular linked lists, inserting a node at the head requires updating the new node's next pointer and reconnecting the last node to the new head. The correct implementation ensures circular linkage and pointer updates.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Choose the code snippet which inserts a node to the head of the list?\n<Multiple insertHead() function implementations provided>\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In binary tree rotations, a right rotation repositions nodes to maintain balance. The given pseudocode updates pointers to rotate a node to the right, making its left child the new root of the subtree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What output does the below pseudo code produce?\n\nTree_node function(Tree_node x)\n{\n    Tree_node y = x.left;\n    x.left = y.right;\n    y.right = x;\n    return y;\n}\n\na) Right rotation of subtree\nb) Left rotation of subtree\nc) Zig-zag operation\nd) Zig-zig operation\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Prefix notation (Polish notation) places the operator before its operands. For the expression a | b & c, the AND operation is evaluated first, followed by OR, resulting in | a & b c → |a&bc.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the Prefix notation for the given equation?\na) a|&bc\nb) &|abc\nc) |a&bc\nd) ab&|c\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: When performing XOR on pointers (such as in XOR linked lists), proper type casting is required to ensure memory addresses are manipulated correctly. Missing a cast results in type mismatch errors.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What’s wrong with this code which returns XOR of two node addresses?\na) Nothing wrong. Everything is fine\nb) Type casting at return is missing\nc) Parameters are wrong\nd) Total logic is wrong\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The van Emde Boas (vEB) tree is a tree-based data structure that supports fast predecessor/successor queries. It was invented by Peter van Emde Boas.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Who invented the vEB tree, also known as the van Emde Boas Tree?\na) Peter Van Emde Boas\nb) Samuel F. B. Morse\nc) Friedrich Clemens Gerke\nd) Alexander Morse\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A weak heap is a variant of the binary heap that is used in the weak heap sort algorithm. It is also known as a relaxed heap due to its weaker structural constraints compared to binary heaps.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the other name of a weak heap?\na) Min-heap\nb) Max-heap\nc) Relaxed-heap\nd) Leonardo heap\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Matrix multiplication satisfies associative and distributive properties but is not commutative. That is, A × B ≠ B × A in general. Therefore, the commutative property does not hold for matrix multiplication.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following property does not hold for matrix multiplication?\na) Associative\nb) Distributive\nc) Commutative\nd) Additive Inverse\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: Common types of queues include ordinary queue (FIFO), circular queue (wrap-around structure), and priority queue (based on priority). A 'single-ended queue' is not a standard type of queue.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not a type of queue?\na) Priority queue\nb) Circular queue\nc) Single-ended queue\nd) Ordinary queue\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In column-major order, the elements of a matrix are stored column by column in memory. For a 3×3 matrix with elements arranged as:\na b c\nd e f\ng h i\nThe order of elements in memory will be: a, d, g, b, e, h, c, f, i → adgbehcfi.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If column-major order is used, how is the following matrix stored in memory?\na b c\nd e f\ng h i\n\na) ihgfedcba\nb) abcdefghi\nc) cfibehadg\nd) adgbehcfi\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A max-heap maintains the property that each parent node is greater than or equal to its children. Inserting 1 and then 7 into a heap that has level-order [10, 8, 5, 3, 2] results in a new structure that reorders to preserve the heap property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A priority queue is implemented as a max-heap. Initially, it has 5 elements. The level-order traversal of the heap is: 10, 8, 5, 3, 2. Two new elements 1 and 7 are inserted into the heap in that order. The level-order traversal of the heap after the insertion of the elements is:\nChoices: ['A\\n10, 8, 7, 3, 2, 1, 5', 'B\\n10, 8, 7, 2, 3, 1, 5', 'C\\n10, 8, 7, 1, 2, 3, 5', 'D\\n10, 8, 7, 5, 3, 2, 1']\n\nAnswer: A\n10, 8, 7, 3, 2, 1, 5"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A descending priority queue gives higher priority to larger elements. It can be efficiently implemented using a max-heap, where the largest element is always at the root and removed first.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A descending priority queue can be implemented using ______\na) Max heap\nb) Min heap\nc) Min-max heap\nd) Trie\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: In double hashing, two hash functions h1(k) and h2(k) are used to calculate probe sequences. A typical implementation is: h1(k) = k mod m, and h2(k) = 1 + (k mod m’), where m and m’ are constants chosen to reduce clustering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the values of h1(k) and h2(k) in the hash function?\na)\n\nh1(k) = m mod k\n    h2(k) = 1 + (m’ mod k)\nb)\n\nh1(k) = 1 + (m mod k)\n    h2(k) = m’ mod k\nc)\n\nh1(k) = 1 + (k mod m)\n    h2(k) = k mod m\nd)\n\nh1(k) = k mod m\n    h2(k) = 1 + (k mod m’)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A max-heap ensures that the maximum element is at the root. To build a max-heap from an array, the heapify procedure swaps elements to restore the heap property. The number of swaps required depends on how far elements are from satisfying the property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The minimum number of interchanges needed to convert the array 89, 19, 40, 17, 12, 10, 2, 5, 7, 11, 6, 9, 70 into a heap with the maximum element at the root is:\nChoices: ['A\\n0', 'B\\n1', 'C\\n2', 'D\\n3']\n\nAnswer: C\n2"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Easy\nContext: Direct addressing is a technique where data is stored at an index equal to its key. Since it allows direct access without traversal, the search time complexity is O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the search complexity in direct addressing?\na) O(n)\nb) O(log n)\nc) O(n log n)\nd) O(1)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In postfix (Reverse Polish) notation, operators follow their operands. For infix expressions like (A + B) * (C * D − E) * F / G, proper conversion uses operator precedence and associativity rules to generate the postfix form.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The postfix form of the expression (A + B) * (C * D − E) * F / G is:\nChoices: ['A\\nAB+ CD*E − FG /**', 'B\\nAB + CD* E − F **G /', 'C\\nAB + CD* E − *F *G /', 'D\\nAB + CDE * − * F *G /']\n\nAnswer: A\nAB+ CD*E − FG /**"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing with open addressing, the probe sequence determines which slots to inspect. The sequence often depends on the key (k) and constants (e.g., in quadratic probing), but ultimately the key determines the pattern of probing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: On what value does the probe sequence depend?\na) c1\nb) k\nc) c2\nd) m\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a min-heap, the minimum element is always at the root, so FindMin() takes O(1) time. Deleting the minimum involves replacing the root with the last element and re-heapifying, which takes O(log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The procedure FindMin() to find the minimum element and the procedure DeleteMin() to delete the minimum element in a min-heap take _________\na) Logarithmic and linear time respectively\nb) Constant and linear time respectively\nc) Constant and quadratic time respectively\nd) Constant and logarithmic time respectively\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In C, dynamic memory allocation is performed using `malloc()`. When creating a new node for a linked list, the correct syntax involves using `sizeof(NODE)` and casting the return value to a pointer of the appropriate type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following definition in C programming language:\n\nstruct node\n{\n    int data;\n    struct node * next;\n};\ntypedef struct node NODE;\nNODE *ptr;\n\nWhich of the following C code is used to create a new node?\na) ptr = (NODE*)malloc(sizeof(NODE));\nb) ptr = (NODE*)malloc(NODE);\nc) ptr = (NODE*)malloc(sizeof(NODE*));\nd) ptr = (NODE)malloc(sizeof(NODE));\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: If only push and pop operations are allowed, simulating an enqueue operation in an array-based queue (via two stacks) involves moving elements from one stack to another and back. Each move takes time, and multiple moves are required to insert an element.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: You are on a planet where computational power is slow. You have an array of size 10. You want to enqueue an element using only push and pop operations (each takes 1 second). What is the total time required to perform the enqueue operation?\na) 20\nb) 40\nc) 42\nd) 43\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are fixed-size data structures. One of their main disadvantages is that memory may be wasted if the number of inserted elements is significantly smaller than the allocated size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the disadvantages of arrays?\na) Data structures like queue or stack cannot be implemented\nb) There are chances of wastage of memory space if elements inserted in an array are fewer than the allocated size\nc) Index value of an array can be negative\nd) Elements are sequentially accessed\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Based on the birthday paradox, in a hash table of size 20, inserting 10 keys leads to a collision probability exceeding 0.5. This concept illustrates how quickly collisions can occur even in modestly filled hash tables.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a hash function that distributes keys uniformly. The hash table size is 20. After hashing how many keys will the probability that any new key collides with an existing one exceed 0.5?\nChoices: ['A\\n5', 'B\\n6', 'C\\n7', 'D\\n10']\n\nAnswer: D\n10"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: The minimum number of jumps to reach the end of an array depends on the value at each index. If certain sections are blocked by 0 and no forward path exists, it's impossible to reach the end.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the minimum number of jumps required to reach the end of the array arr[] = {1,2,0,0,3,6,8,5}?\na) 1\nb) 2\nc) 3\nd) Not possible to reach the end\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A top tree is a type of data structure used in dynamic trees. If a tree has only a single vertex, there are no edges to break or cluster, hence no valid top trees can be formed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many top trees are there in a tree with a single vertex?\na) 0\nb) 1\nc) 2\nd) 3\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: The provided code is an implementation of the Floyd-Warshall algorithm, which computes the shortest paths between all pairs of vertices in a weighted graph. The algorithm updates a distance matrix based on the transitive property of shortest paths.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the value of the distance matrix after the execution of the given code?\n\n#include <bits/stdc++.h>\n#define INF 1000000\nint graph[V][V] = { {0, 7, INF, 4},\n                    {INF, 0, 13, INF},\n                    {INF, INF, 0, 12},\n                    {INF, INF, INF, 0} };\n \nint distance[V][V], i, j, k;\n \nfor (i = 0; i < V; i++)\n    for (j = 0; j < V; j++)\n        distance[i][j] = graph[i][j];\n \nfor (k = 0; k < V; k++)\n    for (i = 0; i < V; i++)\n        for (j = 0; j < V; j++)\n            if (distance[i][k] + distance[k][j] < distance[i][j])\n                distance[i][j] = distance[i][k] + distance[k][j];\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a binary heap, the number of nodes at height h in an n-element heap can be calculated using the formula ceil(n / 2^(h+1)). This is derived from the complete binary tree structure of the heap.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of nodes of height h in any n-element heap is __________.\nChoices: ['A\\nh', 'B\\n2h', 'C\\nceil(n/2h)', 'D\\nceil(n/2^(h+1))']\n\nAnswer: D\nceil(n/2^(h+1))"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A Directed Acyclic Word Graph (DAWG) is a data structure used in string algorithms. It is particularly useful in applications like pattern recognition and string matching due to its compact representation of substrings.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In which of the following does a Directed Acyclic Word Graph find its application?\na) String Matching\nb) Number Sorting\nc) Manipulations on numbers\nd) Pattern Printing\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A triply linked list extends a doubly linked list by including a third pointer. This extra pointer, often named `top`, can be used for specialized navigational or hierarchical operations, and it is typically positioned logically as an additional link from the node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Where does a triply linked list contain an extra pointer in comparison to a doubly linked list?\na) Top of the node\nb) Bottom of the node\nc) Before the node\nd) After the node\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In tree terminology, the height of a node is defined as the number of edges on the longest path from the node to a leaf. The height of a root node in any tree (including ternary trees) is 0 if the node has no children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the height of the root node of a ternary tree?\na) 1\nb) 2\nc) 3\nd) 0\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: MinHash is a probabilistic technique for efficiently estimating the similarity between datasets. It is commonly used in applications like association rule learning, document similarity, and clustering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is MinHash used as a tool for association rule learning?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Tree traversals define the order in which nodes are visited. Level-order traversal, also known as breadth-first traversal, visits nodes level by level from left to right, typically implemented using a queue.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which traversal's pseudo code is written here?\nChoices: ['A\\nLevel order', 'B\\nPre-order', 'C\\nPost-order', 'D\\nIn-order']\n\nAnswer: A\nLevel order"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Auxiliary trees are temporary or helper trees used during tree operations. The 'join' operation combines two auxiliary trees into one while preserving the properties of the tree structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which operation is used to combine two auxiliary trees?\na) Join\nb) Combinatorial\nc) Add\nd) Concatenation\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where each element (node) points to the next node using a pointer. This allows dynamic memory allocation and flexible insertion/deletion operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A linear collection of data elements where the linear node is given by means of a pointer is called ________.\nChoices: ['A\\nLinked list', 'B\\nNode list', 'C\\nPrimitive list', 'D\\nNone of these']\n\nAnswer: A\nLinked list"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Free lists manage available memory blocks. Allocation strategies like best fit, first fit, and worst fit differ in how memory is chosen. Among these, first fit is generally considered the simplest to implement.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are different ways of implementing free lists and which is simple among them?\na) best fit, first fit, worst fit, simple-first fit\nb) best fit, first fit, worst fit, simple-best fit\nc) best fit, first fit, worst fit, simple-worst fit\nd) best fit simple-best fit\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: When two stacks share a single array growing from opposite ends, the condition for stack overflow occurs when their tops are about to collide. That is, when top1 == top2 - 1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A single array A[1..MAXSIZE] is used to implement two stacks growing from opposite ends. If top1 and top2 point to the top elements of each stack and top1 < top2, what is the condition for “stack full”?\nChoices: ['A\\n(top1 = MAXSIZE/2) and (top2 = MAXSIZE/2+1)', 'B\\ntop1 + top2 + 1 = MAXSIZE', 'C\\n(top1 = MAXSIZE/2) or (top2 = MAXSIZE)', 'D\\ntop1 = top2 - 1']\n\nAnswer: D\ntop1 = top2 - 1"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A binary tree is a hierarchical structure in which each node can have at most two children—commonly referred to as the left and right child. This is a defining property of binary trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum number of children that a binary tree node can have?\na) 0\nb) 1\nc) 2\nd) 3\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: Fibonacci heaps offer better amortized time complexity for decrease-key and delete operations than other heap types. Although more complex to implement, they are theoretically faster in certain scenarios, such as Dijkstra's algorithm with many decrease-key operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Out of the following given options, which is the fastest algorithm?\na) Fibonacci heap\nb) Pairing heap\nc) d-ary heap\nd) Binary heap\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: An expression tree is a type of binary tree used to represent expressions. Operands are stored in leaves, and operators are stored in internal nodes. The structure obeys the binary tree property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An expression tree is a kind of?\na) Binary search tree\nb) Fibonacci tree\nc) Binary tree\nd) Treap\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In C++, the `delete` operator releases memory allocated by `new`, but it doesn't delete the pointer itself. After the delete operation, the pointer still exists and should be set to `nullptr` to avoid dangling pointer issues.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given that the line `delete newPtr;` just executed, what can you conclude?\nChoices: ['A\\nThe memory referenced by newPtr is released only if it is needed by the system.', 'B\\nThe pointer newPtr is of type void *.', 'C\\nThe pointer newPtr only exists if there was an error freeing the memory.', 'D\\nThe pointer newPtr still exists.']\n\nAnswer: D\nThe pointer newPtr still exists."
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack can be implemented using two queues. One queue is used to store the elements and the second helps simulate the Last-In-First-Out (LIFO) behavior by rearranging the elements during pop or push operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: To implement a stack using queues (with only enqueue and dequeue operations), how many queues will you need?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: To convert a postfix expression to prefix, reverse the postfix, swap operators/operands accordingly, and apply precedence rules. For AB+CD-* the prefix form is *+AB-CD.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The prefix expression of the postfix expression AB+CD-* is __________\na) (A+B)*(C-D)\nb) +AB*-CD\nc) A+*BCD-\nd) *+AB-CD\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Balancing symbols such as parentheses, braces, or brackets is a common problem in compilers and expression parsing. A stack is the ideal data structure for this task due to its LIFO behavior, allowing correct matching of opening and closing symbols.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which is the most appropriate data structure for applying the balancing of symbols algorithm?\na) Stack\nb) Queue\nc) Tree\nd) Graph\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A bipartite graph with `n` vertices can have at most ⌊n²/4⌋ edges. This maximum is achieved when the vertex set is divided equally into two parts. For 10 vertices, the maximum is (5 × 5) = 25 edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum number of edges in a bipartite graph having 10 vertices?\na) 24\nb) 21\nc) 25\nd) 16\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A suffix array is a sorted array of all suffixes of a string. Compared to suffix trees, suffix arrays are more space efficient as they use linear space and simpler structures, making them preferable for large-scale string processing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suffix array is space efficient compared to the suffix tree.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A graph is bipartite if its vertices can be divided into two disjoint sets such that no edge connects vertices within the same set. While all paths are bipartite, not all cyclic graphs are—especially those with an odd number of vertices in the cycle.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: All paths and cyclic graphs are bipartite graphs.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Dynamic arrays grow and shrink automatically based on their usage. To avoid wasting space, if the size of the array drops below a certain threshold (commonly 30% of the allocated size), the array is deallocated or shrunk.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The size of the dynamic array is deallocated if the array size is less than _________% of the backend physical size.\na) 30\nb) 40\nc) 10\nd) 20\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a binomial heap, the decrease-key operation adjusts the value of a node and may require restructuring the heap to maintain the heap property. This process takes O(log n) time because the heap is organized as a collection of binomial trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Time taken in decreasing the node value in a binomial heap is:\na) O(n)\nb) O(1)\nc) O(log n)\nd) O(n log n)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The evaluation of prefix expressions (Polish notation) is guided by operator precedence and associativity. This determines the correct order in which operands and operators are processed during computation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What determines the order of evaluation of a prefix expression?\na) Precedence and associativity\nb) Precedence only\nc) Associativity only\nd) Depends on the parser\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Converting an infix expression to postfix (Reverse Polish Notation) involves using a stack to manage operators based on their precedence and associativity, ensuring correct evaluation order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: One can convert an infix expression to a postfix expression using a ________.\nChoices: ['A\\nStack', 'B\\nQueue', 'C\\nDeque', 'D\\nNone of these']\n\nAnswer: A\nStack"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Linear probing is a collision resolution technique in hashing. It is widely used in applications such as database indexing, cache management, and compiler symbol tables where fast lookups and space efficiency are needed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the applications of linear probing?\nChoices: ['A\\nDatabases', 'B\\nCaching', 'C\\nCompiler Design', 'D\\nAll of the above']\n\nAnswer: D\nAll of the above"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A complete binary tree of depth `d` has (2^d - 1) nodes and (2^{d+1} - 1) pointers in total. The number of unused (null) pointers corresponds to the number of leaves, which in a complete tree is (2^d). For depth 5, that is 32 leaves, each having 2 null children pointers, so 16 unused pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of unused pointers in a complete binary tree of depth 5 is:\nChoices: ['A\\n4', 'B\\n8', 'C\\n16', 'D\\n32']\n\nAnswer: C\n16"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack follows the Last-In-First-Out (LIFO) principle, where the last item added is the first to be removed. A real-world analogy is a stack of chairs or plates, where the topmost item is accessed first.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following real-world scenarios would you associate with a stack data structure?\na) Piling up of chairs one above the other\nb) People standing in a line to be serviced at a counter\nc) Offer services based on the priority of the customer\nd) Tatkal Ticket Booking in IRCTC\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Universal hashing refers to a class of hash functions that minimize the probability of collision by choosing a function at random from a family of hash functions. It offers better average performance than traditional methods like division or multiplication.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which hashing scheme provides good performance?\na) Open addressing\nb) Universal hashing\nc) Hashing by division\nd) Hashing by multiplication\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix expressions (also called Reverse Polish Notation) are evaluated using a stack. In the expression `ab + cd / -`, substitute values (a=5, b=4, c=9, d=3) → (5+4) - (9/3) = 9 - 3 = 6.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Evaluate the postfix expression ab + cd / - where a=5, b=4, c=9, d=3.\na) 23\nb) 15\nc) 6\nd) 10\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: This question seems to reference a scenario with a queue modified by a parameter `k`, but no operation is specified. However, assuming it refers to a special queue operation (like priority or limited position enqueue), a choice can still be evaluated based on custom logic provided with `k`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following operation along with Enqueue and Dequeue operations on queues, where k is a global parameter.\nChoices: ['A\\nA', 'B\\nB', 'C\\nC', 'D\\nD']\n\nAnswer: A"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Prefix expressions (Polish Notation) place operators before their operands. The expression `++a*bc*+defg` has this format, making it a prefix expression.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: ++a*bc*+defg is a?\na) Postfix expression\nb) Infix expression\nc) Prefix expression\nd) Invalid expression\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Deleting a linked list involves traversing it and deallocating memory for each node. This can be done in-place without needing additional memory, making the space complexity O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the space complexity for deleting a linked list?\na) O(1)\nb) O(n)\nc) Either O(1) or O(n)\nd) O(log n)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In nearest neighbor search using kd-trees, three primary concepts are crucial: (1) pruning using bounding boxes, (2) recursive traversal, and (3) backtracking to search the opposite subtree if necessary. These techniques optimize search in multidimensional spaces.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many prime concepts are available in nearest neighbor search in a kd tree?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a 2-dimensional kd-tree, the root node is typically chosen based on the value of the first dimension. Often, to break ties or for simplicity, the first node inserted (or an arbitrary odd-positioned node) is used as the root.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a two-dimensional search tree, the root is arbitrarily chosen to be?\na) Even\nb) Odd\nc) Depends on subtrees\nd) 1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Linked lists support dynamic memory usage and allow insertions and deletions at any position. This is a major advantage over arrays, which require shifting elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In general, linked lists allow:\nChoices: ['A\\nInsertions and removals anywhere.', 'B\\nInsertions and removals only at one end.', 'C\\nInsertions at the back and removals from the front.', 'D\\nNone of the above.']\n\nAnswer: A\nInsertions and removals anywhere."
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a binary min-heap, the maximum element resides in the leaf nodes. For a complete binary tree with 1023 elements, 512 nodes are leaves. Finding the maximum among them requires 511 comparisons.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the array representation of a binary min-heap containing 1023 elements. The minimum number of comparisons required to find the maximum in the heap is:\nChoices: ['A\\n510', 'B\\n511', 'C\\n512', 'D\\n255']\n\nAnswer: B\n511"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In disjoint set union (union-find), rank is used to limit the depth of trees. A node with rank r must have at least 2^r descendants. This ensures logarithmic time performance with union by rank.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When executing a sequence of Unions, a node of rank r must have at least 2^r descendants.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Converting infix to prefix notation requires applying operator precedence and associativity in reverse. Given a complex expression, proper reordering of operators and operands produces the correct prefix (Polish) notation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the Prefix notation for the given equation?\na) -+a*/^bcdef\nb) -+a*/bc^def\nc) -+a*b/c^def\nd) -a+*/bc^def\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In an undirected simple graph with (n) vertices, each pair of distinct vertices can have at most one edge, resulting in (n(n-1)/2) edges. In a directed graph, each pair can have two directed edges (one in each direction), leading to (n(n-1)) possible non-zero entries in the adjacency matrix.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum number of possible non-zero values in an adjacency matrix of a simple graph with n vertices?\na) (n*(n-1))/2\nb) (n*(n+1))/2\nc) n*(n-1)\nd) n*(n+1)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: To convert a binary tree into its mirror image, you recursively swap the left and right subtrees. This is typically performed during a pre-order traversal, where the current node is processed before its children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A binary tree can be converted into its mirror image by traversing it in ________.\nChoices: ['A\\nIn-order', 'B\\nPre-order', 'C\\nPost-order', 'D\\nAny order']\n\nAnswer: B\nPre-order"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Level-order traversal is a breadth-first traversal of a tree. It visits nodes level by level and is implemented using a queue to process nodes in FIFO order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Level order traversal of a tree is formed with the help of:\na) Breadth-first search\nb) Depth-first search\nc) Dijkstra’s algorithm\nd) Prim’s algorithm\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Parallel arrays store related data across multiple arrays using a shared index. While useful in languages that don’t support records, they can be inefficient for insertion and deletion due to the need to maintain synchronization across arrays.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a disadvantage of parallel arrays over traditional arrays?\na) When a language does not support records, parallel arrays can be used\nb) Increased locality of reference\nc) Ideal cache behaviour\nd) Insertion and deletion becomes tedious\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The height of a tree node is the number of edges on the longest path to a leaf. In a K-ary tree, the height of the root depends on the total number of levels. For some tree definitions, if the tree has multiple levels and the root is at level 0, then its height may be 3.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the height of the root node of a K-ary tree?\na) 1\nb) 2\nc) 3\nd) 0\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: The given recursive function prints the data of a linked list node, then skips the next node (if it exists), and calls itself recursively. After returning from recursion, it prints the same node again. This produces a symmetric output from first, third, fifth, then in reverse.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the output of the following function if start is pointing to the first node of the linked list 1->2->3->4->5->6?\n\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node() { data = 0; next = nullptr; } \n};\n\nvoid fun(Node* start) {\n    if (start == nullptr)\n        return;\n    cout << start->data << \"  \";\n    \n    if (start->next != nullptr)\n        fun(start->next->next);\n    cout << start->data << \"  \";\n}\n\nChoices: ['A\\n1 4 6 6 4 1', 'B\\n1 3 5 1 3 5', 'C\\n1 2 3 5', 'D\\n1 3 5 5 3 1']\n\nAnswer: D\n1 3 5 5 3 1"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Array elements are stored in contiguous memory locations and support random access. This allows any element to be accessed directly using its index in constant time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Elements in an array are accessed _____________\na) randomly\nb) sequentially\nc) exponentially\nd) logarithmically\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a minimum spanning tree (MST), the number of edges is always (V - 1). If the weight of each edge in the graph is increased by a constant, the structure of the MST remains the same, and the total weight increases by (V - 1) × constant.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let G be a connected undirected graph with 100 vertices and 300 edges. The weight of a minimum spanning tree of G is 500. When the weight of each edge of G is increased by five, the weight of a minimum spanning tree becomes ________.\nChoices: ['A\\n1000', 'B\\n995', 'C\\n2000', 'D\\n1995']\n\nAnswer: B\n995"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A leftist heap is a variant of the binary heap that uses a special rule called the null path length (NPL) to ensure balance during merges. It is implemented using a binary tree structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A leftist heap is also said to be a binary heap.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: In bracket matching algorithms, opening brackets are pushed onto the stack. When a closing bracket is encountered, the top of the stack is popped to check for a match. This maintains balanced structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If the corresponding end bracket/braces/parentheses is encountered, which of the following is done?\na) Push it onto the stack\nb) Pop the stack\nc) Throw an error\nd) Treated as an exception\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A suffix tree is a compressed trie of all suffixes of a given string. It is highly useful in text editors and search engines for string matching, substring search, and pattern recognition.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Can a suffix tree be used in string problems occurring in a text editor?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In binary trees, deleting a node while preserving structure involves replacing the node to be deleted with the deepest (rightmost) node and then deleting that deepest node. This avoids violating the binary tree properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The following lines talk about deleting a node in a binary tree (the tree property must not be violated after deletion):\ni) From root, search for the node to be deleted\nii)\niii) Delete the node at\nWhat must be statement ii) and fill up statement iii)?\na) ii) Find random node, replace with node to be deleted. iii) Delete the node\nb) ii) Find node to be deleted. iii) Delete the node at found location\nc) ii) Find deepest node, replace with node to be deleted. iii) Delete a node\nd) ii) Find deepest node, replace with node to be deleted. iii) Delete the deepest node\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Google has evaluated hashing techniques like MinHash and SimHash in large-scale environments. These algorithms are used for estimating similarity between documents and are applied in web indexing and duplicate detection.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Did Google conduct a large evaluation for comparing the performance of two techniques: MinHash and SimHash?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Even if all edge weights in a graph are unique, multiple paths can have different weights, but uniqueness of edge weights does not guarantee that the shortest path between any two nodes is unique.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is the following statement valid?\n\nGiven a weighted graph where weights of all edges are unique, there is always a unique shortest path from a source to destination.\nChoices: ['A\\nTrue', 'B\\nFalse']\n\nAnswer: B\nFalse"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: During the syntax analysis (parsing) phase of a compiler, data structures like linked lists are used to handle tokens and expressions. They allow dynamic handling of nodes without pre-allocation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure is used in the syntax analysis phase of the compiler?\na) Tree\nb) Stack\nc) Linked List\nd) Queue\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: An inversion in an array is a pair of indices (i, j) such that i < j and arr[i] > arr[j]. A sorted array has zero such inversions, indicating it is already ordered.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many inversions does a sorted array have?\na) 0\nb) 1\nc) 2\nd) Cannot be determined\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Converting a decimal number to binary involves dividing the number by 2 repeatedly and storing the remainders in reverse order. Using arrays and loops, this process is implemented by storing remainders and printing the array in reverse.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following code snippets is used to convert decimal to binary numbers?\n<Java code snippets for options a–d>\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Recursion uses a call stack to keep track of function calls. Each recursive call is pushed onto the stack, increasing memory usage. Iteration, in contrast, does not rely on the call stack for execution.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Recursion uses more memory space than iteration because ________.\nChoices: ['A\\nIt uses stack instead of queue.', 'B\\nEvery recursive call has to be stored.', 'C\\nBoth A & B are true.', 'D\\nNone of the above.']\n\nAnswer: B\nEvery recursive call has to be stored."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: An almost complete binary tree of depth 'd' is one where all levels are fully filled except possibly the last, and all leaves appear as far left as possible. It includes both the conditions described in options A and B.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A binary tree of depth “d” is an almost complete binary tree if:\nChoices: ['A\\nEach leaf in the tree is either at level “d” or at level “d−1”', 'B\\nFor any node “n” in the tree with a right descendant at level “d”, all the left descendants of “n” that are leaves, are also at level “d”', 'C\\nBoth (A) & (B)', 'D\\nNone of the above']\n\nAnswer: C\nBoth (A) & (B)"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: Merging two sorted arrays of sizes m and n involves iterating over both arrays once, making comparisons and appending the smaller element. This takes linear time: Θ(m + n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Time required to merge two sorted lists of size m and n is ________.\nChoices: ['A\\nΘ(m | n)', 'B\\nΘ(m + n)', 'C\\nΘ(m log n)', 'D\\nΘ(n log m)']\n\nAnswer: B\nΘ(m + n)"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A connected graph is Eulerian if all its vertices have even degrees. In the given options, only the combination 2, 4, 5 includes at least one vertex with odd degree, making it invalid for Eulerian. However, option a) 1,2,3 is also invalid. This may indicate an error in the expected answer. In general, to be Eulerian, all degrees must be even.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For which of the following combinations of the degrees of vertices would the connected graph be Eulerian?\na) 1, 2, 3\nb) 2, 3, 4\nc) 2, 4, 5\nd) 1, 3, 5\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where each element (node) points to the next using a pointer. This allows dynamic memory allocation and efficient insertions or deletions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A linear collection of data elements where the linear node is given by means of pointer is called?\na) Linked list\nb) Node list\nc) Primitive list\nd) Unordered list\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A complete undirected graph with 4 vertices has 6 edges. To form a minimum spanning tree (MST), we need (V-1) = 3 edges with the smallest weights. Choosing edges with weights 1, 2, and 4 gives the maximum possible MST weight: 7.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let G be a complete undirected graph on 4 vertices, having 6 edges with weights 1, 2, 3, 4, 5, and 6. What is the maximum possible weight that a minimum weight spanning tree of G can have?\nChoices: ['A\\n6', 'B\\n7', 'C\\n8', 'D\\n9']\n\nAnswer: B\n7"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A self-organizing list is a type of linked list that reorders elements based on access patterns to reduce average lookup time. It's used in symbol tables to improve compiler performance during variable/function lookup.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Symbol tables during compilation of a program are efficiently implemented using __________\na) A singly linked list\nb) A doubly linked list\nc) A self-organizing list\nd) An array\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In postfix notation, operators follow operands. When multiple operators have different precedence and associativity, the evaluation order must respect these rules. Operator a has the highest precedence and b, c are right-associative.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the postfix expression 4 5 6 a b 7 8 a c, where a, b, and c are operators. Operator a has higher precedence than b and c. Operators b and c are right associative. What is the equivalent infix expression?\na) 4 a 5 6 b 7 8 a c\nb) 4 a 5 c 6 b 7 a 8\nc) 4 b 5 a 6 c 7 a 8\nd) 4 a 5 b 6 c 7 a 8\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: The given function modifies the `head` pointer passed to it, which may not be desirable if the original head needs to be preserved. A better approach is to use a separate traversal pointer.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following function to traverse a linked list:\n\n// C++ version\nvoid traverse(Node *head) {\n    while (head != NULL) {\n        printf(\"%d  \", head->data);\n        head = head->next;\n    }\n}\n\nChoices: ['A\\nThe function may crash when the linked list is empty', \"B\\nThe function doesn't print the last node when the linked list is not empty\", 'C\\nThe function is implemented incorrectly because it changes head', 'D\\nNone of the above']\n\nAnswer: C\nThe function is implemented incorrectly because it changes head"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: A hash tree, also known as a Merkle tree, is a tree in which every leaf node is a hash of a data block and every non-leaf node is a hash of its children. It’s widely used in blockchain and data verification.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A hash tree is also known as _____\na) Merkle tree\nb) T-tree\nc) Hash table\nd) Bx-tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: The described process constructs a Cartesian tree and uses a priority queue to extract nodes in increasing order of value. This simulates a priority-based traversal of the tree, effectively sorting the input sequence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What happens if we apply the below operations on an input sequence?\ni. Construct a Cartesian tree for input sequence\nii. Put the root element of above tree in a priority queue\niii. If priority queue is not empty then\niv. Search and delete minimum value in priority queue\nv. Add that to output\nvi. Add Cartesian tree children of above node to priority queue\n\na) Constructs a Cartesian tree\nb) Sorts the input sequence\nc) Does nothing\nd) Produces some random output\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A memory-efficient doubly linked list uses XOR linking, where each node contains a single pointer that stores the XOR of addresses of the previous and next nodes. This reduces memory usage by eliminating an extra pointer field.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you calculate the pointer difference in a memory-efficient doubly linked list?\na) head XOR tail\nb) Pointer to previous node XOR pointer to next node\nc) Pointer to previous node – pointer to next node\nd) Pointer to next node – pointer to previous node\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Postfix (Reverse Polish Notation) expressions are evaluated using a stack. When an operator is encountered, the top two operands are popped, the operation is performed, and the result is pushed back onto the stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: While evaluating a postfix expression, when an operator is encountered, what is the correct operation to be performed?\na) Push it directly onto the stack\nb) Pop 2 operands, evaluate them and push the result onto the stack\nc) Pop the entire stack\nd) Ignore the operator\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A weight-balanced tree ensures that the weight (or size) of the left and right subtrees of any node n is at least a certain fraction 'a' of the weight of the node itself. This helps in maintaining balanced access times.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the condition for a tree to be weight balanced, where 'a' is a factor and 'n' is a node?\na) weight[n.left] >= a * weight[n] and weight[n.right] >= a * weight[n]\nb) weight[n.left] >= a * weight[n.right] and weight[n.right] >= a * weight[n]\nc) weight[n.left] >= a * weight[n.left] and weight[n.right] >= a * weight[n]\nd) weight[n] is a non-zero\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are fixed-size data structures. While they allow fast random access, they can suffer from drawbacks such as fixed size and inefficient insertion/deletion. However, accessing elements at specified positions is a major advantage.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not a disadvantage of using arrays?\na) Fixed size\nb) There are chances of wastage of memory space if elements inserted are fewer than allocated size\nc) Insertion based on position\nd) Accessing elements at specified positions\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing, a collision occurs when two different keys hash to the same index in the hash table. This is common and needs to be handled using techniques like chaining or open addressing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Collision is caused due to the presence of two keys having the same value.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A min-heap is a complete binary tree where the value of each parent node is less than or equal to the values of its children. This structure allows efficient access to the minimum element.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Min heap is a complete binary tree.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A treap is a randomized binary search tree that also satisfies the heap property using a priority value assigned randomly to each node. It is also known as a Cartesian tree with priorities.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A treap is a Cartesian tree with ___________\na) Additional value, which is a priority value to the key generated randomly\nb) Additional value, which is a priority value to the key generated sequentially\nc) Additional heap rule\nd) Additional operations like remove a range of elements\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: The provided recursive function for a queue pops each element, makes a recursive call, and then re-inserts the popped element. This reverses the order of the queue.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose you are given an implementation of a queue of integers.\nConsider the following function:\n\nvoid f(queue<int> &Q) {\n    int i;\n    if (!Q.empty()) {\n        i = Q.front();\n        Q.pop();\n        f(Q);\n        Q.push(i);\n    }\n}\n\nChoices: ['A\\nLeaves the queue Q unchanged', 'B\\nReverses the order of the elements in the queue Q', 'C\\nDeletes the element at the front of the queue Q and inserts it at the rear keeping the other elements in the same order', 'D\\nEmpties the queue Q']\n\nAnswer: B"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a binary tree, internal nodes are those with at least one child. The number of leaf nodes can be derived using the relation: L = N + 1, where L is leaf nodes and N is internal nodes with two children. Here, 5 nodes have one child, and 10 have two children, giving 11 leaf nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a binary tree, the number of internal nodes of degree 1 is 5, and the number of internal nodes of degree 2 is 10. The number of leaf nodes in the binary tree is:\nChoices: ['A\\n10', 'B\\n11', 'C\\n12', 'D\\n15']\n\nAnswer: B"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: The given C++ code recursively reverses an array in-place using a two-pointer approach. It swaps the elements from the beginning and end, and recursively works toward the center.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following code?\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid func(int arr[], int left, int right) {\n    if (left >= right)\n        return;\n    int temp = arr[left];\n    arr[left] = arr[right];\n    arr[right] = temp;\n    func(arr, left + 1, right - 1);\n}\n\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++)\n        cout << arr[i] << \" \";\n}\n\nint main() {\n    int arr[] = {1, 2, 3, 4};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    func(arr, 0, n - 1);\n    printArray(arr, n);\n    return 0;\n}\n\nChoices:\na) 1 2 3 4\nb) 4 3 2 1\nc) 1 4 2 3\nd) 4 1 2 3\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In postfix expressions, operands are pushed onto a stack. When an operator is encountered, the top two operands are popped, the operation is performed, and the result is pushed back. For ab*cd*+, using a=2, b=2, c=3, d=4: (2×2)+(3×4) = 4+12 = 16.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the result of the following postfix expression?\nab*cd*+ where a=2, b=2, c=3, d=4.\na) 16\nb) 12\nc) 14\nd) 10\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In graph theory, a multigraph allows multiple edges between the same pair of vertices. If it also includes self-loops (edges that connect a vertex to itself), it is called a pseudograph.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: MultiGraphs having self-loops are called PseudoGraphs?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The given function is a recursive implementation of the factorial. For input 4, it computes 4 * 3 * 2 * 1 = 24.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What value does function mystery return when called with a value of 4?\n\nint mystery (int number) {\n    if (number <= 1)\n        return 1;\n    else\n        return number * mystery(number - 1);\n}\n\nChoices: ['A\\n0', 'B\\n1', 'C\\n4', 'D\\n24']\n\nAnswer: D"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Reaching the end of an array with given steps involves solving a variant of the jump game. Each element represents the maximum number of steps one can take forward. The number of ways depends on valid combinations to move forward.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In how many different ways can we reach the end of the array arr[]={1,3,5,8,9}?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Reversing an array requires swapping elements from both ends toward the center. For an array with n elements, ⌊n/2⌋ swaps are needed. If n is odd, this simplifies to (n-1)/2.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many swaps are required for reversing an array having n elements where n is an odd number?\na) (n-1) / 2\nb) n / 2\nc) (n / 2) - 1\nd) (n + 1) / 2\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Quick sort is a divide-and-conquer algorithm that partitions the array around a pivot element such that elements less than or equal to the pivot come before it, and elements greater come after it. This process is repeated recursively.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The sorting technique where the array to be sorted is partitioned again and again in such a way that all elements less than or equal to the partitioning element appear before it and those which are greater appear after it is called ________.\nChoices: ['A\\nMerge sort', 'B\\nQuick sort \\n (A) Merge sort \\n (B) Quick sort', 'C\\nSelection sort', 'D\\nNone of these']\n\nAnswer: B\nQuick sort \\n (A) Merge sort \\n (B) Quick sort"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In graph theory, a multigraph allows multiple edges between the same pair of vertices. If it also includes self-loops (edges that connect a vertex to itself), it is called a pseudograph.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: MultiGraphs having self-loops are called PseudoGraphs?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The given function is a recursive implementation of the factorial. For input 4, it computes 4 * 3 * 2 * 1 = 24.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What value does function mystery return when called with a value of 4?\n\nint mystery (int number) {\n    if (number <= 1)\n        return 1;\n    else\n        return number * mystery(number - 1);\n}\n\nChoices: ['A\\n0', 'B\\n1', 'C\\n4', 'D\\n24']\n\nAnswer: D"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Reaching the end of an array with given steps involves solving a variant of the jump game. Each element represents the maximum number of steps one can take forward. The number of ways depends on valid combinations to move forward.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In how many different ways can we reach the end of the array arr[]={1,3,5,8,9}?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Reversing an array requires swapping elements from both ends toward the center. For an array with n elements, ⌊n/2⌋ swaps are needed. If n is odd, this simplifies to (n-1)/2.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many swaps are required for reversing an array having n elements where n is an odd number?\na) (n-1) / 2\nb) n / 2\nc) (n / 2) - 1\nd) (n + 1) / 2\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Quick sort is a divide-and-conquer algorithm that partitions the array around a pivot element such that elements less than or equal to the pivot come before it, and elements greater come after it. This process is repeated recursively.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The sorting technique where the array to be sorted is partitioned again and again in such a way that all elements less than or equal to the partitioning element appear before it and those which are greater appear after it is called ________.\nChoices: ['A\\nMerge sort', 'B\\nQuick sort \\n (A) Merge sort \\n (B) Quick sort', 'C\\nSelection sort', 'D\\nNone of these']\n\nAnswer: B\nQuick sort \\n (A) Merge sort \\n (B) Quick sort"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: Skew heaps and leftist heaps are both types of priority queues. Skew heaps are simpler, self-adjusting versions of leftist heaps and prioritize ease of programming over strict balancing, similar to how splay trees relate to AVL trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The relationship of skew heaps to leftist heaps is analogous to that of?\na) Splay tree and AVL tree\nb) Red black tree and AVL tree\nc) Binary tree and Splay tree\nd) Binary tree and Red black tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a balanced binary tree, the height is minimized, ensuring logarithmic time complexity for search operations. Lookup in such a tree is efficient, with worst-case time O(log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A balanced binary tree with n items allows the lookup of an item in ____ worst-case time.\na) O(log n)\nb) O(n log 2)\nc) O(n)\nd) O(1)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In C, arrays are initialized using curly braces and square brackets. The correct syntax is `int arr[3] = {1, 2, 3};`. Other forms with parentheses are incorrect.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you initialize an array in C?\na) int arr[3] = (1,2,3);\nb) int arr(3) = {1,2,3};\nc) int arr[3] = {1,2,3};\nd) int arr(3) = (1,2,3);\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A simple connected graph with n vertices and n edges forms exactly one cycle. The number of different spanning trees depends on the number of ways to exclude one edge from that cycle. The minimum number of such trees is at least 3.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the largest integer m such that every simple connected graph with n vertices and n edges contains at least m different spanning trees?\nChoices: ['A\\n1', 'B\\n2', 'C\\n3', 'D\\nn']\n\nAnswer: C\n3"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Palindrome checking can be performed using a stack by pushing characters and comparing the reverse order. The correct implementation involves popping characters to build the reversed string.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Select the appropriate code which tests for a palindrome.\n<Java code snippets provided>\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Linear probing is a collision resolution technique in open addressing where a key is placed at the next available location in the array. The formula is: H(x) = (key + F(i)) mod table size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the hash function used in linear probing?\na) H(x) = key mod table size\nb) H(x) = (key + F(i²)) mod table size\nc) H(x) = (key + F(i)) mod table size\nd) H(x) = X mod 17\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: An inversion in an array is a pair (i, j) such that i < j and A[i] > A[j]. In a random permutation of n elements, the expected number of inversions is n(n−1)/4 due to uniform distribution of orderings.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let A[1...n] be an array of n distinct numbers. If i < j and A[i] > A[j], then the pair (i, j) is called an inversion of A. What is the expected number of inversions in any permutation on n elements?\nChoices: ['A\\nn(n-1)/2', 'B\\nn(n-1)/4', 'C\\nn(n+1)/4', 'D\\n2n[logn]']\n\nAnswer: B\nn(n-1)/4"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: Skew heaps are self-adjusting heaps that do not enforce structural constraints like leftist heaps. They rely on simple merging logic and do not require null path length constraints or balancing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In skew heaps, certain constraints are to be met in order to perform swapping.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack can be used to reverse a string by pushing characters one by one and then popping them. This LIFO (Last-In-First-Out) behavior ensures the characters are printed in reverse order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following pseudocode that uses a stack:\n\n# Declare a stack of characters\nword = \"example\"\nchar_stack = []\n\nfor c in word:\n    char_stack.append(c)\n\nwhile char_stack:\n    c = char_stack.pop()\n    print(c, end='')\n\nChoices: ['A\\ngeeksquizgeeksquiz', 'B\\nziuqskeeg', 'C\\ngeeksquiz', 'D\\nziuqskeegziuqskeeg']\n\nAnswer: B\nziuqskeeg"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Finding both the minimum and maximum elements in an array of n elements can be optimized using pairwise comparisons. The total number of comparisons is n + ⌊(n−1)/2⌋ = n + ((n+1)/2) - 2.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The total comparisons in finding both the smallest and largest elements are:\na) 2*n + 2\nb) n + ((n+1)/2) - 2\nc) n + log n\nd) n^2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A postorder traversal of a tree visits the left subtree, then the right subtree, and finally the root node. The given code matches this traversal pattern.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following piece of code do?\n\npublic void func(Tree root)\n{\n    func(root.left());\n    func(root.right());\n    System.out.println(root.data());\n}\n\na) Preorder traversal\nb) Inorder traversal\nc) Postorder traversal\nd) Level order traversal\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In postfix notation, also known as Reverse Polish Notation (RPN), operators follow their operands. Converting from infix to postfix requires applying precedence and associativity rules.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the corresponding postfix expression for the given infix expression?\n\nChoices:\na) ab*cdef/^*g-h+\nb) abcdef^/*g*h*+\nc) abcd*^ed/g*-h*+\nd) abc*de^fg/*-*h+\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In planar graphs, Euler’s formula states: V - E + R = C + 1, where V = vertices, E = edges, R = regions, and C = number of connected components. Given V=6, E=7, R=4, substituting values confirms that C = 2.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given a plane graph G with 2 connected components, 6 vertices, 7 edges, and 4 regions, what is the number of connected components?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The given C++ code performs a depth-first traversal (DFS) on an adjacency matrix representation of a graph starting from node 0. The output depends on the recursive call order based on adjacency.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the output of the following C++ program for the given input?\n\n0 0 0 1 1\n0 0 0 0 1\n0 0 0 1 0\n1 0 1 0 0\n1 1 0 0 0\n\n<Code performs DFS starting from node 0>\n\nChoices:\na) 0 2 3 1 4\nb) 0 3 2 4 1\nc) 0 2 3 4 1\nd) 0 3 2 1 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Prefix notation (Polish notation) evaluates expressions by processing operators before operands from right to left. To answer correctly, the exact expression is required. Since it is missing, the context supports understanding the format but the answer is assumed to be based on a placeholder computation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the solution to the given prefix notation?\na) 12\nb) 7.5\nc) 9\nd) 13.5\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In Red-Black trees, color information (red/black) can be stored efficiently by utilizing unused bits in node pointers. For instance, the least significant bit of a pointer can indicate color without extra memory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How can you save memory when storing color information in a Red-Black tree?\na) Using least significant bit of one of the pointers in the node for color information\nb) Using another array with colors of each node\nc) Storing color information in the node structure\nd) Using negative and positive numbering\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Queues are widely used to simulate limited resource allocation in operating systems and networks, where processes or requests are handled in FIFO order as resources become available.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Queues serve a major role in ______________\na) Simulation of recursion\nb) Simulation of arbitrary linked list\nc) Simulation of limited resource allocation\nd) Simulation of heap sort\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a binary tree, the number of nodes with two children is always one less than the number of leaves in a full binary tree. If a tree has 20 leaves, it will have 19 nodes with two children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A binary tree T has 20 leaves. The number of nodes in T having two children is:\nChoices: ['A\\n18', 'B\\n19', 'C\\n17', 'D\\nAny number between 10 and 20']\n\nAnswer: B\n19"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix (or Reverse Polish) notation places operators after operands. For example, the infix expression (A + B) becomes AB+ in postfix notation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In Postfix expressions, the operators come after the operands.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing involves mapping data to a hash table using a hash function. When inserting characters into a hash table, collisions are handled using methods like linear probing or chaining. The correct answer depends on the specific hash function, which is not shown here.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Insert the characters of the string K R P C S N Y T J M into a hash table of size 10. Use the hash function:\nChoices: ['A\\nY', 'B\\nC', 'C\\nM', 'D\\nP']\n\nAnswer: C\nM"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In infix expressions, operators are placed between operands. When parsed recursively, the structure results in a left expression, followed by an operator, then a right expression, which defines infix notation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The expression obtained by recursively producing a left expression, followed by an operator, followed by recursively producing a right expression is called?\na) Prefix expression\nb) Infix expression\nc) Postfix expression\nd) Parenthesized expression\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A rope (or cord) is a data structure used for efficiently manipulating large strings. It is implemented as a binary tree of strings and is also referred to as a cord structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is also known as the Rope data structure?\na) Cord\nb) String\nc) Array\nd) Linked List\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Two balanced binary search trees can be merged efficiently by first converting both trees to sorted arrays, merging the arrays in O(m+n) time, and then building a balanced BST from the merged array in O(m+n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Two balanced binary trees are given with m and n elements respectively. They can be merged into a balanced binary search tree in ____ time.\na) O(m+n)\nb) O(mn)\nc) O(m)\nd) O(mlog n)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The number of binary trees that can be created with `n` distinct nodes follows the Catalan number sequence. For 3 nodes, the number of structurally unique binary trees is 5.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the possible number of binary trees that can be created with 3 nodes, giving the sequence N, M, L when traversed in post-order?\na) 15\nb) 3\nc) 5\nd) 8\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays in C are initialized using curly braces `{}` and square brackets `[]`. The correct syntax for initializing an array of 3 integers is `int arr[3] = {1,2,3};`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you initialize an array in C?\na) int arr[3] = (1,2,3);\nb) int arr(3) = {1,2,3};\nc) int arr[3] = {1,2,3};\nd) int arr(3) = (1,2,3);\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a full binary tree, each internal node has exactly two children. The number of leaves L in such a tree is always L = I + 1, where I is the number of internal nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a full binary tree, if the number of internal nodes is I, then the number of leaves L is?\na) L = 2*I\nb) L = I + 1\nc) L = I - 1\nd) L = 2*I - 1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Accessing the k-th element from the beginning of a singly linked list is O(1) if pointer starts from the head. Finding the k-th element from the end requires a traversal or two-pointer method, making it O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the time complexities of finding the 8th element from the beginning and 8th element from the end in a singly linked list? Let n > 8.\nChoices: ['A\\nO(n) and O(n)', 'B\\nO(1) and O(1)', 'C\\nO(n) and O(1)', 'D\\nO(1) and O(n)']\n\nAnswer: D"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: B-trees and B+ trees are balanced search trees used in databases. B+ trees store all values in leaf nodes and allow larger fanout due to internal node optimizations. However, their depth is not always greater than that of B-trees, making option C false.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is false?\na) Compared to B-tree, B+-tree has larger fanout\nb) Deletion in B-tree is more complicated than in B+-tree\nc) B+-tree has greater depth than corresponding B-tree\nd) Both B-tree and B+-tree have same search and insertion efficiencies\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: AA-Trees are a type of balanced binary search tree that simulate red-black trees using simpler rules. Maintenance of an AA-tree involves two operations: skew (right rotation) and split (left rotation), making the number of structural shapes to consider just two.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many different shapes does maintenance of an AA-Tree need to consider?\na) 7\nb) 5\nc) 2\nd) 3\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Suffix trees are used for efficient implementation of string operations such as substring search, longest common substring, and pattern matching. They allow these operations in linear time with respect to the string length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which tree allows fast implementation of string operations?\na) Rope Tree\nb) Suffix Tree\nc) Tango Tree\nd) Top Tree\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Separate chaining is a method for handling collisions in hash tables using linked lists. Although it effectively resolves collisions, it increases pointer usage and memory overhead.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a disadvantage of using separate chaining with linked lists?\na) It requires many pointers\nb) It requires linked lists\nc) It uses array\nd) It does not resolve collision\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: An edge cluster in graph theory typically refers to a tightly connected group of nodes. The minimum number of edges to define such a cluster is one—connecting two nodes—hence, the simplest form includes one edge.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many edges are present in an edge cluster?\na) 0\nb) 1\nc) 2\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A Cartesian tree is built from a sequence of unique numbers using a recursive rule: the root is the minimum element, and the left and right subtrees are built from the elements to the left and right of the root. It is not height-balanced, but for unique inputs, it is uniquely defined.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the below statements are true?\ni. A Cartesian tree is not a height balanced tree\nii. A Cartesian tree of a sequence of unique numbers can be uniquely generated\n\na) Both statements are true\nb) Only i is true\nc) Only ii is true\nd) Both are false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: In Java, attempting to pop an element from an empty stack using the Stack ADT results in an `EmptyStackException`, which is part of the Java standard library. It is a runtime exception used to indicate improper access to a stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What happens when you pop from an empty stack while implementing using the Stack ADT in Java?\na) Undefined error\nb) Compiler displays a warning\nc) EmptyStackException is thrown\nd) NoStackException is thrown\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A 2-3 tree is a balanced search tree where each node can have two or three children. The height of a 2-3 tree with `n` elements lies between log₃(n + 1) and log₂(n + 1), due to its structure supporting varying degrees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The height of a 2-3 tree with n elements is ______\na) between (n/2) and (n/3)\nb) (n/6)\nc) between (n) and log₂(n + 1)\nd) between log₃(n + 1) and log₂(n + 1)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A sparse array is optimized to store only non-zero elements, making it more memory-efficient than a normal array when many elements are zero. This structure is useful in applications like graph adjacency matrices or scientific computing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the difference between a normal (naive) array and a sparse array?\na) Sparse array can hold more elements than a normal array\nb) Sparse array is memory efficient\nc) Sparse array is dynamic\nd) A naive array is more efficient\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Parentheses matching is a classic use case for stacks. When encountering an opening bracket, it is pushed onto the stack, and when a closing bracket is encountered, it is matched against the top of the stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following data structures can be used for parentheses matching?\na) n-ary tree\nb) queue\nc) priority queue\nd) stack\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: In the given C++ code, the issue lies not with queue initialization but typically with conceptual understanding. However, the correct answer is related to the comment suggesting queue setup might be missing (e.g., improper structure or setup for viewing tree levels).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is wrong in the below code for printing the Right View of a binary tree using the Queue data structure?\n\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nvoid printRightView(Node* root) {\n    if (root == nullptr) return;\n    queue<Node*> q;\n    q.push(root);\n    while (!q.empty()) {\n        int n = q.size();\n        for (int i = 0; i < n; i++) {\n            Node* x = q.front();\n            q.pop();\n            if (i == n - 1) {\n                cout << x->data << \" \";\n            }\n            if (x->left) q.push(x->left);\n            if (x->right) q.push(x->right);\n        }\n    }\n}\n\nChoices: ['A\\nWe have not initialized anything in the Queue', 'B\\nQueue will never be empty.', 'C\\nleft and right nodes of the tree are null.', 'D\\nNone']\n\nAnswer: A"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: To compute the sum of values between two nodes L and H in a balanced BST, you skip subtrees that are completely out of range. The query takes time O(log n) for traversal and O(m) for m matching elements. The full time bound may include constants a, b, c, and d to model deeper operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose we have a balanced binary search tree T holding n numbers. We are given two numbers L and H and wish to sum up all the numbers in T that lie between L and H. Suppose there are m such numbers in T. If the tightest upper bound on the time to compute the sum is O(n^a log^b n + m·c log^d n), the value of a + 10b + 100c + 1000d is ____.\nChoices: ['A\\n60', 'B\\n110', 'C\\n210', 'D\\n50']\n\nAnswer: B"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: The trace of a matrix is the sum of elements on its main diagonal, which are at positions where the row index equals the column index (i == j).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following piece of code do?\n\nfor (int i = 0; i < row; i++) {\n    for (int j = 0; j < column; j++) {\n        if (i == j)\n            sum = sum + array[i][j];\n    }\n}\nSystem.out.println(sum);\n\na) Normal of a matrix\nb) Trace of a matrix\nc) Square of a matrix\nd) Transpose of a matrix\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: The load factor in separate chaining is the average number of elements per bucket and can exceed 1. However, an ideal average load factor is around 1 to maintain efficient performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What should be the load factor for separate chaining hashing?\na) 0.5\nb) 1\nc) 1.5\nd) 2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Rotating an array by 2 means shifting all elements two positions to the left and moving the first two elements to the end. For arr[]={1,2,3,4,5}, the result is {3,4,5,1,2}.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the resulting array after rotating arr[]={1, 2, 3, 4, 5} by 2?\na) 2, 1, 3, 4, 5\nb) 3, 4, 5, 1, 2\nc) 4, 5, 1, 2, 3\nd) 1, 2, 3, 5, 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Universal hashing is a technique that chooses the hash function at random from a carefully designed class of functions, offering better average-case performance by minimizing collision probability.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which scheme uses a randomization approach?\na) Hashing by division\nb) Hashing by multiplication\nc) Universal hashing\nd) Open addressing\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A doubly linked list contains two pointers per node: one to the next node and one to the previous. This allows bidirectional traversal but also increases space usage and complexity compared to a singly linked list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is false about a doubly linked list?\na) We can navigate in both directions\nb) It requires more space than a singly linked list\nc) The insertion and deletion of a node take a bit longer\nd) Implementing a doubly linked list is easier than a singly linked list\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a Directed Acyclic Graph (DAG), topological sorting can be used to compute the shortest paths from a single source efficiently. Unlike general graphs, DAGs do not have cycles, which allows this linear-time optimization.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following algorithms can be used to efficiently calculate single source shortest paths in a Directed Acyclic Graph?\nChoices: ['A\\nDijkstra', 'B\\nBellman-Ford', 'C\\nTopological Sort', 'D\\nStrongly Connected Component']\n\nAnswer: C"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Recursive algorithms often use the system call stack to maintain state across function calls. A non-recursive version of such algorithms requires explicit use of a stack data structure to emulate this behavior.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What data structure would you most likely see in a non-recursive implementation of a recursive algorithm?\na) Stack\nb) Linked List\nc) Tree\nd) Queue\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Converting a decimal number to binary using a stack involves repeatedly dividing the number by 2, pushing the remainder onto a stack, and then popping elements to print the binary representation in reverse order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Using stacks, how do you obtain the binary representation of a number?\n<Code options provided>\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In a queue implemented with a linked list, new elements are added at the rear and removed from the front. During insertion into a non-empty queue, only the `rear` pointer is updated.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a linked list implementation of a queue, front and rear pointers are tracked. Which of these pointers will change during an insertion into a NONEMPTY queue?\na) Only front pointer\nb) Only rear pointer\nc) Both front and rear pointer\nd) No pointer will be changed\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Parenthesis matching is a classic problem solved using stacks. When checking if parentheses are balanced, each opening bracket is pushed onto the stack, and closing brackets pop from the stack. If at the end the stack is empty, the parentheses are balanced. This check is O(n) in complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Write a piece of code which returns true if the string contains balanced parenthesis, false otherwise.\n<Java code options provided>\n\nChoices: a) O(log n)\nb) O(n)\nc) O(1)\nd) O(n log n)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In Java, arrays are instantiated using the `new` keyword followed by the type and size in square brackets. The correct syntax is `int arr[] = new int[3];`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you instantiate an array in Java?\na) int arr[] = new int(3);\nb) int arr[];\nc) int arr[] = new int[3];\nd) int arr() = new int(3);\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A circular queue, also known as a ring buffer, connects the last position back to the first to utilize space efficiently. It is used in scenarios like CPU scheduling and buffering data streams.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Circular Queue is also known as ________\na) Ring Buffer\nb) Square Buffer\nc) Rectangle Buffer\nd) Curve Buffer\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack follows Last-In-First-Out (LIFO) order. If elements “A”, “B”, “C”, and “D” are pushed in that order, they will be popped in reverse order: D, C, B, A.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If the elements “A”, “B”, “C” and “D” are placed in a stack and are deleted one at a time, what is the order of removal?\na) ABCD\nb) DCBA\nc) DCAB\nd) ABDC\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: The optimal merge pattern problem determines the minimum number of comparisons to merge sorted files. Merging files of sizes 15, 3, 9, and 8 optimally (greedily combining smallest first) requires 15 comparisons.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The total number of comparisons required to merge 4 sorted files containing 15, 3, 9 and 8 records into a single sorted file is ________.\nChoices: ['A\\n66', 'B\\n39', 'C\\n15', 'D\\n3']\n\nAnswer: C"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In a binary search tree (BST), the left child must have a value less than the parent. The given statement implies this is true for all trees, which is incorrect. It only applies to BSTs, not general binary trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Left child of a parent node has value lesser than the parent node.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a max-heap, the heap property ensures that the largest element is always located at the root. This structure allows constant-time access to the maximum element.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a max-heap, the element with the greatest key is always in which node?\na) Leaf node\nb) First node of left subtree\nc) Root node\nd) First node of right subtree\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Top trees are used in dynamic tree algorithms. They rely on the divide and conquer paradigm by breaking the tree into clusters and solving subproblems recursively.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which algorithm is used in the top tree data structure?\na) Divide and Conquer\nb) Greedy\nc) Backtracking\nd) Branch\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A full binary tree is a tree where every node has either 0 or 2 children. If such a tree has `n` leaf nodes, then it has exactly `2n - 1` total nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A full binary tree with n leaves contains ________.\nChoices: ['A\\nn nodes', 'B\\nlog n2 nodes', 'C\\n2n – 1 nodes', 'D\\n2n nodes']\n\nAnswer: C"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: When checking for balanced expressions or structured input using a stack, failure to empty the stack at the end implies unmatched symbols and typically results in an error.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An error is reported when the stack is not empty at the end.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: An inverter graph, often used in digital circuits, is a form of directed acyclic graph (DAG). It models logical flow without cycles, which allows consistent topological ordering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An Inverter Graph is a type of __________\na) Multigraph\nb) Cyclic Graph\nc) Directed Acyclic Graph\nd) Directed Acyclic Word Graph\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Linked lists are dynamic structures ideal for collections where the size may change frequently. They allow efficient insertion and deletion, making them suitable for non-permanent or frequently modified data.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Linked lists are best suited ________.\nA. For relatively permanent collections of data.\nB. For the size of the structure and the data in the structure are constantly changing.\nC. Data structure\nD. For none of the above situations\n\nAnswer: B"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: In linked list-based queue implementations, available nodes may be managed through a separate free list called the AVAIL list. When inserting a new node, it is taken from the AVAIL list to avoid allocating new memory dynamically each time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In case of insertion into a linked queue, a node borrowed from the __________ list is inserted in the queue.\na) AVAIL\nb) FRONT\nc) REAR\nd) NULL\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A pseudograph is a graph that allows self-loops and multiple edges. An adjacency matrix representing a graph with non-zero diagonal entries indicates the presence of self-loops, identifying a pseudograph.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given adjacency matrices, determine which of them are PseudoGraphs?\ni) {{1,0}, {0,1}}\nii) {{0,1}, {1,0}}\niii) {{0,0,1}, {0,1,0}, {1,0,0}}\n\na) only i)\nb) ii) and iii)\nc) i) and iii)\nd) i), ii), and iii)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Any decision tree that sorts n elements must have at least n leaves, and therefore a height of at least Ω(n) in the worst case, as each comparison decision leads to a distinct permutation of input.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Any decision tree that sorts n elements has height:\nChoices: ['A\\nΩ(n)', 'B\\nΩ(log n)', 'C\\nΩ(n log n)', 'D\\nΩ(n²)']\n\nAnswer: A"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In a hypergraph, a hyperedge can connect any number of vertices. The degree of a vertex is the number of hyperedges it is part of. The degree sequence is the list of degrees sorted in non-increasing order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the degree sequence of the given hypergraph in non-increasing order?\nV = {v1,v2,v3,v4,v5,v6}, E = {{v1,v4,v5}, {v2,v3,v4,v5}, {v2}, {v1}, {v1,v6}}\n\na) 3, 2, 1, 1, 1, 1\nb) 3, 2, 2, 2, 1, 1\nc) 3, 2, 2, 2, 2, 1\nd) 3, 2, 2, 1, 1, 1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A queue can be implemented using two stacks. One stack is used for enqueue operations and the other for dequeue, ensuring that the queue maintains FIFO order using LIFO operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The minimum number of stacks needed to implement a queue is:\nChoices: ['A\\n3', 'B\\n1', 'C\\n2', 'D\\n4']\n\nAnswer: C"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: Topological sorting of a Directed Acyclic Graph (DAG) can be done in linear time using either Depth First Search (DFS) or Kahn’s algorithm. The time complexity is O(V + E), where V is the number of vertices and E is the number of edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The topological sorting of any DAG can be done in ________ time.\na) Cubic\nb) Quadratic\nc) Linear\nd) Logarithmic\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The number of distinct binary search trees (BSTs) that can be created with `n` distinct keys is given by the nth Catalan number. For n = 4, the result is C₄ = 14.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many distinct binary search trees can be created out of 4 distinct keys?\nChoices: ['A\\n4', 'B\\n14', 'C\\n24', 'D\\n42']\n\nAnswer: B"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A priority queue is a type of queue where each element has a priority. Elements can be removed in ascending or descending priority order. Hence, both ascending and descending order priority queues are valid types.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the type of priority queue?\nChoices: ['A\\nAscending Order Priority Queue', 'B\\nDescending order Priority Queue', 'C\\nDeque', 'D\\nBoth A and B.']\n\nAnswer: D"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: For a binary tree, if an in-order traversal results in a sorted sequence, the tree is a binary search tree (BST). This traversal visits nodes in left-root-right order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: One can determine whether a binary tree is a binary search tree by traversing it in ________.\nChoices: ['A\\nPre-order', 'B\\nIn-order', 'C\\nPost-order', 'D\\nAny of these']\n\nAnswer: B"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: DNA sequence alignment uses algorithms like Smith-Waterman and Needleman-Wunsch, not traditional string matching algorithms like Rabin-Karp or KMP. These algorithms are based on dynamic programming.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In DNA sequence alignment, which string-matching algorithm is commonly used to identify similarities between two DNA sequences efficiently?\nChoices: ['A\\nRabin-Karp algorithm', 'B\\nKnuth-Morris-Pratt algorithm', 'C\\nZ function', 'D\\nNone of the above']\n\nAnswer: D"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays provide contiguous memory allocation and support random access. Linked lists allow flexible size but have slower access due to pointer traversal. Access speed is generally better in arrays.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following points is/are not true about the linked list data structure when compared with an array?\na) Arrays have better cache locality that can make them better in terms of performance\nb) It is easy to insert and delete elements in linked lists\nc) Random access is not allowed in a typical implementation of linked lists\nd) Access of elements in a linked list takes less time than in arrays\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A skip list is a linked structure designed for fast search operations. It uses multiple levels of linked lists with skip pointers to allow logarithmic search time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a skip list?\na) A linked list with size value in nodes\nb) A linked list that allows faster search within an ordered sequence\nc) A linked list that allows slower search within an ordered sequence\nd) A tree which is in the form of a linked list\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays store data in contiguous memory locations and are efficient for storing elements of the same data type. This allows simple memory management and fast indexed access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the advantages of arrays?\na) Objects of mixed data types can be stored\nb) Elements in an array cannot be sorted\nc) Index of the first element of an array is 1\nd) Easier to store elements of the same data type\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In an array representation of a complete binary tree using 1-based indexing, for a node at index `w`, the left child is at `2w` and the right child is at `2w + 1`. This formula allows efficient parent-child navigation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the children for node ‘w’ of a complete-binary tree in an array representation?\na) 2w and 2w+1\nb) 2+w and 2-w\nc) w+1/2 and w/2\nd) w-1/2 and w+1/2\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a binary search tree (BST), the maximum element is located at the rightmost node. To find it, traverse from the root repeatedly to the right child until reaching a node with no right child.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How will you find the maximum element in a binary search tree?\n<Code snippets given for options>\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Two graphs are isomorphic if there is a one-to-one mapping between their vertex sets that preserves adjacency. If their incidence matrices can be rearranged to match, they are isomorphic.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The graphs G1 and G2 with their incidence matrices given are isomorphic.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Red-black trees require fewer rotations than AVL trees during insertion and deletion because they store less balancing information. AVL trees use a balance factor at each node, which increases space and operation complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Why prefer red-black trees over AVL trees?\na) Because red-black is more rigidly balanced\nb) AVL tree stores balance factor in every node which costs space\nc) AVL tree fails at scale\nd) Red-black is more efficient\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: If all edge weights in a graph are multiplied by a constant, the shortest path remains the same. This is because path weights scale proportionally and the relative path order does not change.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is the following statement valid about shortest paths?\n\nGiven a graph, suppose we have calculated shortest paths from a source to all other vertices. If we modify the graph such that weights of all edges become double the original weight, then the shortest path remains the same—only the total weight of the path changes.\nChoices: ['A\\nTrue', 'B\\nFalse']\n\nAnswer: A"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs can have multiple visual representations depending on the placement of vertices and edges. These visual layouts do not affect the structural properties, so graphical representation is not unique.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: All graphs have unique representation on paper.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a complete graph of 100 vertices where edge weights are defined as |i - j| for edge (vi, vj), the minimum spanning tree (MST) connects adjacent vertices (v1–v2, v2–v3, ..., v99–v100). Each edge contributes a weight of 1, and there are 99 such edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a graph G=(V, E), where V = {v1, v2, ..., v100} and E = {(vi, vj) | 1 ≤ i < j ≤ 100}. The weight of edge (vi, vj) is |i – j|. The weight of the minimum spanning tree of G is ________.\nChoices: ['A\\n99', 'B\\n100', 'C\\n98', 'D\\n101']\n\nAnswer: A"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hash tables are data structures that provide efficient operations for inserting and searching elements using a hash function. These are the primary operations supported by most hash table implementations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following operations are done in a hash table?\na) Insert only\nb) Search only\nc) Insert and search\nd) Replace\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Auxiliary space is the extra space or temporary space used by an algorithm. In the given code, an array `temp[10]` is used for temporary storage of `d` elements, hence the auxiliary space is O(d).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the auxiliary space complexity of the following code?\n\n<Code rotates an array using an intermediate temp[] array>\n\na) O(1)\nb) O(n)\nc) O(d)\nd) O(n*d)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In Java, the `BitSet` class is used to represent a bit array. It allows bitwise manipulation and is part of the `java.util` package, providing methods like `set`, `clear`, and `flip` for managing bits efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which class in Java can be used to represent a bit array?\na) BitSet\nb) BitVector\nc) BitArray\nd) BitStream\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A parse tree for a grammar generates the same structure regardless of whether it's based on leftmost or rightmost derivation, as long as the grammar is unambiguous. Thus, the number of parse trees equals the number of both derivation trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is correct with respect to a parse tree for a given grammar?\na) n parse tree = n leftmost derivation tree = n rightmost derivation tree\nb) n parse tree = n leftmost derivation tree\nc) n parse tree = n rightmost derivation tree\nd) n parse tree = n non-terminals\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a d-heap (a generalization of a binary heap where each node has d children), operations like insert, delete, and create are well-defined. However, a generic `find` operation is not directly supported since heaps are not designed for search.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which operation cannot be directly performed in a d-heap?\na) Insert\nb) Delete\nc) Find\nd) Create\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Easy\nContext: A palindromic string is a string that reads the same forward and backward. Examples include 'madam', 'racecar', and 'level'. This is a fundamental concept in string processing and pattern recognition.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a palindromic string?\nChoices: ['A\\nThe string of length 0', 'B\\nThe string having a special character.', 'C\\nThe string having an uppercase letter', 'D\\nThe string whose reversed string is equal to the original string.']\n\nAnswer: D\nThe string whose reversed string is equal to the original string."
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A triply linked list extends the doubly linked list with an additional pointer (often called top or third) to provide enhanced navigation. Inserting a node typically involves initializing the pointers and updating head/tail references.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following algorithm to insert an element in a triply linked list:\n\ninitializing previous, next and top pointers to null\npointing the head and tail to the node created\npointing previous, next and top pointers to the node created\ninitializing the head and tail to null\ninitializing previous, next and top pointers to null\ninitializing the head and tail to null\npointing previous, next and top pointers to the node\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Both Dijkstra's and Bellman-Ford algorithms compute shortest paths from a source node. When all edge weights are positive, the actual shortest path costs are the same, although the paths themselves might differ in structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is the following statement valid?\n\nGiven a graph where all edges have positive weights, the shortest paths produced by Dijkstra and Bellman-Ford algorithms may be different, but path weight would always be the same.\nChoices: ['A\\nTrue', 'B\\nFalse']\n\nAnswer: A"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In a doubly linked list, insertion affects four pointers: the previous and next pointers of the new node, and the pointers in neighboring nodes. This makes total pointer operations four, not any of the given exact numeric options, hence “None of these.”\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a doubly linked list, the number of pointers affected for an insertion operation will be:\nChoices: ['A\\n5', 'B\\n0', 'C\\n1', 'D\\nNone of these']\n\nAnswer: D\nNone of these"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The given function appends a node at the end of a singly linked list. It traverses the list to find the last node and updates its `next` pointer to the new node. This is a common operation in list manipulation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the following code?\n\npublic void function(Node node) {\n  if (size == 0)\n    head = node;\n  else {\n    Node temp, cur;\n    for (cur = head; (temp = cur.getNext()) != null; cur = temp);\n    cur.setNext(node);\n  }\n  size++;\n}\n\na) Inserting a node at the beginning of the list\nb) Deleting a node at the beginning of the list\nc) Inserting a node at the end of the list\nd) Deleting a node at the end of the list\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Splay trees are self-adjusting binary search trees. They move recently accessed elements closer to the root using rotations, which improves access time for frequently used elements. They are simpler to implement than AVL or Red-Black trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Why prefer splay trees?\na) Easier to program\nb) Space efficiency\nc) Easier to program and faster access to recently accessed items\nd) Quick searching\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a K-ary tree, the height of a tree with only the root node is 0 because there are no edges from the root to any other node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the height of a K-ary tree having only the root node?\na) 1\nb) 0\nc) 2\nd) 3\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Transposing a matrix involves swapping elements across its diagonal. In this case, the function iterates over the upper triangle and swaps A[i][j] with A[j][i], effectively transposing the matrix.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let A be a matrix of size n x n. Consider the following program. What is the expected output?\n\nvoid fun(int A[][N]) {\n    for (int i = 0; i < N; i++)\n        for (int j = i + 1; j < N; j++)\n            swap(A[i][j], A[j][i]);\n}\n\nChoices: ['A\\nMatrix A', 'B\\nDiagonal Of matrix A', 'C\\nTranspose of matrix A', 'D\\nNone']\n\nAnswer: C"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used in digital signature systems not for encrypting or decrypting the signature itself but to hash the message into a fixed-size digest, which is then signed or verified.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Hashing can be used to encrypt and decrypt digital signatures.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Operator precedence and associativity guide the conversion from infix to postfix expressions. In this case, the postfix expression is created by respecting right and left associativity and operator precedence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Assume that the operators +, -, × are left-associative and ^ is right-associative. The order of precedence (from highest to lowest) is ^, ×, +, -. What is the postfix expression for the infix expression a + b × c − d ^ e ^ f?\na) a b c × + d e f ^ ^ −\nb) a b c × + d e ^ f ^ −\nc) a b + c × d − e ^ f ^\nd) − + a × b c ^ ^ d e f\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A B-tree of minimum degree t and height h has a search time complexity of Θ(logₜ n), where n is the number of keys. This allows for efficient disk-based searching in large datasets.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of disk page accesses in a B-tree search, where h is height, n is the number of keys, and t is the minimum degree, is:\nChoices: ['A\\nΘ(log n h * t)', 'B\\nΘ(log t n * h)', 'C\\nΘ(log h n)', 'D\\nΘ(log t n)']\n\nAnswer: D"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Linked lists are suitable for operations like insertion, deletion, and manipulation of data where random access is not required. However, binary search requires random access, which is inefficient in a linked list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Linked lists are not suitable for the implementation of ___________\na) Insertion sort\nb) Radix sort\nc) Polynomial manipulation\nd) Binary search\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: AA-trees are simplified versions of red-black trees. They maintain balance using right-child-only 'red' links and a level field instead of colors. Coding practices (e.g., recursion) are not structural rules, hence statement 2 is incorrect.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Of the following rules that are followed by an AA-tree, which of the following is incorrect?\n1. Only right children can be red\n2. Procedures are coded recursively\n3. Instead of storing colors, the level of a node is stored\n4. There should not be any left children\n\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In a binary min-heap, each parent must be less than or equal to its children. During heap construction, comparisons and swaps enforce this property. A violation of this rule would occur on a line where this relationship is not upheld.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For the construction of a binary heap with the property that the parent node has a value less than the child node, which line is incorrect (lines indexed from 1)?\na) Line – 3\nb) Line – 5\nc) Line – 6\nd) Line – 7\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: A treap is a binary search tree with the heap property based on node priority. The root node must have the highest priority. Therefore, it is the node with the lowest logical value (in heap terms).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which node has the lowest priority in a treap?\na) Root node\nb) Leaf node\nc) Null node\nd) Centre node\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Operator precedence defines the order in which operators are evaluated in expressions. Among the listed operators, bitwise NOT (`~`) and XOR (`^`) have higher precedence than arithmetic operators like `+` and `-`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of these operators have the highest order of precedence?\na) ‘(‘ and ‘)’\nb) ‘*’ and ‘/’\nc) ‘~’ and ‘^’\nd) ‘+’ and ‘-‘\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Constructing a suffix array using a comparison-based sorting algorithm involves sorting all suffixes of the string. Each comparison between two suffixes can take O(n), and sorting n suffixes leads to O(n² log n) time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If a comparison-based sorting algorithm is used to construct the suffix array, what will be the time required to construct the suffix array?\na) O(n log n)\nb) O(n²)\nc) O(n² log n)\nd) O(n²) + O(log n)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: To implement a stack using a priority queue, each new item must be assigned a priority that ensures it is removed before earlier items. This is achieved by assigning strictly decreasing keys, so the last pushed item is removed first.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A priority queue Q is used to implement a stack S that stores characters. PUSH(C) is implemented as INSERT(Q, C, K) where K is a key. POP is implemented as DELETEMIN(Q). For a sequence of operations, the keys should be in:\nChoices: ['A\\nNon-increasing order', 'B\\nNon-decreasing order', 'C\\nStrictly increasing order', 'D\\nStrictly decreasing order']\n\nAnswer: D"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: In a linked list-based stack, the top element (`first`) is removed by assigning `first` to `first.getNext()`. The pop operation should return the value of the original top node before the update.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given the Node and Stack classes, which of the following pop() implementations correctly removes and returns the top of the stack?\n<Java pop() method code options provided>\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A 2-dimensional tree (kd-tree) is a generalization of a binary search tree (BST), where each level alternates between dimensions. Inserting into a 2-d tree follows similar logic to BST insertion, but with coordinate-based comparisons.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Insertion into a 2-d tree is a trivial extension of insertion into a binary search tree.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Prefix expressions are evaluated from right to left. The expression `+-9 2 7` is evaluated as -9 + (2 - 7) = -9 + (-5) = -14. Thus, the correct answer is 14 (absolute value).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Using prefix evaluation, what is the result of the expression +-9 2 7?\na) 10\nb) 4\nc) 17\nd) 14\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Compared to arrays, linked lists provide dynamic memory allocation, efficient insertion/deletion, and do not require a fixed size. However, they lack random access and have lower cache locality.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following points is/are true about the Linked List data structure when compared with arrays?\nChoices: ['A\\nArrays have better cache locality that can make them better in terms of performance.', 'B\\nIt is easy to insert and delete elements in Linked List', 'C\\nRandom access is not allowed in a typical implementation of Linked Lists', 'D\\nThe size of array has to be pre-decided, linked lists can change their size any time.', 'E\\nAll of the above']\n\nAnswer: E"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In binomial heaps and similar structures, merging two trees of the same order k results in a tree of order k+1. This is because one becomes the child of the other, increasing the depth by one.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the order of the resultant heap after merging two trees of order k?\na) 2*k\nb) k+1\nc) k*k\nd) k+logk\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Simple uniform hashing assumes that each key is equally likely to be hashed into any of the slots. A good hash function for this often uses fractional multipliers such as h(k) = floor(k × m), where m is a constant less than 1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which hash function satisfies the condition of simple uniform hashing?\na) h(k) = lowerbound(km)\nb) h(k) = upperbound(mk)\nc) h(k) = lowerbound(k)\nd) h(k) = upperbound(k)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: In parentheses matching using stacks, if a closing bracket is found without a matching opening bracket (or the stack is empty), an error is reported to indicate an unbalanced expression.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When the corresponding end bracket/braces/parentheses is not found, what happens?\na) The stack is popped\nb) Ignore the parentheses\nc) An error is reported\nd) It is treated as an exception\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: A good hash function should distribute keys uniformly across the table and be independent of patterns in the data. Dependence on patterns often leads to clustering and poor performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A good hash approach is to derive the hash value that is expected to be dependent on any patterns that might exist in the data.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The C++ code reverses the first `k` elements of an array using a two-pointer approach. For k=3 and array {1, 2, 3, 4, 5}, it results in {3, 2, 1, 4, 5}.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following code?\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid func(int a[], int n, int k) {\n    if (k <= n) {\n        for (int i = 0; i < k/2; i++)\n            swap(a[i], a[k - i - 1]);\n    }\n}\n\nint main() {\n    int a[] = {1, 2, 3, 4, 5};\n    int n = sizeof(a) / sizeof(int), k = 3;\n    func(a, n, k);\n    for (int i = 0; i < n; ++i)\n        cout << a[i] << \" \";\n    return 0;\n}\n\na) 3 2 1 4 5\nb) 5 4 3 2 1\nc) 1 2 5 4 3\nd) error\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In an AVL tree, which is a self-balancing binary search tree, the height is bounded by O(log p) where p is the number of nodes. This ensures efficient search, insertion, and deletion operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum height of an AVL tree with p nodes?\na) p\nb) log(p)\nc) log(p)/2\nd) p/2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A sparse array stores only non-null (or non-zero) elements, saving memory. In contrast, a normal array of length 6 stores all elements, including nulls. So its logical size is 6, but the sparse representation only stores 2 meaningful elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose the contents of an array A are, A = {1, null, null, null, null, 10}; What would be the size of the array considering it as a normal array and a sparse array?\na) 6 and 6\nb) 6 and 2\nc) 2 and 6\nd) 2 and 2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: An adjacency list representation of an undirected graph stores each edge twice (once for each vertex), resulting in space complexity of O(V + E), where V is the number of vertices and E is the number of edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Space complexity for an adjacency list of an undirected graph having large values of V (vertices) and E (edges) is ___________\na) O(E)\nb) O(V*V)\nc) O(E + V)\nd) O(V)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Checking balanced parentheses requires tracking matching opening and closing brackets, which is efficiently done using a stack. Arrays and queues do not support the required LIFO behavior.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The data structure required to check whether an expression contains a balanced parenthesis is?\na) Queue\nb) Stack\nc) Tree\nd) Array\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A heap is a complete binary tree that satisfies the heap property (either max-heap or min-heap). It is implemented using an array but logically represented as a binary tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Heap exhibits the property of a binary tree?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix expressions (also known as Reverse Polish Notation) do not require parentheses and can be evaluated linearly using a stack, making them easier and more efficient for computers to process.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: It is easier for a computer to process a postfix expression than an infix expression.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In a XOR linked list, each node stores the XOR of the addresses of the previous and next nodes instead of maintaining two separate pointers. This saves memory in comparison to traditional doubly linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does a XOR linked list have?\na) Every node stores the XOR of addresses of previous and next nodes\nb) Actual memory address of next node\nc) Every node stores the XOR of addresses of previous and next two nodes\nd) Every node stores XOR of 0 and the current node address\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In circular linked lists, inserting at the head requires updating both the head pointer and the last node’s next pointer to maintain the circular structure. Proper care must be taken to update links in both empty and non-empty cases.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Choose the code snippet which inserts a node to the head of the list:\n<Java insertHead() code options provided>\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The given pseudocode performs a right rotation of a binary tree node. This operation restructures the tree by making the left child the new root of the subtree, useful in balancing trees like AVL and splay trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What output does the below pseudo code produce?\n\nTree_node function(Tree_node x) {\n    Tree_node y = x.left;\n    x.left = y.right;\n    y.right = x;\n    return y;\n}\n\na) Right rotation of subtree\nb) Left rotation of subtree\nc) Zig-zag operation\nd) Zig-zig operation\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Prefix notation (Polish notation) places operators before their operands. In the expression a | & b c, `&` has higher precedence, and `|` applies to the result of `&`. Thus the prefix form is | a & b c.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the Prefix notation for the given equation?\n\na) a|&bc\nb) &|abc\nc) |a&bc\nd) ab&|c\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In XOR linked lists, pointer arithmetic is used by XORing node addresses. Since address arithmetic isn't natively supported, explicit type casting is required to convert between integers and pointers correctly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What’s wrong with this code which returns XOR of two node addresses?\na) Nothing wrong. Everything is fine\nb) Type casting at return is missing\nc) Parameters are wrong\nd) Total logic is wrong\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The van Emde Boas (vEB) tree is a tree data structure that supports fast predecessor, successor, and minimum/maximum queries in O(log log U) time. It was introduced by Peter van Emde Boas.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Who invented the vEB tree, also known as Van Emde Boas Tree?\na) Peter Van Emde Boas\nb) Samuel F. B. Morse\nc) Friedrich Clemens Gerke\nd) Alexander Morse\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A weak heap is a variant of a binary heap used in sorting algorithms like Weak Heap Sort. It is sometimes referred to as a relaxed heap due to less strict structural properties compared to binary heaps.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the other name of a weak heap?\na) Min-heap\nb) Max-heap\nc) Relaxed-heap\nd) Leonardo heap\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Matrix multiplication is associative and distributive over addition, but not commutative. That is, A × B ≠ B × A in general, making commutativity the property that does not hold.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following properties does not hold for matrix multiplication?\na) Associative\nb) Distributive\nc) Commutative\nd) Additive Inverse\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: Queues are abstract data structures with several variations including ordinary queue (FIFO), circular queue (with wrap-around logic), and priority queue (based on priority levels). 'Single ended queue' is not a standard classification.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not a type of queue?\na) Priority queue\nb) Circular queue\nc) Single ended queue\nd) Ordinary queue\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In column-major order, elements of a matrix are stored column by column in memory. For the matrix:\n```\na b c\nd e f\ng h i\n```\nthe order will be a, d, g, b, e, h, c, f, i.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If column-major order is used, how is the following matrix stored in memory?\n```\na b c\nd e f\ng h i\n```\na) ihgfedcba\nb) abcdefghi\nc) cfibehadg\nd) adgbehcfi\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a max-heap, new elements are inserted at the next available leaf position and then 'heapified up' to maintain the heap property. The level-order traversal changes depending on the heapification process.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A priority queue is implemented as a max-heap. Initially, it has 5 elements. The level-order traversal of the heap is: 10, 8, 5, 3, 2. Two new elements 1 and 7 are inserted into the heap in that order. What is the level-order traversal of the heap after insertion?\nChoices: ['A\\n10, 8, 7, 3, 2, 1, 5', 'B\\n10, 8, 7, 2, 3, 1, 5', 'C\\n10, 8, 7, 1, 2, 3, 5', 'D\\n10, 8, 7, 5, 3, 2, 1']\n\nAnswer: A"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A descending priority queue removes the highest priority (largest) element first. This behavior is efficiently implemented using a max-heap, where the maximum element is always at the root.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A descending priority queue can be implemented using ______\na) Max heap\nb) Min heap\nc) Min-max heap\nd) Trie\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: In double hashing, the two hash functions h1(k) and h2(k) are used for probe sequences. A correct implementation involves computing h1(k) = k mod m and h2(k) = 1 + (k mod m′) to ensure uniformity and reduce clustering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the values of h1(k) and h2(k) in the hash function?\nOptions:\n- h1(k) = m mod k\n  h2(k) = 1 + (m′ mod k)\n- h1(k) = 1 + (m mod k)\n  h2(k) = m′ mod k\n- h1(k) = 1 + (k mod m)\n  h2(k) = k mod m\n- h1(k) = k mod m\n  h2(k) = 1 + (k mod m′)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The minimum number of interchanges needed to convert the array 89, 19, 40, 17, 12, 10, 2, 5, 7, 11, 6, 9, 70 into a heap with the maximum element at the root is, , Choices: ['A\\n0', 'B\\n1', 'C\\n2', 'D\\n3'], Answer: C\n2"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Easy\nContext: Searching algorithms are used to retrieve data from structures. Direct addressing allows constant time O(1) access using an array index derived from the key.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the search complexity in direct addressing?\na) O(n)\nb) O(logn)\nc) O(nlogn)\nd) O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The postfix form of the expression (A+B)*(C*D−E)*F/G is:, , Choices: ['A\\nAB+CD*E−FG/**', 'B\\nAB+CD*E−F**G/', 'C\\nAB+CD*E−*F*G/', 'D\\nAB+ CDE*−*F*G/'], Answer: A\nAB+CD*E−FG/**"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "On what value does the probe sequence depend on?\na) c1\nb) k\nc) c2\nd) m\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The procedure FindMin() to find the minimum element and the procedure DeleteMin() to delete the minimum element in min heap take _________\na) logarithmic and linear time constant respectively\nb) constant and linear time respectively\nc) constant and quadratic time respectively\nd) constant and logarithmic time respectively\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following definition in c programming language.\n\nstruct node\n{\n    int data;\n    struct node * next;\n}\ntypedef struct node NODE;\nNODE *ptr;\n\nWhich of the following c code is used to create new node?\na) ptr = (NODE*)malloc(sizeof(NODE));\nb) ptr = (NODE*)malloc(NODE);\nc) ptr = (NODE*)malloc(sizeof(NODE*));\nd) ptr = (NODE)malloc(sizeof(NODE));\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider yourself to be in a planet where the computational power of chips to be slow. You have an array of size 10.You want to perform enqueue some element into this array. But you can perform only push and pop operations .Push and pop operation both take 1 sec respectively. The total time required to perform enQueue operation is?\na) 20\nb) 40\nc) 42\nd) 43\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "10. What are the disadvantages of arrays?\na) Data structure like queue or stack cannot be implemented\nb) There are chances of wastage of memory space if elements inserted in an array are lesser than the allocated size\nc) Index value of an array can be negative\nd) Elements are sequentially accessed\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider a hash function that distributes keys uniformly. The hash table size is 20. After hashing of how many keys will the probability that any new key hashed collides with an existing one exceed 0.5., , Choices: ['A\\n5', 'B\\n6', 'C\\n7', 'D\\n10'], Answer: D\n10"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the minimum number of jumps required to reach the end of the array arr[] = {1,2,0,0,3,6,8,5}?\na) 1\nb) 2\nc) 3\nd) not possible to reach the end\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many top trees are there in a tree with single vertex?\na) 0\nb) 1\nc) 2\nd) 3\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. Algorithms like Floyd-Warshall and Dijkstra compute shortest paths.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the value of the distance matrix, after the execution of the given code?\n\n#include <bits/stdc++.h>\n#define INF 1000000\nint graph[V][V] = {   {0,   7,  INF, 4},\n                      {INF, 0,   13, INF},\n                      {INF, INF, 0,   12},\n                      {INF, INF, INF, 0}\n                  };\n \nint distance[V][V], i, j, k;\n \nfor (i = 0; i < V; i++)\n        for (j = 0; j < V; j++)\n     distance[i][j] = graph[i][j];\n \nfor (k = 0; k < V; k++)\n for (i = 0; i < V; i++)\n         for (j = 0; j < V; j++)\n                {\n              if (distance[i][k] + distance[k][j] < distance[i][j])\n                  distance[i][j] = distance[i][k] + distance[k][j];\n \n                           return 0;\n                }\n\nd) None of the mentioned\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The number of nodes of height h in any n - element heap is __________., , Choices: ['A\\nh', 'B\\n2h', 'C\\nceil(n/2h)/', 'D\\nceil(n/2h+1)'], Answer: D\nceil(n/2h+1)"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. Algorithms like Floyd-Warshall and Dijkstra compute shortest paths.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In which of the following does a Directed Acyclic Word Graph finds its application in?\na) String Matching\nb) Number Sorting\nc) Manipulations on numbers\nd) Pattern Printing\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Where does a triply linked list contains an extra pointer in comparison to a doubly linked list?\na) Top of the node\nb) Bottom of the node\nc) Before the node\nd) After the node\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the Height of the root node of ternary tree?\na) 1\nb) 2\nc) 3\nd) 0\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Is MinHash used as a tool for association rule learning.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which traversal's pseudo code is written here?, , Choices: ['A\\nLevel order', 'B\\nPre-order', 'C\\nPost-order', 'D\\nIn-order'], Answer: A\nLevel order"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which operation is used to combine two auxiliary trees?\na) Join\nb) Combinatorial\nc) Add\nd) Concatenation\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A linear collection of data elements where the   linear node is given by means of pointer is called   ……   233. A linear collection of data elements where the   linear node is given by means of pointer is called   ……., , Choices: ['A\\nLinked list', 'B\\nNode list', 'C\\nPrimitive list', 'D\\nNone of these'], Answer: A\nLinked list"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are different ways of implementing free lists and which is simple among them?\na) best fit, first fit, worst fit, simple-first fit\nb) best fit, first fit, worst fit, simple-best fit\nc) best fit, first fit, worst fit, simple-worst fit\nd) best fit simple-best fit\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A single array A[1..MAXSIZE] is used to implement two stacks. The two stacks grow from opposite ends of the array. Variables top1 and top2 (topl< top 2) point to the location of the topmost element in each of the stacks. If the space is to be used efficiently, the condition for “stack full” is:, , Choices: ['A\\n(top1 = MAXSIZE/2) and (top2 = MAXSIZE/2+1)', 'B\\ntop1 + top2 + 1 = MAXSIZE', 'C\\n(top1= MAXSIZE/2) or (top2 = MAXSIZE)', 'D\\ntop1= top2 -1'], Answer: D\ntop1= top2 -1"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the maximum number of children that a binary tree node can have?\na) 0\nb) 1\nc) 2\nd) 3\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Out of the following given options, which is the fastest algorithm?\na) fibonacci heap\nb) pairing heap\nc) d-ary heap\nd) binary heap\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An expression tree is a kind of?\na) Binary search tree\nb) Fibonacci tree\nc) Binary tree\nd) Treap\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given that the line   \f delete newPtr;   226. Given that the line   delete newPtr;  just executed, what can you conclude?, , Choices: ['A\\nThe memory referenced by newPtr is released only if it is \\n needed by the system.', 'B\\nThe pointer newPtr is of type void *.', 'C\\nThe pointer newPtr only exists if there was an error \\n freeing the memory.', 'D\\nThe pointer newPtr still exists.'], Answer: D\nThe pointer newPtr still exists."
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "To implement a stack using queue(with only enqueue and dequeue operations), how many queues will you need?\na) 1\nb) 2\nc) 3\nd) 4\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The prefix expression of the postfix expression AB+CD-* is __________\na) (A+B)*(C-D)\nb) +AB*-CD\nc) A+*BCD-\nd) *+AB-CD\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which is the most appropriate data structure for applying balancing of symbols algorithm?\na) stack\nb) queue\nc) tree\nd) graph\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. Algorithms like Floyd-Warshall and Dijkstra compute shortest paths.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the maximum number of edges in a bipartite graph having 10 vertices?\na) 24\nb) 21\nc) 25\nd) 16\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Suffix array is space efficient than the suffix tree.\na) True\nb) Fasle\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. Algorithms like Floyd-Warshall and Dijkstra compute shortest paths.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "All paths and cyclic graphs are bipartite graphs.\na) True\nb) False\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The size of the dynamic array is deallocated if the array size is less than _________% of the backend physical size.\na) 30\nb) 40\nc) 10\nd) 20\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Time taken in decreasing the node value in a binomial heap is\na) O(n)\nb) O(1)\nc) O(logn)\nd) O(nlogn)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What determines the order of evaluation of a prefix expression?\na) precedence and associativity\nb) precedence only\nc) associativity only\nd) depends on the parser\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "One can convert an infix expression to a postfix   expression using a ……..., , Choices: ['A\\nStack', 'B\\nQueue', 'C\\nDeque', 'D\\nNone of these'], Answer: A\nStack"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are the applications of linear probing include:, , Choices: ['A\\nDatabases', 'B\\nCaching', 'C\\nCompiler Design', 'D\\nAll of the above'], Answer: D\nAll of the above"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The number of unused pointers in a complete   binary tree of depth 5 is:, , Choices: ['A\\n4', 'B\\n8', 'C\\n16', 'D\\n32'], Answer: C\n16"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following real world scenarios would you associate with a stack data structure?\na) piling up of chairs one above the other\nb) people standing in a line to be serviced at a counter\nc) offer services based on the priority of the customer\nd) tatkal Ticket Booking in IRCTC\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which scheme provides good performance?\na) open addressing\nb) universal hashing\nc) hashing by division\nd) hashing by multiplication\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Evaluate the postfix expression ab + cd/- where a=5, b=4, c=9, d=3.\na) 23\nb) 15\nc) 6\nd) 10\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A queue is a linear data structure that follows the First In First Out (FIFO) principle. It supports operations like enqueue (insert) and dequeue (remove), commonly used in scheduling and buffering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following operation along with Enqueue and Dequeue operations on queues, where k is a global parameter., , Choices: ['A\\nA', 'B\\nB', 'C\\nC', 'D\\nD'], Answer: A\nA"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "++a*bc*+defg is an?\na) postfix expression\nb) infix expression\nc) prefix expression\nd) invalid expression\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the space complexity for deleting a linked list?\na) O(1)\nb) O(n)\nc) Either O(1) or O(n)\nd) O(logn)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many prime concepts are available in nearest neighbour search in a kd tree?\na) 1\nb) 2\nc) 3\nd) 4\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a two-dimensional search tree, the root is arbitrarily chosen to be?\na) even\nb) odd\nc) depends on subtrees\nd) 1\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In general, linked lists allow: Choices: ['A\\nInsertions and removals anywhere.', 'B\\nInsertions and removals only at one end.', 'C\\nInsertions at the back and removals from the front.', 'D\\nNone of the above.'], Answer: A\nInsertions and removals anywhere."
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the array representation of a binary min-heap containing 1023 elements. The minimum number of comparisons required to find the maximum in the heap is _________ . , , Choices: ['A\\n510', 'B\\n511', 'C\\n512', 'D\\n255'], Answer: B\n511"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "When executing a sequence of Unions, a node of rank r must have at least 2r descendants.\na) true\nb) false\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the Prefix notation for the given equation?\n\na) -+a*/^bcdef\nb) -+a*/bc^def\nc) -+a*b/c^def\nd) -a+*/bc^def\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. Algorithms like Floyd-Warshall and Dijkstra compute shortest paths.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the maximum number of possible non zero values in an adjacency matrix of a simple graph with n vertices?\na) (n*(n-1))/2\nb) (n*(n+1))/2\nc) n*(n-1)\nd) n*(n+1)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A binary tree can be converted in to its mirror image by traversing it in ……..., , Choices: ['A\\nIn-order', 'B\\nPre-order', 'C\\nPost-order', 'D\\nAny order'], Answer: B\nPre-order"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Level order traversal of a tree is formed with the help of\na) breadth first search\nb) depth first search\nc) dijkstra’s algorithm\nd) prims algorithm\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is a disadvantage of parallel array over the traditional arrays?\na) When a language does not support records, parallel arrays can be used\nb) Increased locality of reference\nc) Ideal cache behaviour\nd) Insertion and Deletion becomes tedious\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the Height of the root node of K-ary tree?\na) 1\nb) 2\nc) 3\nd) 0\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the hash function used in the division method?\na) h(k) = k/m\nb) h(k) = k mod m\nc) h(k) = m/k\nd) h(k) = m mod k\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following operations does not destroy the leftist heap property?\na) insert\nb) merge\nc) delete\nd) swap\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The recurrence relation that arises in relation with the complexity of binary search is:, , Choices: ['A\\nT(n) = 2T(n/ 2) + k , where k is constant', 'B\\nT(n) = T(n / 2) + k , where k is constant', 'C\\nT(n) = T(n / 2) + log n', 'D\\nT(n) = T(n / 2) + n'], Answer: B\nT(n) = T(n / 2) + k , where k is constant"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the order of a matrix?\na) number of rows X number of columns\nb) number of columns X number of rows\nc) number of rows X number of rows\nd) number of columns X number of columns\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In what way the Symmetry Sparse Matrix can be stored efficiently?\na) Heap\nb) Binary tree\nc) Hash table\nd) Adjacency List\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. Algorithms like Floyd-Warshall and Dijkstra compute shortest paths.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A graph with n vertices will definitely have a   parallel edge or self loop if the total number of   edges are ………….., , Choices: ['A\\ngreater than n–1', 'B\\nless than n(n–1)', 'C\\ngreater than n(n–1)/2', 'D\\nless than n2/2'], Answer: A\ngreater than n–1"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time taken for a range query for a perfectly balanced tree?\na) O(N)\nb) O(log N)\nc) O(√N+M)\nd) O(√N)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Easy\nContext: String data structures represent sequences of characters. Operations include concatenation, substring search, slicing, and pattern matching, often used in text processing and compiler design.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the output of the following code?, #include <iostream>\nusing namespace std;\n\nint main()\n{\n\n    string str = \"Hello\";\n    cout << str.substr(2, 5);\n    return 0;\n}, Choices: ['A\\nSyntax error', 'B\\nello', 'C\\nllo', 'D\\nNone'], Answer: C\nllo"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Associative arrays can be implemented using __________\na) B-tree\nb) A doubly linked list\nc) A single linked list\nd) A self balancing binary search tree\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following data structure is used to convert postfix expression to infix expression?\na) Stack\nb) Queue\nc) Linked List\nd) Heap\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If -*+abcd = 11, find a, b, c, d using evaluation of prefix algorithm.\na) a=2, b=3, c=5, d=4\nb) a=1, b=2, c=5, d=4\nc) a=5, b=4, c=7,d=5\nd) a=1, b=2, c=3, d=4\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the functionality of the following code? Choose the most appropriate answer.\n\npublic int function()\n{\n if(head == null)\n  return Integer.MIN_VALUE;\n int var;\n Node temp = head;\n Node cur;\n while(temp.getNext() != head)\n {\n  cur = temp;\n  temp = temp.getNext();\n }\n if(temp == head)\n {\n  var = head.getItem();\n  head = null;\n  return var;\n }\n var = temp.getItem();\n cur.setNext(head);\n return var;\n}\n\na) Return data from the end of the list\nb) Returns the data and deletes the node at the end of the list\nc) Returns the data from the beginning of the list\nd) Returns the data and deletes the node from the beginning of the list\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In parse trees, every internal node represents a non-terminal and every leaf node represents a terminal.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The value of h2(k) can be composite relatively to the hash table size m.\na) True\nb) False\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Linked lists are not suitable data structures for   which one of the following problems?, , Choices: ['A\\nInsertion sort', 'B\\nBinary search', 'C\\nRadix sort', 'D\\nPolynomial manipulation'], Answer: B\nBinary search"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "11. Assuming int is of 4bytes, what is the size of int arr[15];?\na) 15\nb) 19\nc) 11\nd) 60\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is a valid heap ? , , Choices: ['A\\nA', 'B\\nB', 'C\\nC', 'D\\nD'], Answer: B\nB"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the other name for a postfix expression?\na) Normal polish Notation\nb) Reverse polish Notation\nc) Warsaw notation\nd) Infix notation\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the implementation of the ternary tree?\na) AVL Tree\nb) Ternary Heap\nc) Hash Table\nd) Dictionary\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the expected error for estimating the Jaccard index using MinHash scheme for k different hash functions?\na) O (log k!)\nb) O (k!)\nc) O (k2)\nd) O (1/k½)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Electrical connectivity is an example of equivalence relation.\na) true\nb) false\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The maximum number of binary trees that can be formed with three unlabelled nodes is:, , Choices: ['A\\n1', 'B\\n5', 'C\\n4', 'D\\n3'], Answer: B\n5"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Abstract syntax tree is an input to which phase of compiler?\na) Lexical analysis\nb) Syntax Analysis\nc) Semantic Analysis\nd) Intermediate code generation\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Who invented the MinHash technique?\na) Weiner\nb) Samuel F. B. Morse\nc) Friedrich Clemens Gerke\nd) Andrei Broder\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider a linked list of n elements. What is the   time taken to insert an element after an element   pointed by some pointer?, , Choices: ['A\\nO(1)', 'B\\nO(log2 n)', 'C\\nO(n)', 'D\\nO(n log2 n)'], Answer: A\nO(1)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A program to search a contact from phone directory can be implemented efficiently using ______\na) a BST\nb) a trie\nc) a balanced BST\nd) a binary tree\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which tree allows fast implementation of a set of string operation?\na) Rope Tree\nb) Tango Tree\nc) Generalized Suffix Tree\nd) Top Tree\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Easy\nContext: String data structures represent sequences of characters. Operations include concatenation, substring search, slicing, and pattern matching, often used in text processing and compiler design.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the output of the following code?, #include <iostream>\nusing namespace std;\n\nint main()\n{\n\n    string str1 = \"Hello\";\n    string str2 = \"Geeks\";\n    string str3 = str1 + str2;\n    cout << str3 << endl;\n\n    return 0;\n}, Choices: ['A\\nHello +  Geeks', 'B\\nstr1 + str2', 'C\\nHello Geeks', 'D\\nHelloGeeks'], Answer: D\nHelloGeeks"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the other name or Van Emde Boas Tree data structure?\na) Van Emde Boas Array\nb) Van Emde Boas Stack\nc) Van Emde Boas Priority Queue\nd) Van Emde Boas Heap\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which is the simplest of all binary search trees?\na) AVL tree\nb) Treap\nc) Splay tree\nd) Binary heap\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: Sorting algorithms arrange elements in a particular order (ascending or descending). Adaptive sorting algorithms improve performance when data is partially sorted.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An adaptive sorting algorithm ……….., , Choices: ['A\\nadapts to new computers', 'B\\ntakes advantage of already sorted elements', 'C\\ntakes input which is already sorted \\n (A) adapts to new computers \\n (B) takes advantage of already sorted elements \\n (C) takes input which is already sorted', 'D\\nNone of these'], Answer: B\ntakes advantage of already sorted elements"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not a disadvantage of bit array?\na) Without compression, they might become sparse\nb) Accessing individual bits is expensive\nc) Compressing bit array to byte/word array, the machine also has to support byte/word addressing\nd) Storing and Manipulating in the register set for long periods of time\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which tree allows fast implementation of a set of string operation?\na) Rope Tree\nb) Tango Tree\nc) Generalized Suffix Tree\nd) Top Tree\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Easy\nContext: String data structures represent sequences of characters. Operations include concatenation, substring search, slicing, and pattern matching, often used in text processing and compiler design.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the output of the following code?, #include <iostream>\nusing namespace std;\n\nint main()\n{\n\n    string str1 = \"Hello\";\n    string str2 = \"Geeks\";\n    string str3 = str1 + str2;\n    cout << str3 << endl;\n\n    return 0;\n}, Choices: ['A\\nHello +  Geeks', 'B\\nstr1 + str2', 'C\\nHello Geeks', 'D\\nHelloGeeks'], Answer: D\nHelloGeeks"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the other name or Van Emde Boas Tree data structure?\na) Van Emde Boas Array\nb) Van Emde Boas Stack\nc) Van Emde Boas Priority Queue\nd) Van Emde Boas Heap\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which is the simplest of all binary search trees?\na) AVL tree\nb) Treap\nc) Splay tree\nd) Binary heap\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: Sorting algorithms arrange elements in a particular order (ascending or descending). Adaptive sorting algorithms improve performance when data is partially sorted.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An adaptive sorting algorithm ……….., , Choices: ['A\\nadapts to new computers', 'B\\ntakes advantage of already sorted elements', 'C\\ntakes input which is already sorted \\n (A) adapts to new computers \\n (B) takes advantage of already sorted elements \\n (C) takes input which is already sorted', 'D\\nNone of these'], Answer: B\ntakes advantage of already sorted elements"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not a disadvantage of bit array?\na) Without compression, they might become sparse\nb) Accessing individual bits is expensive\nc) Compressing bit array to byte/word array, the machine also has to support byte/word addressing\nd) Storing and Manipulating in the register set for long periods of time\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The algorithm given is for deleting an element in an unrolled linked list. What should be the correct statement for the blank given below?\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the output of the following program?\n\nmain()  \n{  \n   char str[]=\"san foundry\";  \n   int len = strlen(str);  \n   int i;  \n \n   for(i=0;i<len;i++)  \n        push(str[i]);  // pushes an element into stack\n \n   for(i=0;i<len;i++)  \n      pop();  //pops an element from the stack\n}\n\na) sanfoundry\nb) san foundry\nc) yrdnuof nas\nd) foundry nas\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the node path length of a node with 0 or 1 child?\na) 1\nb) -1\nc) 0\nd) null\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "B Trees are generally, , Choices: ['A\\nvery deep and narrow', 'B\\nvery wide and shallow', 'C\\nvery deep and very wide', 'D\\ncannot say \\n (A) very deep and narrow \\n (B) very wide and shallow \\n (C) very deep and very wide \\n (D) cannot say'], Answer: D\ncannot say \n (A) very deep and narrow \n (B) very wide and shallow \n (C) very deep and very wide \n (D) cannot say"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following piece of 'C' code fragment that removes duplicates from an ordered list of integers., #include <stdio.h>\n\nNode *remove_duplicates(Node *head, int *j) {\n    Node *t1, *t2;\n    *j = 0;\n    t1 = head;\n    if (t1 != NULL) t2 = t1->next;\n    else return head;\n    *j = 1;\n    if (t2 == NULL)\n        return head;\n    while (t2 != NULL) {\n        if (t1->val != t2->val) { // S1\n            (*j)++; t1->next = t2; t1 = t2; // S2\n        }\n        t2 = t2->next;\n    }\n    t1->next = NULL;\n    return head;\n}, Choices: ['A\\n(a). n-1 times, since comparison is pairwise for n elements.\\n(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.\\n(C). j keeps count of distinct nodes in the list.', 'B\\n(a). n times, since comparison is pairwise for n elements.\\n(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.\\n(C). j keeps count of distinct nodes in the list.', 'C\\n(a). n-1 times, since comparison is pairwise for n elements.\\n(b). maximum : n-1 for all distinct elements, minimum: 1 for all same elements.\\n(C). j keeps count of distinct nodes in the list.', 'D\\nNone of the above'], Answer: A\n(a). n-1 times, since comparison is pairwise for n elements.\n(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.\n(C). j keeps count of distinct nodes in the list."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is an AVL tree?\na) a tree which is balanced and is a height balanced tree\nb) a tree which is unbalanced and is a height balanced tree\nc) a tree with three children\nd) a tree with atmost 3 children\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider an implementation of unsorted singly linked list. Suppose it has its representation with a head pointer only. Given the representation, which of the following operation can be implemented in O(1) time?\n\na) I and II\nb) I and III\nc) I, II and III\nd) I, II and IV\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the use of the bin data structure?\na) to have efficient insertion\nb) to have efficient deletion\nc) to have efficient region query\nd) to have efficient traversal\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "To convert the postfix expression into the infix expression we use stack and scan the postfix expression from left to right.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: Sorting algorithms arrange elements in a particular order (ascending or descending). Adaptive sorting algorithms improve performance when data is partially sorted.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "You have to sort a list L consisting of a sorted   list followed by a few “random” elements.   Which of the following sorting methods would be   especially suitable for such a task?, , Choices: ['A\\nBubble sort', 'B\\nSelection sort', 'C\\nQuick sort', 'D\\nInsertion sort'], Answer: D\nInsertion sort"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In Breadth First Search of Graph, which of the   following data structure is used?, , Choices: ['A\\nStack', 'B\\nQueue', 'C\\nLinked List', 'D\\nNone of the above'], Answer: B\nQueue"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the load factor?\na) Average array size\nb) Average key size\nc) Average chain length\nd) Average hash table length\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Why the below pseudo code where x is a value, wt is weight factor and t is root node can’t insert?\n\na) when x>t. element Rotate-with-left-child should take place and vice versa\nb) the logic is incorrect\nc) the condition for rotating children is wrong\nd) insertion cannot be performed in weight balanced trees\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which pattern is used to evaluate abstract syntax tree?\na) Visitor pattern\nb) Singleton Pattern\nc) Proxy pattern\nd) Adapter pattern\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Five node splitting operations occurred when an entry is inserted into a B-tree. Then how many nodes are written?\na) 14\nb) 7\nc) 11\nd) 5\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is an advantage of parallel arrays?\na) Poor locality of reference for non-sequential access\nb) Very little direct language support\nc) Expensive to shrink or grow\nd) Increased Locality of Reference\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider B+ tree in which the search key is 12 bytes long, block size is 1024 bytes, record pointer is 10 bytes long and block pointer is 8 bytes long. The maximum number of keys that can be accommodated in each non-leaf node of the tree is, , Choices: ['A\\n49', 'B\\n50', 'C\\n51', 'D\\n52'], Answer: B\n50"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Recursive procedures are implemented by   using ………….. data structure., , Choices: ['A\\nqueues', 'B\\nstacks', 'C\\nlinked lists', 'D\\nstrings'], Answer: B\nstacks"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Can child node be always called Leaf node in the K-ary tree?\na) True\nb) False\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A balance factor in AVL tree is used to check   ……….., , Choices: ['A\\nwhat rotation to make.', 'B\\nif all child nodes are at same level.', 'C\\nwhen the last rotation occurred.', 'D\\nif the tree is unbalanced.'], Answer: D\nif the tree is unbalanced."
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the Prefix notation and Postfix notation for the given equation?\n\na) ++ABC and AB+C+\nb) AB+C+ and ++ABC\nc) ABC++ and AB+C+\nd) ABC+ and ABC+\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "For how many vertices in a set, is top tree defined for underlying tree?\na) 3\nb) 4\nc) 5\nd) 2\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Quick sort running time depends on the   selection of ……….., , Choices: ['A\\nsize of array', 'B\\npivot element', 'C\\nsequence of values', 'D\\nnone of the above'], Answer: B\npivot element"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which type of binary search tree is imitated for construction of tango tree?\na) Complete Binary Search Tree\nb) Perfect Binary Search Tree\nc) Balanced Binary Search Tree\nd) Degenerate Binary Search Tree\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In order traversal of binary search tree will   produce ………., , Choices: ['A\\nunsorted list \\n (A) unsorted list', 'B\\nreverse of input', 'C\\nsorted list', 'D\\nnone of the above'], Answer: C\nsorted list"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Reversing a word using stack can be used to find if the given word is a palindrome or not.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Assume there is a free list which contains nodes and is filled with a value if it is already assigned and the value will be the size of requested block else will be 0.\n\nThe above code represents what?\na) code for first fit\nb) code for best fit\nc) code for worst fit\nd) none of the mentioned\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The number of items used by the dynamic array contents is its __________\na) Physical size\nb) Capacity\nc) Logical size\nd) Random size\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Suppose, in a triply linked list, the elements 2, 3, 3, 5, 5, 5 and 6 are inserted in the given sequence. To which of the following elements will the top pointer point, if the linked list is traversed starting from the head?\na)\n2\n3top→3\n5top→5\n5top→6\n\nb)\n2top→3\n3top→5\n5\n5top→6\n\nc)\n2\n3top→3\n5top→5top→5\n6\n\nd)\n2top→3top→3top→5\n5\n5\n6"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "___________ is not a theoretical problem but actually occurs in real implementations of probing.\na) Hashing\nb) Clustering\nc) Rehashing\nd) Collision\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given the Node class implementation, select one of the following that correctly inserts a node at the tail of the list.\n\npublic class Node\n{\n protected int data;\n protected Node prev;\n protected Node next;\n public Node(int data)\n {\n  this.data = data;\n  prev = null;\n  next = null;\n }\n public Node(int data, Node prev, Node next)\n {\n  this.data = data;\n  this.prev = prev;\n  this.next = next;\n }\n public int getData()\n {\n  return data;\n }\n public void setData(int data)\n {\n  this.data = data;\n }\n public Node getPrev()\n {\n  return prev;\n }\n public void setPrev(Node prev)\n {\n  this.prev = prev;\n }\n public Node getNext()\n {\n  return next;\n }\n public void setNext(Node next)\n {\n  this.next = next;\n }\n}\npublic class DLL\n{\n protected Node head;\n protected Node tail;\n int length;\n public DLL()\n {\n  head = new Node(Integer.MIN_VALUE,null,null);\n  tail = new Node(Integer.MIN_VALUE,null,null);\n  head.setNext(tail);\n  length = 0;\n }\n}\npublic void insertRear(int data)\n{\n Node node = new Node(data,tail.getPrev(),tail);\n node.getPrev().setNext(node);\n tail.setPrev(node);\n length++;\n}\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A queue is a linear data structure that follows the First In First Out (FIFO) principle. It supports operations like enqueue (insert) and dequeue (remove), commonly used in scheduling and buffering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the output of the following Java code?\n\npublic class CircularQueue\n{\n // class definition omitted for brevity\n}\npublic class CircularQueueDemo\n{\n public static void main(String args[])\n {\n  Object var;\n  CircularQueue myQ = new CircularQueue();\n  myQ.enqueue(10);\n  myQ.enqueue(3);\n  var = myQ.rearElement();\n  myQ.dequeue();\n  myQ.enqueue(6);\n  var = myQ.frontElement();\n  System.out.println(var+\" \"+var);\n }\n}\n\na) 3 3\nb) 3 6\nc) 6 6\nd) 10 6\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Fill in the blanks for completing the program to rotate an array by d elements., /*Function to left rotate arr[] of size n by d*/\nvoid Rotate(int arr[], int d, int n)\n{\n    int p = 1;\n    while (_______) {\n        int last = arr[0];\n        for (int i = 0; ______ i++) {\n            arr[i] = arr[i + 1];\n        }\n        __________\n        p++;\n    }\n}, Choices: ['A\\np <= d , i < n - 1 , arr[n - 1] = last;', 'B\\np < d, i < n, arr[n] = last;', 'C\\np >=d, i >n , arr[n] =  last', 'D\\nNone'], Answer: A\np <= d , i < n - 1 , arr[n - 1] = last;"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following has search efficiency of   Ω(1)?, , Choices: ['A\\nTree', 'B\\nHeap', 'C\\nHash Table', 'D\\nLinked-List'], Answer: C\nHash Table"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which type of binary search tree or algorithm does tango tree use?\na) Online\nb) Offline\nc) Static\nd) Dynamic\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Dijkstra’s Algorithm will work for both negative and positive weights?\na) True\nb) False\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the auxiliary space complexity of the code to rotate an array by using the reversal algorithm (d = number of rotations)?\na) O(1)\nb) O(n)\nc) O(d)\nd) O(n*d)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not an advantage of trees?, , Choices: ['A\\nHierarchical structure', 'B\\nFaster search', 'C\\nRouter algorithms', 'D\\nUndo/Redo operations in a notepad'], Answer: D\nUndo/Redo operations in a notepad"
  },
  {
    "input_text": "Topic: String\nDifficulty: Easy\nContext: String data structures represent sequences of characters. Operations include concatenation, substring search, slicing, and pattern matching, often used in text processing and compiler design.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How does strcmp() function work to compare two strings?, , Choices: ['A\\nIt compares characters based on their index.', 'B\\nIt compares strings based on the index.', 'C\\nIt compares characters of the string based on their ASCII values.', 'D\\nNone.'], Answer: C\nIt compares characters of the string based on their ASCII values."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Is Top tree used for maintaining Dynamic set of trees called forest.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Accessing free list very frequently for wide range of addresses can lead to\na) paging\nb) segmentation fault\nc) memory errors\nd) cache problems\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Express -15 as a 6-bit signed binary number.\na) 001111\nb) 101111\nc) 101110\nd) 001110\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider an implementation of unsorted single linked list. Suppose it has its representation with a head and a tail pointer (i.e. pointers to the first and last nodes of the linked list). Given the representation, which of the following operation can not be implemented in O(1) time ?, , Choices: ['A\\nInsertion at the front of the linked list.', 'B\\nInsertion at the end of the linked list.', 'C\\nDeletion of the front node of the linked list.', 'D\\nDeletion of the last node of the linked list.'], Answer: D\nDeletion of the last node of the linked list."
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. Algorithms like Floyd-Warshall and Dijkstra compute shortest paths. Topological sorting applies to Directed Acyclic Graphs (DAGs).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the given statement is true?\na) All the Cyclic Directed Graphs have topological sortings\nb) All the Acyclic Directed Graphs have topological sortings\nc) All Directed Graphs have topological sortings\nd) All the cyclic directed graphs hace non topological sortings\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The result evaluating the postfix expression 10 5 + 60 6 / * 8 – is, , Choices: ['A\\n284', 'B\\n213', 'C\\n142', 'D\\n71'], Answer: C\n142"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is direct addressing?\na) Distinct array position for every possible key\nb) Fewer array positions than keys\nc) Fewer keys than array positions\nd) Same array position for all keys\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a binary tree, for every node the difference between the number of nodes in the left and right subtrees is at most 2. If the height of the tree is h > 0, then the minimum number of nodes in the tree is:, , Choices: ['A\\n2h - 1', 'B\\n2h - 1 + 1', 'C\\n2h - 1', 'D\\n2h'], Answer: B\n2h - 1 + 1"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where elements are stored in nodes, each containing a reference to the next. Variants like singly, doubly, and triply linked lists vary by the number of pointers per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "9. Which of the following statement(s) about stack data structure is/are NOT correct?\na) Top of the Stack always contain the new node\nb) Stack is the FIFO data structure\nc) Null link is present in the last node at the bottom of the stack\nd) Linked List are used for implementing Stacks\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the range of β in finding the length of the longest path in a randomized binary search tree?\na) (-1, 0)\nb) (1, 0)\nc) (0, 5)\nd) (0, 1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Choose the code which performs the store operation in a sparse array.(Linked list implementation)\na)\n\npublic void store(int index, Object val) { ... }\n\n... [code options truncated for brevity] ...\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. Algorithms like Floyd-Warshall and Dijkstra compute shortest paths. Simple graphs do not allow loops or multiple edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following properties does a simple graph not hold?\na) Must be connected\nb) Must be unweighted\nc) Must have no loops or multiple edges\nd) Must have no multiple edges\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Tree data structures also include randomized types like treaps, which combine binary search trees with heap properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Who invented treaps?\na) Cecilia and Raimund\nb) Arne Andersson\nc) Donald Shell\nd) Harris and Ross\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If A[x+3][y+5] represents an adjacency matrix, which of these could be the value of x and y.\na) x=5, y=3\nb) x=3, y=5\nc) x=3, y=3\nd) x=5, y=5\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Can leaf node be called child node in a K-ary tree?\na) True\nb) false\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A queue is a linear data structure that follows the First In First Out (FIFO) principle. It supports operations like enqueue (insert) and dequeue (remove), commonly used in scheduling and buffering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given a queue with a linked list implementation. the Rear pointer points to the rear node of the queue. and the front node of the queue points to the front node of the queue, Which of the following operations is impossible to do in O(1) time?\n , , Choices: ['A\\nDelete the front item from the list.', 'B\\nDelete the rear from the list.', 'C\\ninsert at the front of the list.', 'D\\nNone'], Answer: B\nDelete the rear from the list."
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many stacks are required for evaluation of prefix expression?\na) one\nb) two\nc) three\nd) four\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees. AA-trees are a balanced binary search tree variant using skew and split operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In an AA-tree, we process split first, followed by a skew.\na) True\nb) False\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Path Compression algorithm performs in which of the following operations?\na) Create operation\nb) Insert operation\nc) Find operation\nd) Delete operation\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given an array of element 5, 7, 9, 1, 3, 10, 8, 4. Which of the following are the correct sequences of elements after inserting all the elements in a min-heap?\na) 1,3,4,5,7,8,9,10\nb) 1,4,3,9,8,5,7,10\nc) 1,3,4,5,8,7,9,10\nd) 1,3,7,4,8,5,9,10\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and collision handling techniques such as open addressing and separate chaining are key to practical implementations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are the methods to handle  collision: , , Choices: ['A\\nSeparate Chaining ', 'B\\nOpen Chaining ', 'C\\nBoth of the above', 'D\\nNone of the above'], Answer: C\nBoth of the above"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Parse trees, especially in compiler design, represent the syntactic structure of strings. Nodes may be evaluated using rule-based grammars.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Suppose X is the starting symbol of the given grammar with the following transition rules. Compute the value of X as the root of the parse tree for the expression: 3 & 4 % 7.\nX → X1 & B | B {X.value = X1.value + B.value, X.value = B.value}\nB → B1 % D | D {B.value = B1.value * D.value, B.value = D.value}\nD → num {D.value = num.value}\na) 31\nb) 32\nc) 33\nd) 34\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be used to compute mathematical operations such as binary conversion or expression evaluation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Using stacks, how to obtain the binary representation of the number?\na)\n\npublic void convertBinary(int num) { ... }\n\n... [code options truncated for brevity] ...\n\nd)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not the rearranging method used to implement self-organizing lists?\na) count method\nb) move to front method\nc) ordering method\nd) least frequently used\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. Algorithms like Floyd-Warshall and Dijkstra compute shortest paths.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of these adjacency matrices represents a simple graph?\na) [ [1, 0, 0], [0, 1, 0], [0, 1, 1] ]\nb) [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]\nc) [ [0, 0, 1], [0, 0, 0], [0, 0, 1] ]\nd) [ [0, 0, 1], [1, 0, 1], [1, 0, 0] ]\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following can be called a parallel array implementation?\na)\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. Sparse arrays are used when most elements are zero and can be optimized in memory by only storing non-zero entries.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "When do you use a sparse array?\na) When there are unique elements in the array\nb) When the array has more occurrence of zero elements\nc) When the data type of elements differ\nd) When elements are sorted\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: The incidence matrix of a connected graph has a rank that depends on the number of vertices and the structure of the graph. For a connected graph with n vertices, the rank is at most n−1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If a connected Graph (G) contains n vertices what would be the rank of its incidence matrix?\na) n-1\nb) values greater than n are possible\nc) values less than n-1 are possible\nd) insufficient Information is given\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The Bellman-Ford algorithm is used for finding the shortest paths from a source vertex to all other vertices in a graph. It is capable of handling graphs with negative weights.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following statement(s)is / are correct regarding Bellman-Ford shortest path algorithm?, , Choices: ['A\\nP Only', 'B\\nQ Only', 'C\\nBoth P and Q', 'D\\nNeither P nor Q'], Answer: B\nQ Only"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Who proposed the concept of Suffix Tree?\na) Weiner\nb) Samuel F. B. Morse\nc) Friedrich Clemens Gerke\nd) Alexander Morse\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the average retrieval time when n keys hash to the same slot?\na) Theta(n)\nb) Theta(n2)\nc) Theta(nlog n)\nd) Big-Oh(n2)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Algorithms for dynamic programming and greedy strategies are often used in jump games and path finding.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the output of the following code?\n... [C++ code truncated for brevity] ...\na) 1\nb) 2\nc) 3\nd) error\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. JavaScript provides many built-in array methods, including reverse(), sort(), and slice().\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the predefined function for array reversal in javascript?\na) reverse()\nb) arr_reverse()\nc) array_reverse()\nd) rev()\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: Queues are FIFO data structures. Linked list implementations use front and rear pointers to support O(1) insertions and deletions from respective ends.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following can be used to delete an element from the front end of the queue?\na)\n\npublic Object deleteFront() throws emptyDEQException { ... }\n\n... [code options truncated for brevity] ...\n\nd)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The best average behaviour is shown by:, , Choices: ['A\\nQuick Sort', 'B\\nMerge Sort', 'C\\nInsertion Sort', 'D\\nHeap Sort'], Answer: A\nQuick Sort"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. The degree sum formula for undirected graphs states that the sum of degrees equals twice the number of edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "For an undirected graph with n vertices and e   edges, the sum of the degree of each vertex is equal   to:, , Choices: ['A\\n2n', 'B\\n(2n-1)/2', 'C\\n2e', 'D\\ne2/2'], Answer: C\n2e"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A weight-balanced tree is a binary tree in which each node maintains balance based on subtree sizes. The height of such trees can be bounded using logarithmic relationships.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A weight-balanced tree is a binary tree in which for each node. The number of nodes in the left sub tree is at least half and at most twice the number of nodes in the right sub tree. The maximum possible height (number of nodes on the path from the root to the farthest leaf) of such a tree on n nodes is best described by which of the following? a) \\log_2 n b) \\log_{4/3} n c) \\log_3 n d) \\log_{3/2} n, , Choices: ['A\\nA', 'B\\nB', 'C\\nC', 'D\\nD'], Answer: D\nD"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: The adjacency matrix of a graph with n vertices is an n x n matrix. Each entry indicates the presence or absence of an edge.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The number of elements in the adjacency matrix of a graph having 7 vertices is __________\na) 7\nb) 14\nc) 36\nd) 49\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In theory, prefix expressions (also known as Polish notation) are written with operators preceding operands and can be evaluated using a stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the Prefix notation for the given equation?\n\na) |&-+ab/cdef\nb) &|-+ab/cdef\nc) |&-ab+/cdef\nd) |&-+/abcdef\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In graph theory, a cycle in a connected undirected graph can be formed only when the number of edges exceeds the number of vertices by at least one.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Let G be a connected undirected graph with n vertices and m edges. Which of the following statements is true regarding the minimum number of edges required to create a cycle in G?\n , , Choices: ['A\\nThe minimum number of edges required to create a cycle is n.', 'B\\nThe minimum number of edges required to create a cycle is n - 1.', 'C\\nThe minimum number of edges required to create a cycle is m - n + 1.', 'D\\nThe minimum number of edges required to create a cycle is m - n + 2.'], Answer: B\nThe minimum number of edges required to create a cycle is n - 1."
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions, and the probability of collisions can be analyzed using principles from probability theory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The goal of hashing is to produce a search that   takes ………., , Choices: ['A\\nO(1) time', 'B\\nO(n2) time', 'C\\nO(log n) time', 'D\\nO(n log n) time'], Answer: A\nO(1) time"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: Sorting algorithms arrange elements in a particular order (ascending or descending). Binary search, which is used on sorted data, reduces the search space logarithmically.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A sorted file contains 16 items. Using binary   search, the maximum number of comparisons to   search for an item in this file is ……….., , Choices: ['A\\n15', 'B\\n8', 'C\\n1', 'D\\n4'], Answer: B\n4"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Trees represent hierarchical structures. In certain graph-tree transformations or path queries, complexity depends on the structure. Some algorithms can achieve O(m+n) performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "O(m2 + n2), , Choices: ['A\\nO(m+n)', 'B\\nO(mlogn)', 'C\\nO(nlogm)', 'D\\nO(m2 + n2)'], Answer: A\nO(m+n)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A B+ tree is a type of self-balancing search tree where all records are stored at the leaf level and internal nodes only store keys. It remains balanced because the paths from the root to all leaves are of the same length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "B+ Trees are considered BALANCED because, , Choices: ['A\\nthe lengths of the paths from the root to all leaf nodes are all equal.', 'B\\nthe lengths of the paths from the root to all leaf nodes differ from each other by at most 1.', 'C\\nthe number of children of any two non-leaf sibling nodes differ by at most 1.', 'D\\nthe number of records in any two leaf nodes differ by at most 1.'], Answer: A\nthe lengths of the paths from the root to all leaf nodes are all equal."
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where each element is stored in a node containing a pointer to the next node. Searching through a linked list is a linear-time operation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Linked list search complexity is …………, , Choices: ['A\\nΩ(1)', 'B\\nΩ(n)', 'C\\nΩ(log n)', 'D\\nΩ(log log n)'], Answer: B\nΩ(n)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Trees are used to represent data with hierarchical relationships and have various types such as binary trees, AVL trees, and B-trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A binary search tree contains values 7, 8, 13, 26, 35, 40, 70, 75. Which one of the following is a valid post-order sequence of the tree provided the pre-order sequence as 35, 13, 7, 8, 26, 70, 40 and 75?\na) 7, 8, 26, 13, 75, 40, 70, 35\nb) 26, 13, 7, 8, 70, 75, 40, 35\nc) 7, 8, 13, 26, 35, 40, 70, 75\nd) 8, 7, 26, 13, 40, 75, 70, 35"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the limitation of the array?, , Choices: ['A\\nelements can be accessed from anywhere.', 'B\\nThe size of the array is fixed.', 'C\\nIndexing is started from Zero.', \"D\\nMemory waste if an array's elements are smaller than the size allotted to them\"], Answer: D\nMemory waste if an array's elements are smaller than the size allotted to them"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs can be represented using adjacency matrices or lists. Matrix representations offer efficient lookups at the cost of higher space complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is an advantage of matrices?\na) Internal complexity\nb) Searching through a matrix is complex\nc) Not space efficient\nd) Graph Plotting\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Circular arrays allow rotation or wrapping around of elements and are useful in problems like buffer cycling and rotation tasks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the below program, and what is doing this program basically?, #include <bits/stdc++.h>\nusing namespace std;\n\nvoid print(char a[], int n, int ind)\n{\n    for (int i = ind; i < n + ind; i++)\n        cout << a[(i % n)] << \" \";\n}\n\nint main()\n{\n    char a[] = { 'A', 'B', 'C', 'D', 'E', 'F' };\n    int n = sizeof(a) / sizeof(a[0]);\n    print(a, n, 3);\n    return 0;\n}, Choices: ['A\\nIt is printing the normal array', 'B\\nIt is printing circular array rotated by 3', 'C\\nSyntax error', 'D\\nNone'], Answer: B\nIt is printing circular array rotated by 3"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where each element is stored in a node containing a pointer to the next. Trie data structures, though tree-based, can outperform linked lists and BSTs for dictionary word searches.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the efficient data structure for searching words in dictionaries?\na) BST\nb) Linked List\nc) Balancded BST\nd) Trie\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The following postfix expression with single digit operands is evaluated using a stack:, , Choices: ['A\\n6, 1', 'B\\n5, 7', 'C\\n3, 2', 'D\\n1, 5'], Answer: A\n6, 1"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays are linear data structures that store elements in contiguous memory locations. They allow indexed access, but resizing and dynamic operations can be inefficient compared to other structures like lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the minimum number of jumps required to reach the end of the array arr[] ={0,1,3,6,3,6,8,5}?\na) 1\nb) 2\nc) 3\nd) not possible to reach the end\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure used in expression evaluation, symbol balancing, and function call tracking. It operates on the LIFO principle.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not an application of stack?\na) evaluation of postfix expression\nb) conversion of infix to postfix expression\nc) balancing symbols\nd) line at ticket counter\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays support multiple operations, but the performance of stack/queue simulation using arrays can differ in terms of complexity, especially with dequeue operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider you have an array of some random size. You need to perform dequeue operation. You can perform it using stack operation (push and pop) or using queue operations itself (enQueue and Dequeue). The output is guaranteed to be same. Find some differences?\na) They will have different time complexities\nb) The memory used will not be different\nc) There are chances that output might be different\nd) No differences\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A doubly linked list is a variation of linked list in which each node contains pointers to both the next and the previous node, making bidirectional traversal possible.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In doubly linked lists:, , Choices: ['A\\na pointer is maintained to store both next and previous \\n nodes.', 'B\\ntwo pointers are maintained to store next and previous \\n nodes.', 'C\\na pointer to self is maintained for each node.', 'D\\nnone of these'], Answer: B\ntwo pointers are maintained to store next and previous \n nodes."
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A linked list is a linear data structure where each node contains data and a reference to the next node. In a queue implemented using a linked list, new elements are typically added at the tail (rear).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In linked list implementation of a queue, where does a new element be inserted?\na) At the head of link list\nb) At the centre position in the link list\nc) At the tail of the link list\nd) At any position in the linked list\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A queue is a linear data structure that follows the First In First Out (FIFO) principle. It supports operations like enqueue (insert) and dequeue (remove), commonly used in scheduling and buffering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A priority queue can efficiently implemented using which of the following data structures? Assume that the number of insert and peek (operation to see the current highest priority item) and extraction (remove the highest priority item) operations are almost same., , Choices: ['A\\nArray', 'B\\nLinked List', 'C\\nHeap Data Structures like Binary Heap, Fibonacci Heap', 'D\\nNone of the above'], Answer: C\nHeap Data Structures like Binary Heap, Fibonacci Heap"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a weight-balanced tree, the left and right subtrees of each node must maintain specific size constraints. This affects the tree's height, which grows logarithmically based on the subtree ratio.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider a weight balanced tree such that, the number of nodes in the left sub tree is at least half and at most twice the number of nodes in the right sub tree. The maximum possible height (number of nodes on the path from the root to the farthest leaf) of such a tree on k nodes can be described as\na) log2 n\nb) log4/3 n\nc) log3 n\nd) log3/2 n\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Tree rotations are used in AVL trees to restore balance after insertions and deletions. Height updates are necessary after a rotation to maintain the AVL property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the below left-left rotation pseudo code where the node contains value pointers to left, right child nodes and a height value and Height() function returns height value stored at a particular node.\n\nWhat is missing?\na) Height(w-left), x-height\nb) Height(w-right), x-height\nc) Height(w-left), x\nd) Height(w-left)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A B-tree is a self-balancing tree data structure. During insertions, a node may split if it exceeds its capacity. The number of splits depends on how often insertions cause overflow.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A B-tree of order 4 is built from scratch by 10 successive insertions. What is the maximum number of node splitting operations that may take place?, , Choices: ['A\\n3', 'B\\n4', 'C\\n5', 'D\\n6'], Answer: C\n5"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A heap is a binary tree where each node follows a specific heap property. In a min-heap, each parent is less than or equal to its children. In a max-heap, the opposite is true.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The ascending heap property is ___________\na) A[Parent(i)] =A[i]\nb) A[Parent(i)] <= A[i]\nc) A[Parent(i)] >= A[i]\nd) A[Parent(i)] > 2 * A[i]\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Graphs are collections of nodes connected by edges. They can be directed or undirected and are used to model pairwise relations. The incidence matrix of a simple graph has columns that sum to 2 for each edge.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The column sum in an incidence matrix for a simple graph is __________\na) depends on number of edges\nb) always greater than 2\nc) equal to 2\nd) equal to the number of edges\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Efficient hashing minimizes collisions. Double hashing is an open addressing technique that reduces clustering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Double hashing is one of the best methods available for open addressing.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A queue is a linear data structure that follows the First In First Out (FIFO) principle. Common operations include enqueue (insertion), dequeue (removal), and peek (access front without removing).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is NOT a common operation in a queue data structure? , , Choices: ['A\\nEnqueue ', 'B\\nDequeue ', 'C\\nPeek ', 'D\\nShuffle '], Answer: D\nShuffle"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Inversions in an array occur when a pair of elements is out of order. Counting inversions is useful in analyzing sorting algorithms like merge sort.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following form inversion in the array arr = {1,5,4,2}?\na) (5,4), (5,2)\nb) (5,4), (5,2), (4,2)\nc) (1,5), (1,4), (1,2)\nd) (1,5)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A Cartesian tree is a binary tree derived from a sequence of numbers. It satisfies the heap property and its in-order traversal yields the original sequence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a Cartesian tree?\na) a skip list in the form of tree\nb) a tree which obeys cartesian product\nc) a tree which obeys heap property and whose inorder traversal yields the given sequence\nd) a tree which obeys heap property only\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a heap data structure, a binary heap can be of two types: max-heap and min-heap. Operations like insertion, deletion, and finding the minimum/maximum element have specific time complexities depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In what time can a leftist heap be built?\na) O(N)\nb) O(N log N)\nc) O(log N)\nd) O(M log N)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. A full K-ary tree and a complete K-ary tree may differ in the distribution of their children, leading to a difference in node counts.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many extra nodes are there in Full K-ary tree than complete K-ary tree?\na) 1\nb) 2\nc) 3\nd) Both have same number of nodes\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Suffix trees are used in string matching and compression. Farach’s algorithm is one of the linear-time algorithms that can construct suffix trees efficiently, especially in external memory settings.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Who among the following algorithm is used in external memory and compression of the suffix tree?\na) Weiner’s algorithm\nb) Farach’s algorithm\nc) Ukkonen’s algorithm\nd) Alexander Morse\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: Queues are FIFO data structures, but self-balancing binary search trees can be used for efficient implementations of priority queues due to ordered access and rebalancing features.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A self – balancing binary search tree can be used to implement ________\na) Priority queue\nb) Hash table\nc) Heap sort\nd) Priority queue and Heap sort\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: An equivalence relation must be reflexive, symmetric, and transitive. Two-way connections are needed to satisfy the symmetry property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the condition for an equivalence relation if two cities are related within a country?\na) the two cities should have a one-way connection\nb) the two cities should have a two-way connection\nc) the two cities should be in different countries\nd) no equivalence relation will exist between two cities\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Stacks can be implemented using arrays or linked lists. Stacks follow LIFO (Last In First Out) behavior, unlike queues which follow FIFO.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following statements about stacks   is incorrect?, , Choices: ['A\\nStacks can be implemented using linked lists.', 'B\\nStacks are first-in, first-out (FIFO) data structures.', 'C\\nNew nodes can only be added to the top of the stack.', 'D\\nThe last node (at the bottom) of a stack has a null (0) \\n link. \\n (D) The last node (at the bottom) of a stack has a null (0) \\n link.'], Answer: B\nStacks are first-in, first-out (FIFO) data structures."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. AVL trees and 2-3 trees are both self-balancing, but they differ in how they manage balance and insertion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "AVL trees provide better insertion the 2-3 trees.\na) True\nb) False\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In the given C snippet, find the statement number that has error.\n\n//C code to push an element into a stack\n1. void push( struct stack *s, int x) \n2. {\n3.     if(s->top==MAX-1)\n4.     {\n5.         printf(\"stack overflow\");\n6.     }\n7.     else\n8.     {\n9.         s->items[++s->top]=x;\n10.        s++;\n11.    }   \n12. }\n\na) 1\nb) 9\nc) 10\nd) 11\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In propositional logic, directed acyclic graphs (DAGs) can represent expressions and computations. Leaves in such graphs may represent boolean constants or variables.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a Propositional Directed Acyclic Graph Leaves maybe labelled with a boolean variable.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: AVL trees are height-balanced binary search trees. The difference in height between left and right subtrees of every node is at most 1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In ………., the difference between the height of   the left sub tree and height of the right tree, for each   node, is almost one., , Choices: ['A\\nBinary search tree', 'B\\nAVL – tree', 'C\\nComplete tree', 'D\\nThreaded binary tree'], Answer: B\nAVL – tree"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Stack operations modify the top index. Incorrect modification (e.g., post-increment instead of pre-decrement) can result in logical errors during pop.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Find the error (if any) in the following code snippet for pop operation.\n\nvoid pop() //removing an element from a stack\n{\n     printf(\"%s\", stack[top++]);\n}\n\na) run time error\nb) compile time error\nc) pop operation is performed, but top moved in wrong direction\nd) pop operation is performed properly\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Binary Search Trees (BSTs) are created by placing elements such that left children are smaller and right children are larger. The number of BSTs that can be made from n distinct elements is given by the Catalan number: (1/(n+1)) * C(2n, n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "We are given a set of n distinct elements and an unlabelled binary tree with n nodes. In how many ways can we populate the tree with the given set so that it becomes a binary search tree? (GATE CS 2011), , Choices: ['A\\n0', 'B\\n1', 'C\\nn!', 'D\\n(1/(n+1)).2nCn'], Answer: D\n(1/(n+1)).2nCn"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Easy\nContext: Searching algorithms are used to retrieve data from structures. Binary search is an efficient method to find elements in sorted arrays with time complexity O(log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The complexity of searching an element from a   set of n elements using Binary search algorithm is   ………., , Choices: ['A\\nO(n)', 'B\\nO(log n)', 'C\\nO(n2)', 'D\\nO(n log n)'], Answer: B\nO(log n)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A full binary tree can be uniquely constructed using both preorder and postorder traversals. One traversal alone is not sufficient.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A full binary tree can be generated using ______\na) post-order and pre-order traversal\nb) pre-order traversal\nc) post-order traversal\nd) in-order traversal\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A full ternary tree is one where every node has either 0 or 3 children. A complete ternary tree is filled level by level, but may not fill the last level entirely.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many extra nodes are there in Full ternary tree than a complete ternary tree?\na) 1\nb) 2\nc) 3\nd) Both have same number of nodes\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A pairing heap is a type of heap-ordered multiway tree. It supports many priority queue operations efficiently and is simpler to implement than Fibonacci heaps.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How is a pairing heap represented?\na) binary tree\nb) fibonacci tree\nc) heap ordered tree\nd) treap\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following program:, #include <iostream>\n#include <cctype>\n#include <stack>\n\n#define EOF -1\n\nstd::stack<int> s;\n\nvoid push(int value) { s.push(value); } /* push the argument on the stack */\nint pop(void) { if (s.empty()) return EOF; int value = s.top(); s.pop(); return value; }  /* pop the top of the stack */\nvoid flagError() { std::cerr << \"Error!\" << std::endl; exit(1); }\n\nint main() {\n    int c, m, n, r;\n    while ((c = std::cin.get()) != EOF) {\n        if (isdigit(c))\n            push(c - '0');\n        else if ((c == '+') || (c == '*')) {\n            m = pop();\n            n = pop();\n            r = (c == '+') ? n + m : n * m;\n            push(r);\n        } else if (c != ' ')\n            flagError();\n    }\n    std::cout << pop() << std::endl;\n}, Choices: ['A\\n15', 'B\\n25', 'C\\n30', 'D\\n150'], Answer: B\n25"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In any rooted tree, the node with no ancestors is the root. All other nodes are descendants.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many nodes in a tree have no ancestors?, , Choices: ['A\\n0', 'B\\n1', 'C\\n2', 'D\\nn'], Answer: B\n1"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Union-find data structures with union by size and path compression techniques achieve nearly constant time complexity, amortized over a series of m operations on n elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst-case running time of unions done by size and path compression?\na) O(N)\nb) O(logN)\nc) O(N logN)\nd) O(M logN)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A node in a linked list contains data and a link to the next node. This allows dynamic memory allocation and efficient insertion/deletion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In Linked List implementation, a node carries information regarding ___________\na) Data\nb) Link\nc) Data and Link\nd) Node\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A spanning tree is formed by removing edges from a connected graph such that all nodes remain connected and the graph becomes acyclic. A complete graph has the maximum possible edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "From a complete graph, by removing maximum   …………. edges, we can construct a spanning tree., , Choices: ['A\\ne-n+1', 'B\\nn-e+1', 'C\\nn+e-1', 'D\\ne-n-1'], Answer: A\ne-n+1"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. B+ trees are a variation of B-trees and are commonly used in databases and file systems. They are balanced, support sequential access through sibling pointers, and grow upward.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is false?\na) A B+ -tree grows downwards\nb) A B+ -tree is balanced\nc) In a B+ -tree, the sibling pointers allow sequential searching\nd) B+ -tree is shallower than B-tree\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Abstract Syntax Trees (ASTs) are used in compilers to represent the structure of source code. Operators are represented as internal nodes and operands as leaves.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In an abstract syntax tree, each internal node represents an operand and each leaf node represents an operator.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Unrolled linked lists store multiple elements per node, reducing memory allocation and access overhead, which improves insertion and deletion performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Insertion and deletion are much faster in an unrolled linked list than in a singly linked list.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: C++ offers standard functions like reverse() and rotate() for manipulating arrays or ranges within containers like std::vector and std::array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the predefined function for array reversal in C++?\na) rotate()\nb) arr_rotate()\nc) array_rotate()\nd) rot()\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays can represent binary trees in sequential memory where the height determines the number of elements. A tree of height l has up to 2^l - 1 nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What must be the ideal size of array if the height of tree is ‘l’?\na) 2l-1\nb) l-1\nc) l\nd) 2l\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. AA-trees are a simplified form of balanced binary search trees and were introduced by Arne Andersson.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Who is the inventor of AA-Tree?\na) Arne Anderson\nb) Daniel Sleator\nc) Rudolf Bayer\nd) Jon Louis Bentley\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a full binary tree, every node has either 0 or 2 children. A full binary tree with 2n+1 total nodes always contains exactly n non-leaf (internal) nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A full binary tree with 2n+1 nodes contain   ………., , Choices: ['A\\nn leaf nodes', 'B\\nn non-leaf nodes', 'C\\nn-1 leaf nodes', 'D\\nn-1 non-leaf nodes'], Answer: B\nn non-leaf nodes"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Expression trees can be built from prefix, infix, or postfix expressions. Only infix cannot uniquely determine an expression tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Only infix expression can be made into an expression tree.\na) true\nb) false\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix notation (Reverse Polish Notation) is a way to write arithmetic expressions without using parentheses. It can be derived from infix expressions using operator precedence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the corresponding postfix expression for the given infix expression?\n\na) ab*+cd/\nb) ab+*cd/\nc) abc*+/d\nd) abc+*d/\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A full binary tree is a binary tree in which every node has either 0 or 2 children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a full binary tree?\na) Each node has exactly zero or two children\nb) Each node has exactly two children\nc) All the leaves are at the same level\nd) Each node has exactly one or two children\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In separate chaining, each hash bucket contains a list of all elements that hash to the same bucket. A doubly linked list is often used for chaining in hash tables.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following technique stores data in a separate entity in case of a collision?\na) Open addressing\nb) Chaining using doubly linked list\nc) Linear probing\nd) Double hashing\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A Binary Search Tree (BST) is a binary tree where the left subtree contains only nodes with keys less than the parent node and the right subtree only nodes with keys greater. The number of distinct BSTs that can be formed with n keys is the nth Catalan number.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many distinct BSTs can be constructed with 3 distinct keys?, , Choices: ['A\\n4', 'B\\n5', 'C\\n6', 'D\\n9'], Answer: B\n5"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Poor hash functions can lead to clustering, especially when the modulus operator is used with closely packed keys.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following hash functions is most likely to cause clustering in a hash table? Here k is the input key value and m is hash table size. You may assume that all four hash functions generate valid indexes in the hash table., , Choices: ['A\\nh(k) = k % m', 'B\\nh(k) = floor(m * (k mod 1))', 'C\\nh(k) = k', 'D\\nh(k) = ((k / m) + k * m) + k % m'], Answer: A\nh(k) = k % m"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Skip lists are probabilistic data structures that allow efficient search, insertion, and deletion. Their multi-level structure is maintained by adjusting probabilities when modifying nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How to maintain multi-level skip list properties when insertions and deletions are done?\na) design each level of a multi-level skip list with varied probabilities\nb) that cannot be maintained\nc) rebalancing of lists\nd) reconstruction\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: MinHash is a probabilistic technique for estimating similarity between sets. It was originally used to cluster web documents based on shared content (like shingles or n-grams).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which technique was firstly used clustering documents using the similarity of two words or strings?\na) MinHash\nb) Stack\nc) Priority Queue\nd) PAT Tree\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Bitwise XOR is used to toggle specific bits in a binary representation. It flips a bit from 0 to 1 or from 1 to 0.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following bitwise operations will you use to toggle a particular bit?\na) OR\nb) AND\nc) XOR\nd) NOT\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: MinHash was used in the AltaVista search engine to detect duplicate pages. It’s a fast method to compute Jaccard similarity between large sets.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which technique was firstly used to remove duplicate web pages from search results in AltaVista search engine?\na) MinHash\nb) Stack\nc) Priority Queue\nd) PAT Tree\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A tree is a hierarchical data structure consisting of nodes. Splay trees are self-adjusting binary search trees where recently accessed elements are moved to the root for fast access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In which of the following self – balancing binary search tree the recently accessed element can be accessed quickly?\na) AVL tree\nb) AA tree\nc) Splay tree\nd) Red – Black tree\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is used to map data to fixed-size values using a hash function. Collision resolution techniques like separate chaining, linear probing, and quadratic probing manage collisions, whereas hashing itself is the overall process.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not a collision resolution technique?\na) Separate chaining\nb) Linear probing\nc) Quadratic probing\nd) Hashing\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The symbol balancing algorithm checks whether parentheses, brackets, and braces are balanced. It is typically implemented using a stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following statement is incorrect with respect to balancing symbols algorithm?\na) {[()]}\nb) ([ )]\nc) {( )}\nd) { [ ] }\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Linear search is a sequential search technique, while binary search divides the search space. Binary search is more efficient in large, sorted arrays.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Linear search is highly inefficient compared to  binary search when dealing with:, , Choices: ['A\\nSmall, unsorted arrays', 'B\\nSmall, sorted arrays', 'C\\nLarge, unsorted arrays', 'D\\nLarge, sorted arrays'], Answer: D\nLarge, sorted arrays"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Separate chaining is a common technique used in hash tables where each bucket is a linked list. A typical hash function for this method is x mod table size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the hashing function for separate chaining?\na) H(x)=(hash(x)+f(i)) mod table size\nb) H(x)=hash(x)+i2 mod table size\nc) H(x)=x mod table size\nd) H(x)=x mod (table size * 2)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Threaded binary trees reduce the need for stack and queue memory by using NULL pointers to point to in-order predecessor or successor. Efficiency, not memory size, is a primary concern.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Identify the reason which doesn’t play a key role to use threaded binary trees?\na) The storage required by stack and queue is more\nb) The pointers in most of nodes of a binary tree are NULL\nc) It is Difficult to find a successor node\nd) They occupy less size\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the functionality of the following piece of code?\n\npublic Object delete_key() \n{\n if(count == 0)\n {\n  System.out.println(\"Q is empty\");\n  System.exit(0);\n }\n else\n {\n  Node cur = head.getNext();\n  Node dup = cur.getNext();\n  Object e = cur.getEle();\n  head.setNext(dup);\n  count--;\n  return e;\n }\n}\n\na) Delete the second element in the list\nb) Return but not delete the second element in the list\nc) Delete the first element in the list\nd) Return but not delete the first element in the list\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A full binary tree is a tree in which every node has either 0 or 2 children. The number of nodes in such a tree is always of the form 2n+1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following number of nodes can form a full binary tree?, , Choices: ['A\\n8', 'B\\n15', 'C\\n14', 'D\\n13'], Answer: B\n15"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: In simple uniform hashing, every key is equally likely to hash to any slot, which makes the expected search time constant.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In simple uniform hashing, what is the search complexity?\na) O(n)\nb) O(logn)\nc) O(nlogn)\nd) O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Easy\nContext: Insert operations in trees are usually implemented using recursion or iteration with pointers. The pseudocode that traverses the tree and modifies pointers is typically performing insertion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the below pseudo code trying to do, where pt is a node pointer and root pointer?\n\na) insert a new node\nb) delete a node\nc) search a node\nd) count the number of nodes\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The Top operation returns the most recently pushed element on the stack. Push adds to the top, and Top returns that value.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the result of the following operation:   Top (Push (S, X)), , Choices: ['A\\nX', 'B\\nnull', 'C\\nS', 'D\\nNone of these.'], Answer: A\nX"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Randomized hashing techniques like universal and double hashing reduce clustering and collision frequency by generating hashes independent of the data.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Collisions can be reduced by choosing a hash function randomly in a way that is independent of the keys that are actually to be stored.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In memory storage, row-major order stores elements of a 2D array row by row. For a 3x3 matrix, the elements are stored sequentially as they appear row-wise.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If row-major order is used, how is the following matrix stored in memory?\na b c\nd e f\ng h i\na) ihgfedcba\nb) abcdefghi\nc) cfibehadg\nd) adgbehcfi\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Inversions represent the number of pairs of elements that are out of order. A sorted array has zero inversions, which is the minimum.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Under what condition the number of inversions in an array are minimum?\na) when the array is sorted\nb) when the array is reverse sorted\nc) when the array is half sorted\nd) depends on the given array\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays support data locality, which improves cache performance. Spatial locality refers to accessing elements stored close together.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following concepts make extensive use of arrays?\na) Binary trees\nb) Scheduling of processes\nc) Caching\nd) Spatial locality\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: The kth power of an adjacency matrix gives the number of paths of length k between any two vertices in a graph. Each entry A^k[i][j] equals the number of such paths from i to j.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Let A be an adjacency matrix of a graph G. The   ijth entry in the matrix AK , gives, , Choices: ['A\\nThe number of paths of length K from vertex Vi to vertex \\n Vj.', 'B\\nShortest path of K edges from vertex Vi to vertex Vj.', 'C\\nLength of a Eulerian path from vertex Vi to vertex Vj.', 'D\\nLength of a Hamiltonian cycle from vertex Vi to vertex \\n Vj.'], Answer: B\nShortest path of K edges from vertex Vi to vertex Vj."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In an AVL tree, after inserting a node, the balance factor of nodes along the path to the root may need to be updated. This ensures the tree remains balanced.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "To restore the AVL property after inserting a element, we start at the insertion point and move towards root of that tree. is this statement true?\na) true\nb) false\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: AA-Trees and Red-Black Trees are both self-balancing binary search trees. They have similar properties and performance characteristics.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following trees is similar to that of an AA-Tree?\na) Splay Tree\nb) B+ Tree\nc) AVL Tree\nd) Red-Black Tree\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In hashing theory, probe sequences like linear and quadratic probing determine how collisions are resolved. Expression evaluation and conversion also fall under theory topics, such as converting infix to postfix using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the Prefix notation for the given equation?\n\na) ^^^ABCD\nb) ^A^B^CD\nc) ABCD^^^\nd) AB^C^D\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Linked list manipulations require careful updates of pointers. The given code removes the first node in a circular list and returns its value.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the functionality of the following code? Choose the most appropriate answer.\n\npublic int function() {\n if(head == null) return Integer.MIN_VALUE;\n int var;\n Node temp = head;\n while(temp.getNext() != head) temp = temp.getNext();\n if(temp == head) {\n  var = head.getItem();\n  head = null;\n  return var;\n }\n temp.setNext(head.getNext());\n var = head.getItem();\n head = head.getNext();\n return var;\n}\n\na) Return data from the end of the list\nb) Returns the data and deletes the node at the end of the list\nc) Returns the data from the beginning of the list\nd) Returns the data and deletes the node from the beginning of the list\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Breadth First Traversal (BFS) is implemented using a queue. This data structure allows level-order traversal in graphs or trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The data structure required for Breadth First Traversal on a graph is?\na) Stack\nb) Array\nc) Queue\nd) Tree\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix expressions are evaluated from left to right using a stack. The evaluation substitutes variables with values and applies operators.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Evaluate and write the result for the following postfix expression\nabc*+de*f+g*+ where a=1, b=2, c=3, d=4, e=5, f=6, g=2.\na) 61\nb) 59\nc) 60\nd) 55\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In array-based representation of binary trees, left and right children of node at index i can be found at 2i+1 and 2i+2 respectively.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If binary trees are represented in arrays, what formula can be used to locate a left child, if the node has an index i?\na) 2i+1\nb) 2i+2\nc) 2i\nd) 4i\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Easy\nContext: Hashing-based searches use probing for insertion and lookup. On average, linear probing requires 2.5 probes for insertion and 1.5 for successful search.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many probes are required on average for insertion and successful search?\na) 4 and 10\nb) 2 and 6\nc) 2.5 and 1.5\nd) 3.5 and 1.5\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: A stack is a linear data structure following the Last In First Out (LIFO) principle. It supports operations like push and pop and can be implemented using arrays or linked lists. Stack memory is also used in function calls and recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the need for a circular queue?\na) effective usage of memory\nb) easier computations\nc) to delete elements based on priority\nd) implement LIFO principle in queues\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A queue is a linear data structure that follows the First In First Out (FIFO) principle. It supports operations like enqueue (insert) and dequeue (remove), commonly used in scheduling and buffering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Let Q denote a queue containing sixteen numbers and S be an empty stack. Head(Q) returns the element at the head of the queue Q without removing it from Q. Similarly Top(S) returns the element at the top of S without removing it from S. Consider the algorithm given below., , Choices: ['A\\n16', 'B\\n32', 'C\\n256', 'D\\n64'], Answer: C\n256"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Abstract Data Types (ADTs) are defined by their behavior from the point of view of a user, characterized by the collection of operations that can be performed on them.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An ADT is defined to be a mathematical model \f of a user-defined type along with the collection of all …………. operations on that model., , Choices: ['A\\nCardinality', 'B\\nAssignment', 'C\\nPrimitive \\n (A) Cardinality \\n (B) Assignment \\n (C) Primitive', 'D\\nStructured'], Answer: C\nPrimitive \n (A) Cardinality \n (B) Assignment \n (C) Primitive"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In postfix expressions (also known as Reverse Polish Notation), operators follow their operands. They eliminate the need for parentheses to define operation order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is an example for a postfix expression?\na) a*b(c+d)\nb) abc*+de-+\nc) +ab\nd) a+b-c\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Balanced parentheses can be checked using a stack. A valid algorithm pushes '(' and pops for each ')'. At the end, if the stack is empty, the string is balanced.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Write a piece of code which returns true if the string contains balanced parenthesis, false otherwise.\na)\n\npublic boolean isBalanced(String exp) { ... }\n\n... [code options truncated] ...\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Balanced parentheses checks often use stacks because of their LIFO structure, which mirrors the nesting of brackets. Arrays can store stack data.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "One can determine whether an infix expression has balanced parenthesis or not by using ………., , Choices: ['A\\nArray', 'B\\nQueue', 'C\\nStack', 'D\\nTree'], Answer: C\nStack"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: This recursive function computes the minimum number of jumps to reach the end of the array, where each element represents the maximum number of steps that can be jumped forward from that index.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the output of the following code?\n\n#include <bits/stdc++.h> \nusing namespace std; \n \nint func(int arr[], int s, int e) \n{\n   if (s == e) \n return 0; \n   if (arr[s] == 0) \n return INT_MAX; \n \nint min = INT_MAX; \nfor (int i = s + 1; i <= e && i <= s + arr[s]; i++) \n{ \n int jumps = func(arr, i, e); \n if(jumps != INT_MAX && jumps + 1 < min) \n  min = jumps + 1; \n} \nreturn min; \n}\n \nint main() \n{ \n int arr[] = {1, 3, 6, 3, 8, 5}; \n int n = sizeof(arr)/sizeof(arr[0]); \n cout << func(arr, 0, n-1); \n return 0; \n}\n\na) 1\nb) 2\nc) 3\nd) error\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A heap is a special tree-based data structure that satisfies the heap property and can efficiently support priority queue operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Heap can be used as ________________\na) Priority queue\nb) Stack\nc) A decreasing order array\nd) Normal Array\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Quadratic probing is a collision resolution technique in open addressing where the hash index is computed as (h(k) + c1*i + c2*i^2) % table_size. Often simplified as f(i) = i^2.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the correct function definition for quadratic probing?\na) F(i)=i2\nb) F(i)=i\nc) F(i)=i+1\nd) F(i)=i2+1\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: String\nDifficulty: Easy\nContext: The `charAt()` method in Java's `String` class is used to return the character located at a specific index.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of these methods from the String class is used to extract a single character from an object of String?, , Choices: ['A\\nCHARAT()', 'B\\ncharAt()', 'C\\nCharAt()', 'D\\ncharAT()'], Answer: B\ncharAt()"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A suffix tree is a compressed trie that contains all the suffixes of a given string. For a string of length n, the tree has n leaves and helps in efficient string pattern matching.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which statement is correct of suffix tree with a string of length n?\na) The tree has n leaves.\nb) The tree has n roots\nc) Height of Tree is n\nd) Depth of tree is n\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In stack operations, Push(S, X) adds X to stack S, and Top returns the last element pushed onto the stack, which would be X.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the result of the following operation?\nTop (Push (S, X))\na) X\nb) X+S\nc) S\nd) XS\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: Propositional Directed Acyclic Graphs (PDAGs) are used to represent Boolean functions efficiently. They help in logical inference and are fundamental in knowledge representation and reasoning systems.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In which of the following case does a Propositional Directed Acyclic Graph is used for?\na) Representation of Boolean Functions\nb) String Matching\nc) Searching\nd) Sorting of number\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Red-Black trees are chosen for frequent insertions, AVL trees for fast lookups due to strict balancing, and B-trees for handling large datasets and disk-based storage.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "When to choose Red-Black tree, AVL tree and B-trees?\na) many inserts, many searches and when managing more items respectively\nb) many searches, when managing more items respectively and many inserts respectively\nc) sorting, sorting and retrieval respectively\nd) retrieval, sorting and retrieval respectively\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In most programming languages like C, C++, and Java, array indexing starts from 0. This is known as zero-based indexing and simplifies address calculation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In general, the index of the first element in an array is __________\na) 0\nb) -1\nc) 2\nd) 1\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A weight balanced tree is a binary tree where each node stores the size (or weight) of its subtrees to maintain balance. It helps in ensuring efficient insertions, deletions, and access operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a weight balanced tree?\na) A binary tree that stores the sizes of subtrees in nodes\nb) A binary tree with an additional attribute of weight\nc) A height balanced binary tree\nd) A normal binary tree\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: In a Hash Tree (Merkle Tree), sequential access is more efficient compared to B-trees because of the way data is hashed and arranged. However, B-trees are better for range queries and disk-based access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Sequential access in a Hash tree is faster than in B-trees.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a binomial heap, the number of binomial trees with n nodes corresponds to the number of 1's in the binary representation of n, which is approximately log(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The number of trees in a binomial heap with n nodes is\na) logn\nb) n\nc) nlogn\nd) n/2\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A doubly linked list allows traversal in both directions and provides direct access to the previous node, which makes deletion of a known node location more efficient compared to a singly linked list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following operations is performed more efficiently by doubly linked list than by linear linked list?, , Choices: ['A\\nDeleting a node whose location is given', 'B\\nSearching an unsorted list for a given item', 'C\\nInserting a node after the node with a given location', 'D\\nTraversing the list to process each node'], Answer: A\nDeleting a node whose location is given"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: The given code checks if the stack is empty, and if not, traverses and prints each element. This is the typical behavior of displaying a linked list representing a stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "30. What is the functionality of the following piece of code?\n\npublic void display() \n{\n\tif(size == 0)\n\t\tSystem.out.println(\"underflow\");\n\telse\n\t{\n\t\tNode current = first;\n\t\twhile(current != null)\n\t\t{\n\t\t\tSystem.out.println(current.getEle());\n\t\t\tcurrent = current.getNext();\n\t\t}\n\t}\n}\na) display the list\nb) reverse the list\nc) reverse the list excluding top-of-the-stack-element\nd) display the list excluding top-of-the-stack-element\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: This question evaluates understanding of stack behavior based on logical statements. The correct answer depends on which statements about stack operations or behavior are logically accurate.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following statements:, , Choices: ['A\\n(ii) is true', 'B\\n(i) and (ii) are true', 'C\\n(iii) is true', 'D\\n(ii) and (iv) are true'], Answer: C\n(iii) is true"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: When converting expressions or evaluating them using a stack, operands are typically placed directly into the output stream or output list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "When an operand is read, which of the following is done?\na) It is placed on to the output\nb) It is placed in operator stack\nc) It is ignored\nd) Operator stack is emptied\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: An optimal binary search tree minimizes the expected search cost based on known frequencies of access. It is constructed when the access pattern of the keys is known and remains unchanged.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are the conditions for an optimal binary search tree and what is its advantage?\na) The tree should not be modified and you should know how often the keys are accessed, it improves the lookup cost\nb) You should know the frequency of access of the keys, improves the lookup time\nc) The tree can be modified and you should know the number of elements in the tree before hand, it improves the deletion time\nd) The tree should be just modified and improves the lookup time\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: It is possible to find the minimum number of steps to reach the end of an array using a greedy or dynamic programming approach in linear time, contrary to common belief.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "It is not possible to find the minimum number of steps to reach the end of an array in linear time.\na) true\nb) false\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A spanning tree of a connected graph with `n` vertices always contains exactly `n-1` edges. It is a subgraph that connects all the vertices without forming any cycle.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The spanning tree of connected graph with 10 vertices contains ……….., , Choices: ['A\\n9 edges', 'B\\n11 edges', 'C\\n10 edges', 'D\\n9 vertices'], Answer: A\n9 edges"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In a linked list, overflow can occur if a node creation is attempted but there is no available memory (i.e., the free space pool is empty).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Overflow condition in linked list may occur when attempting to ……….., , Choices: ['A\\nCreate a node when free space pool is empty.', 'B\\nTraverse the nodes when free space pool is empty.', 'C\\nCreate a node when linked list is empty.', 'D\\nNone of these.'], Answer: A\nCreate a node when free space pool is empty."
  },
  {
    "input_text": "Topic: String\nDifficulty: Easy\nContext: To print special characters like a newline escape sequence (\\n), you must use double backslashes (\\\\) in C++ to escape each backslash.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How will you print \"\\\\\\n\" on the screen?, , Choices: ['A\\n  cout << \"\\\\\\\\\\\\n\";', 'B\\ncout<<\"\\\\\\\\\\\\\\\\\\\\n\";', 'C\\ncout<<\"//n\";', 'D\\ncout<<\"///n\"'], Answer: A\n  cout << \"\\\\\\n\";"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Binary Search is the most efficient technique to search in a sorted array, requiring O(log n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "To search for an element in a sorted array, which searching technique can be used?\na) Linear Search\nb) Jump Search\nc) Binary Search\nd) Fibonacci Search\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: The described problem involves in-place reversal and rearrangement, where memory efficiency and element manipulation are important. XOR linked lists offer constant space without using extra pointers, saving memory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given 10,8,6,7,9\nswap the above numbers such that finally you got 6,7,8,9,10\nso now reverse 10\n9,7,6,8,10\nnow reverse 9\n8,6,7,9,10\n7,6,8,9,10\n6,7,8,9,10\nat this point 6 is ahead so no more reversing can be done so stop.\nTo implement above algorithm which datastructure is better and why ?\na) linked list. because we can swap elements easily\nb) arrays. because we can swap elements easily\nc) xor linked list. because there is no overhead of pointers and so memory is saved\nd) doubly linked list. because you can traverse back and forth\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: B-trees are used in databases and filesystems. Compression techniques applied to keys in a B-tree can optimize both space and lookup time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Compression techniques can be used on the keys to reduce both space and time requirements in a B-tree.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Hashing is a technique used to map data (keys) to specific addresses in memory using hash functions. It enables constant-time average-case access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Hashing is the problem of finding an appropriate mapping of keys into addresses.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The `reverse()` function in C++ is part of the Standard Template Library (STL) and is defined in the `<algorithm>` header file. It is used to reverse elements in a range.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Predefined function reverse() in C++ is available under which header file?\na) math\nb) stdio\nc) stdlib\nd) algorithm\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A single traversal like inorder, preorder, or postorder is not sufficient to uniquely reconstruct a binary tree. At least two traversals (such as inorder and preorder) are required.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Can a tree stored in an array using either one of inorder or post order or pre order traversals be again reformed?\na) Yes just traverse through the array and form the tree\nb) No we need one more traversal to form a tree\nc) No in case of sparse trees\nd) Yes by using both inorder and array elements\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: String\nDifficulty: Easy\nContext: In C/C++, the `strcmp()` function compares two strings. If both strings are identical, it returns `0`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If two string s are identical, then strcmp() functions returns ______, , Choices: ['A\\n-1', 'B\\n1', 'C\\nYES', 'D\\n0'], Answer: D\n0"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The Least Common Ancestor (LCA) of two nodes in a binary search tree (BST) is the deepest node that is an ancestor of both. A correct approach involves comparing the node values and traversing left or right accordingly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given that 2 elements are present in the tree, write a function to find the LCA(Least Common Ancestor) of the 2 elements.\na)\n\npublic void lca(Tree root,int n1, int n2)\n{\n while (root != NULL)\n        {\n            if (root.data() > n1 && root.data() > n2)\n            root = root.right();\n            else if (root.data() < n1 && root.data() < n2)\n            root = root.left();\n     else break;\n        }\n        System.out.println(root.data());\n}\npublic void lca(Tree root,int n1, int n2)\n{\n    while (root != NULL)\n    {\n        if (root.data() > n1 && root.data() < n2)\n        root = root.left();\n        else if (root.data() < n1 && root.data() > n2)\n        root = root.right();\n else break;\n    }\n    System.out.println(root.data());\n}\npublic void lca(Tree root,int n1, int n2)\n{\n    while (root != NULL)\n    {\n        if (root.data() > n1 && root.data() > n2)\n        root = root.left();\n        else if (root.data() < n1 && root.data() < n2)\n        root = root.right();\n else break;\n    }\n    System.out.println(root.data());\n}\npublic void lca(Tree root,int n1, int n2)\n{\n    while (root != NULL)\n    {\n        if (root.data() > n1 && root.data() > n2)\n        root = root.left.left();\n        else if (root.data() < n1 && root.data() < n2)\n        root = root.right.right();\n else break;\n    }\n    System.out.println(root.data());\n}\n\nd)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a randomized binary search tree, the expected number of leaves is generally (n + 1)/3, assuming uniform insertion probabilities.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the expected number of leaves in a randomized binary search tree?\na) n + 1\nb) (n + 1)/3\nc) (n + 1)/2\nd) n + 3\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A stack is a Last-In First-Out (LIFO) structure. Saying it is FIFO is incorrect. Stacks are commonly implemented using linked lists where the top points to the most recently added node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following statement(s) about stack data structure is/are NOT correct?\na) Linked List are used for implementing Stacks\nb) Top of the Stack always contain the new node\nc) Stack is the FIFO data structure\nd) Null link is present in the last node at the bottom of the stack\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Converting an infix expression (like A + B) to postfix (like AB+) requires temporarily storing operators in the correct precedence order. This is efficiently done using a stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "6. Which data structure is needed to convert infix notation to postfix notation?\na) Tree\nb) Branch\nc) Stack\nd) Queue\nAnswer: c"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A complete graph with n vertices has an edge between every pair of distinct vertices. The number of edges is given by the formula (n*(n-1))/2.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the number of edges present in a complete graph having n vertices?\na) (n*(n+1))/2\nb) (n*(n-1))/2\nc) n\nd) Information given is insufficient\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Bit arrays are memory-efficient data structures that enable compact storage and bit-level operations. However, accessing individual bits can be slower due to bit masking and shifting.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not an advantage of bit array?\na) Exploit bit level parallelism\nb) Maximal use of data cache\nc) Can be stored and manipulated in the register set for long periods of time\nd) Accessing Individual Elements is easy\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a randomized binary search tree (RBST), the expected depth of a node is approximately 2 * log(n) + O(1), based on probabilistic balancing during insertion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the expected depth of a node in a randomized binary search tree?\na) log n\nb) n!\nc) n2\nd) 2 log n + O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In threaded binary trees, null pointers are replaced with special pointers (threads) to the in-order predecessor or successor. A single-threaded tree has one such pointer, while a double-threaded tree has two.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are double and single threaded trees?\na) when both left, right nodes are having null pointers and only right node is null pointer respectively\nb) having 2 and 1 node\nc) using single and double linked lists\nd) using heaps and priority queues\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In postfix expressions (also known as Reverse Polish Notation), operators follow their operands. To convert infix expressions to postfix, operator precedence and parentheses are handled using stack-based parsing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The postfix form of A ^ B * C – D + E/ F/ (G + H),, , Choices: ['A\\nAB^C*D-EF/GH+/+', 'B\\nAB^CD-EP/GH+/+*', 'C\\nABCDEFGH+//+-*^', 'D\\nAB^D +EFGH +//*+'], Answer: A\nAB^C*D-EF/GH+/+"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A suffix array is an array of integers giving the starting positions of suffixes of a string in lexicographical order. It is useful in full-text indexing and pattern matching.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Suffix array of the string “statistics” is ____________\na) 2 8 7 4 9 0 5 1 6 3\nb) 2 7 4 9 8 0 5 1 6 3\nc) 2 4 9 0 5 7 8 1 6 3\nd) 2 8 7 0 5 1 6 9 4 3\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Stack operations like push and pop follow Last-In First-Out (LIFO). The final output after a sequence of operations depends on the order of these operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following sequence of operations on an empty stack., , Choices: ['A\\n86', 'B\\n68', 'C\\n24', 'D\\n94'], Answer: A\n86"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Time complexity of different tree algorithms varies. For example, optimal Binary Search Trees have Θ(n²) time complexity, but other structures like AVL trees offer Θ(n log n) performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Θ(n2), , Choices: ['A\\nΘ(n)', 'B\\nΘ(nLogn)', 'C\\nΘ(n2)', 'D\\nΘ(n2log n)'], Answer: B\nΘ(nLogn)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a k-d tree, the 'k' refers to the number of dimensions. It is a space-partitioning data structure for organizing points in a k-dimensional space.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a k-d tree, k originally meant?\na) number of dimensions\nb) size of tree\nc) length of node\nd) weight of node\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Cartesian trees are used in scenarios requiring range minimum queries and lowest common ancestor computations. They combine properties of a heap and binary search tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Cartesian trees are most suitable for?\na) searching\nb) finding nth element\nc) minimum range query and lowest common ancestors\nd) self balancing a tree\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: A suffix tree can be constructed using a suffix array and an LCP (Longest Common Prefix) array, which together allow efficient representation and search in strings.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "LCP array and ______ is used to construct suffix tree.\na) Hash tree\nb) Hash trie\nc) Suffix array\nd) Balanced tree\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a min heap, the value of the parent node is always less than or equal to its child nodes. This ensures the minimum element is always at the root.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a min heap:, , Choices: ['A\\nminimum values are stored.', 'B\\nchild nodes have less value than parent nodes. \\n (A) minimum values are stored. \\n (B) child nodes have less value than parent nodes.', 'C\\nparent nodes have less value than child nodes.', 'D\\nmaximum value is contained by the root node.'], Answer: C\nparent nodes have less value than child nodes."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Suffix trees are widely used in bioinformatics for tasks like DNA sequence alignment, pattern matching, and repeat finding.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Can suffix tree be used in bioinformatics problems and solutions.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a randomized binary search tree, the longest path during insertion can be analyzed probabilistically. The expected maximum depth for inserting a node is around 4.311 * log(x).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the longest length path for a node x in random binary search tree for the insertion process?\na) log x\nb) x2\nc) x!\nd) 4.311 log x\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In C++, when passing an array to a function, you typically pass the array name (which decays to a pointer). So, calling a function with `fun(arr)` is correct.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the correct way to call the function (fun) in the below program?, #include <bits/stdc++.h>\n#include <iostream>\nusing namespace std;\n\nvoid fun(char* arr)\n{\n    int i;\n    unsigned int n = strlen(arr);\n    for (i = 0; i < n; i++)\n        cout << \" \" << arr[i];\n}\n\n// Driver program\nint main()\n{\n    char arr[]\n        = { 'g', 'e', 'e', 'k', 's', 'q', 'u', 'i', 'z' };\n    // How to call the above function here to print the char\n    // elements?\n\n    return 0;\n}, Choices: ['A\\nfun(&arr);', 'B\\nfun(*arr);', 'C\\nfun(arr)', 'D\\nNone'], Answer: C\nfun(arr)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a B+-tree, if the maximum number of keys in a node is `m`, then the minimum number of keys in any non-root node is typically ⌈m/2⌉. This ensures balance and efficient access. (As asked in GATE CS 2010)\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider a B+-tree in which the maximum number of keys in a node is 5. What is the minimum number of keys in any non-root node? (GATE CS 2010), , Choices: ['A\\n1', 'B\\n2', 'C\\n3', 'D\\n4'], Answer: B\n2"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: Searching for a specific element in a heap requires scanning each node, as heaps are not designed for search operations. Therefore, the worst-case time complexity is O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the space complexity of searching in a heap?\na) O(logn)\nb) O(n)\nc) O(1)\nd) O(nlogn)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: Heap data structures are widely used in various real-world applications such as medical systems (task scheduling), file compression (Huffman coding), and stock market analysis (priority queues).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are the applications of the Heap data structure?, , Choices: ['A\\nMedical Applications', 'B\\nFile Compression', 'C\\nStock market', 'D\\nAll of these'], Answer: D\nAll of these"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The time complexity for multiplying two matrices of order m×n and n×p using standard matrix multiplication is O(mnp), where m, n, and p are the respective dimensions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The complexity of multiplying two matrices of order m*n and n*p is …………., , Choices: ['A\\nmnp', 'B\\nmp', 'C\\nmn', 'D\\nnp'], Answer: A\nmnp"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: Circular queues optimize memory use by treating the queue as a circular buffer. They are beneficial in memory management, traffic systems, and CPU scheduling.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is/are advantages of circular Queue?, , Choices: ['A\\nMemory Management', 'B\\nTraffic system', 'C\\nCPU Scheduling', 'D\\nAll of the above'], Answer: D\nAll of the above"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In direct addressing, each key has a unique position in an array, meaning there's a one-to-one correspondence between keys and array indices. This allows constant-time access but requires large arrays if the key range is large.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is direct addressing?\na) Distinct array position for every possible key\nb) Fewer array positions than keys\nc) Fewer keys than array positions\nd) Distinct array positions for keys based on priority\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Priority scheduling can cause issues like starvation and indefinite blocking for low-priority processes. However, interrupt handling is a standard OS function and not a specific disadvantage of this scheduling.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is not a disadvantage of priority scheduling in operating systems?\na) A low priority process might have to wait indefinitely for the CPU\nb) If the system crashes, the low priority systems may be lost permanently\nc) Interrupt handling\nd) Indefinite blocking\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: Circular queues are used to optimize memory usage by wrapping around when the end of the array is reached, unlike linear queues which can waste space after deletions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the need for a circular queue?\na) easier computations\nb) implement LIFO principle in queues\nc) effective usage of memory\nd) to delete elements based on priority\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a binary search tree (BST), an inorder traversal visits the nodes in sorted (increasing) order. This property makes it useful for producing sorted output.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the speciality about the inorder traversal of a binary search tree?\na) It traverses in a non increasing order\nb) It traverses in an increasing order\nc) It traverses in a random fashion\nd) It traverses based on priority of the node\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: The postfix (Reverse Polish Notation) form of an expression removes parentheses and places operators after their operands. It is used for expression evaluation using stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The postfix form of the expression (A+ B)*(C*D- E)*F / G is?\na) AB+ CD*E – FG /**\nb) AB + CD* E – F **G /\nc) AB + CD* E – *F *G /\nd) AB + CDE * – * F *G /\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Computational geometry is a field of computer science that deals with the study and development of algorithms to solve geometric problems. It plays an important role in computer graphics, robotics, and more.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is computational geometry?\na) study of geometry using a computer\nb) study of geometry\nc) study of algorithms\nd) study of algorithms related to geometry\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In B-trees, when a node splits during insertion, the middle key moves up to the parent, and stays in the right child. During deletion, keys are removed only from the leaf and not repeated in internal nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Statement 1: When a node is split during insertion, the middle key is promoted to the parent as well as retained in right half-node.\nStatement 2: When a key is deleted from the leaf, it is also deleted from the non-leaf nodes of the tree.\na) Statement 1 is true but statement 2 is false\nb) Statement 2 is true but statement 1 is false\nc) Both the statements are true\nd) Both the statements are false\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Easy\nContext: In evaluating infix expressions using stacks, the precedence of operators determines the evaluation order. Higher precedence should not trigger immediate evaluation—only lower or equal precedence should.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following statement is incorrect with respect to evaluation of infix expression algorithm?\na) Operand is pushed on to the stack\nb) If the precedence of operator is higher, pop two operands and evaluate\nc) If the precedence of operator is lower, pop two operands and evaluate\nd) The result is pushed on to the operand stack\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Top trees are a type of dynamic tree data structure, often used in advanced algorithms for dynamic connectivity. They are based on the divide and conquer paradigm to maintain and update tree structures efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which algorithm is used in the top tree data structure?\na) Backtracking\nb) Divide and Conquer\nc) Branch\nd) Greedy\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: An AVL tree is a height-balanced binary search tree. For every node, the difference in height between its left and right subtrees (called balance factor) must be at most 1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An AVL tree is a self – balancing binary search tree, in which the heights of the two child sub trees of any node differ by _________\na) At least one\nb) At most one\nc) Two\nd) At most two\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a binary search tree (BST), in-order traversal visits nodes in the left-root-right order, which yields values in ascending sorted order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a binary search tree, which of the following traversals would print the numbers in the ascending order?\na) Level-order traversal\nb) Pre-order traversal\nc) Post-order traversal\nd) In-order traversal\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Height-balanced binary trees like AVL trees maintain balance to prevent skewed shapes, which helps achieve faster access and insertion times, improving overall efficiency.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Why we need to a binary tree which is height balanced?\na) to avoid formation of skew trees\nb) to save memory\nc) to attain faster memory access\nd) to simplify storing\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Open addressing handles collisions by probing alternative locations in the hash table. Common techniques include linear probing, quadratic probing, and double hashing. Rehashing, however, refers to resizing the hash table, not collision resolution.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not a collision resolution strategy for open addressing?\na) Linear probing\nb) Quadratic probing\nc) Double hashing\nd) Rehashing\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a B+ tree with n pointers, the number of keys in a leaf node ranges from ⌈(n−1)/2⌉ to n−1. If the node can hold 7 pointers, it can hold up to 6 keys, with a minimum of ⌈6/2⌉ = 3.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A B+ tree can contain a maximum of 7 pointers in a node. What is the minimum number of keys in leaves?\na) 6\nb) 3\nc) 4\nd) 7\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In syntax trees or parse trees used by compilers, an in-order traversal returns the original infix expression, which is the same as the original input string.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "While evaluating the parse tree, which traversal technique is used to give the original input string?\na) Pre-order traversal\nb) In-order traversal\nc) Post-order traversal\nd) Breadth-first traversal\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: In a hypergraph, an incidence matrix is a binary matrix that indicates the membership of vertices in hyperedges. Each row represents a vertex, and each column a hyperedge.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the Incidence Matrix of the given HyperGraph?\nV = {x,y,z} E = {{x,y}{y}{x,z}{z,y}}\na) {{1,0,1,0},\n{1,1,0,1},\n{0,0,1,1}}\nb) {{1,1,0,0},\n{0,1,0,0},\n{1,1,1,0}}\nc) {{0,1,0,1},\n{0,0,1,0},\n{1,1,0,0}}\nd) None of the Mentioned\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The maximum number of nodes in a binary tree of depth `d` is given by the formula 2^d − 1. For depth 5, it would be 2^5 − 1 = 31.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The maximum number of nodes in a binary tree of depth 5 is ………….., , Choices: ['A\\n31', 'B\\n16', 'C\\n32 \\n (A) 31 \\n (B) 16 \\n (C) 32', 'D\\n15'], Answer: A\n31"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Quadratic probing is a collision resolution method in open addressing. The hash function is adjusted using a quadratic function: Hash(x) = (hash(x) + c1*i + c2*i^2) % table_size, often simplified as (hash(x) + F(i²)) mod table size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the formula used in quadratic probing?\na) Hash key = key mod table size\nb) Hash key=(hash(x)+F(i)) mod table size\nc) Hash key=(hash(x)+F(i2)) mod table size\nd) H(x) = x mod 17\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The k-d tree (k-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. It was invented by Jon Bentley in 1975.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Who invented k-d trees?\na) Arne Andersson\nb) Jon Bentley\nc) Jon Von Newmann\nd) Rudolf Bayer\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Prefix notation (Polish notation) places operators before their operands. The infix expression (p + q) − (r * t) is written as − + p q * r t in prefix form.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The prefix form of an infix expression (p + q) − (r * t) is?\na) + pq − *rt\nb) − +pqr * t\nc) − +pq * rt\nd) − + * pqrt\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A 2D search tree, also known as a k-d tree, uses alternate dimensions for comparison at different levels. At odd levels, comparisons are typically made using the first key.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The 2d search tree has the simple property that branching on odd levels is done with respect to the first key.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix expressions (Reverse Polish Notation) are evaluated using a stack. For `abc*+`, with a=1, b=2, c=3, it becomes 1 + (2 * 3) = 7.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the result of the given postfix expression? abc*+ where a=1, b=2, c=3.\na) 4\nb) 5\nc) 6\nd) 7\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Postfix expressions are evaluated using a stack. The expression `6 3 2 4 + − *` evaluates as: 2 + 4 = 6, then 3 − 6 = −3, and finally 6 * (−3) = −18.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "7. What is the value of the postfix expression 6 3 2 4 + − *?\na) 74\nb) -18\nc) 22\nd) 40\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The Van Emde Boas tree, an advanced data structure that supports operations in O(log log u) time, was invented by Peter van Emde Boas in 1975.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In which year was Van Emde Boas tree invented?\na) 1972\nb) 1973\nc) 1974\nd) 1975\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A full binary tree is a binary tree in which every node other than the leaves has two children. A balanced full binary tree with `n` leaves has height ⌈log₂(n)⌉. For 8 leaves, height is log₂(8) = 3, so height = 3 + 1 = 4.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the height of a balanced full binary tree with 8 leaves?\na) 8\nb) 5\nc) 6\nd) 4\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In Java, accessing an array element outside its valid index range throws an `ArrayIndexOutOfBoundsException`. In the given code, `arr[5]` is invalid for a 5-element array (index 0–4).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the output of the following Java code?\n\npublic class array\n{\n public static void main(String args[])\n {\n  int []arr = {1,2,3,4,5};\n  System.out.println(arr[5]);\n }\n}\n\na) 4\nb) 5\nc) ArrayIndexOutOfBoundsException\nd) InavlidInputException\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A spanning tree is a subgraph that includes all vertices and is a tree. All spanning trees of a graph have the same number of vertices and exactly (V − 1) edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "All possible spanning trees of graph G:, , Choices: ['A\\nhave same number of edges and vertices.', 'B\\nhave same number of edges and but not vertices.', 'C\\nhave same number of vertices but not edges.', 'D\\ndepends upon algorithm being used.'], Answer: A\nhave same number of edges and vertices."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A self-balancing binary search tree ensures logarithmic height. The minimum height for `n` nodes in such a tree is approximately log₂(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The minimum height of self balancing binary search tree with n nodes is _____\na) log2(n)\nb) n\nc) 2n + 1\nd) 2n − 1\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Random trees are generated using probabilistic algorithms. AVL trees are deterministic and follow strict balancing rules, making them non-random trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not a random tree?\na) Treap\nb) Random Binary Tree\nc) Uniform Spanning Tree\nd) AVL Tree\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: XOR linked lists use a single pointer per node that stores the XOR of previous and next node addresses. This reduces memory usage compared to traditional doubly linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Is it possible to create a doubly linked list using only one pointer with every node., , Choices: ['A\\nNot Possible', 'B\\nYes, possible by storing XOR of addresses of previous and next nodes.', 'C\\nYes, possible by storing XOR of current node and next node', 'D\\nYes, possible by storing XOR of current node and previous node'], Answer: B\nYes, possible by storing XOR of addresses of previous and next nodes."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a BFS traversal of an undirected graph, any non-tree edge (u, v) connects nodes that are at the same level or one level apart. A difference of more than 1 is not possible.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Let G = (V, E) be a simple undirected graph, and s be a particular vertex in it called the source. For x ∈ V, let d(x) denote the shortest distance in G from s to x. A breadth first search (BFS) is performed starting at s. Let T be the resultant BFS tree. If (u, v) is an edge of G that is not in T, then which one of the following CANNOT be the value of d(u) – d(v)?, , Choices: ['A\\n-1', 'B\\n0', 'C\\n1', 'D\\n2'], Answer: D\n2"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Arrays provide a way to store elements of the same data type in contiguous memory locations. They are simple to use and offer efficient indexing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "9. What are the advantages of arrays?\na) Objects of mixed data types can be stored\nb) Elements in an array cannot be sorted\nc) Index of first element of an array is 1\nd) Easier to store elements of same data type\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: A special sparse matrix has mostly zero elements but follows a specific structure. A band matrix is one such type, where non-zero elements are confined to a diagonal band.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which one of the following is a Special Sparse Matrix?\na) Band Matrix\nb) Skew Matrix\nc) Null matrix\nd) Unit matrix\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Deleting a node from a singly linked list requires adjusting the previous node’s next pointer to skip over the node being deleted. The implementation must carefully check bounds and node existence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How would you delete a node in the singly linked list? The position to be deleted is given.\na)\n\npublic void delete(int pos)\n{\n if(pos < 0)\n pos = 0;\n if(pos > size)\n pos = size;\n if( size == 0)\n return;\n if(pos == 0)\n head = head.getNext();\n else\n {\n     Node temp = head;\n     for(int i=1; i<pos; i++)\n            {\n  temp = temp.getNext();\n            }\n     temp.setNext(temp.getNext().getNext());\n }\n     size--;\n}\npublic void delete(int pos)\n{\n if(pos < 0)\n pos = 0;\n if(pos > size)\n pos = size;\n if( size == 0)\n return;\n if(pos == 0)\n head = head.getNext();\n else\n {\n     Node temp = head;\n     for(int i=1; i<pos; i++)\n     {\n  temp = temp.getNext();\n     }\n     temp.setNext(temp.getNext());\n }\n     size--;\n}\npublic void delete(int pos)\n{\n        if(pos < 0)\n pos = 0;\n if(pos > size)\n pos = size;\n if( size == 0)\n return;\n if(pos == 0)\n head = head.getNext();\n else\n {\n     Node temp = head;\n     for(int i=1; i<pos; i++)\n     {\n  temp = temp.getNext().getNext();\n            }\n     temp.setNext(temp.getNext().getNext());\n }\n     size--;\n}\npublic void delete(int pos)\n{\n        if(pos < 0)\n        pos = 0;\n        if(pos > size)\n        pos = size;\n        if( size == 0)\n return;\n if(pos == 0)\n head = head.getNext();\n else\n {\n     Node temp = head;\n     for(int i=0; i<pos; i++)\n     {\n  temp = temp.getNext();\n     }\n     temp.setNext(temp.getNext().getNext());\n }\n size--;\n}\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In C and C++, arrays are declared using the syntax `type name[size];`. For example, `int geeks[20];` declares an array of 20 integers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following correctly declares an array?, , Choices: ['A\\nint geeks[20];', 'B\\nint geeks;', 'C\\ngeeks{20};', 'D\\narray geeks[20];'], Answer: A\nint geeks[20];"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: XOR linked lists use a single field to store the XOR of the addresses of previous and next nodes. The first node XORs NULL and the address of the second node; the last node XORs its previous node and NULL.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What does first and last nodes of a xor linked lists contain ? (let address of first and last be A and B)\na) NULL xor A and B xor NULL\nb) NULL and NULL\nc) A and B\nd) NULL xor A and B\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Simple uniform hashing assumes that every key is equally likely to hash into any of the available slots in the hash table, resulting in uniform distribution.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is simple uniform hashing?\na) Every element has equal probability of hashing into any of the slots\nb) A weighted probabilistic method is used to hash elements into the slots\nc) Elements has Random probability of hashing into array slots\nd) Elements are hashed based on priority\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: A suffix tree is a compressed trie used for efficient full-text searches, particularly in string processing and bioinformatics.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following special type of trie is used for fast searching of the full texts?\na) Ctrie\nb) Hash tree\nc) Suffix tree\nd) T tree\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: In queue data structures, attempting to insert an element into a full queue results in an overflow condition, especially in fixed-size implementations like arrays.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the term for inserting into a full queue known as?\na) overflow\nb) underflow\nc) null pointer exception\nd) program won’t be compiled\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: The bitwise NOT operator (`~` in C/C++) is used to invert all bits of a bit array. It flips 0s to 1s and vice versa.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following bitwise operator will you use to invert all the bits in a bit array?\na) OR\nb) NOT\nc) XOR\nd) NAND\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: In array-based dequeue operations (double-ended queue), elements can be inserted and removed from both ends. Each element may be touched multiple times for shifting or reordering, potentially up to four times in certain implementations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given an array of size n, let’s assume an element is ‘touched’ if and only if some operation is performed on it(for example, for performing a pop operation the top element is ‘touched’). Now you need to perform Dequeue operation. Each element in the array is touched atleast?\na) Once\nb) Twice\nc) Thrice\nd) Four times\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In C, memory allocated using `malloc` or `calloc` should be released using `free`. For deleting nodes in an expression tree, `free` is used to deallocate the memory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An expression tree’s nodes can be deleted by calling?\na) malloc\nb) calloc\nc) delete\nd) free\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: In data structures and algorithms, a naive merge strategy can sometimes still apply in skewed merges, depending on the case. The claim that naive merge cannot be done is false.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Naïve merge cannot be done in a skew merge.\na) true\nb) false\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Prefix notation (Polish notation) expressions must include the expression itself. Without it, no solution is possible. This question appears to be missing the actual prefix expression.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the solution to the given prefix notation?\n\na) 14\nb) 15\nc) 18\nd) 12\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Reversing an array involves swapping pairs of elements from both ends toward the center. For an array of even length n, exactly n/2 swaps are required.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many swaps are required for reversing an array having n elements where n is an even number?\na) (n-1) / 2\nb) n/2\nc) (n/2) – 1\nd) (n+1)/2\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: Height-balanced binary search trees (like AVL trees) can efficiently implement abstract data types such as sets and priority queues due to their balanced structure and fast lookup and update times.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following data structures can be efficiently implemented using height balanced binary search tree?\na) sets\nb) priority queue\nc) heap\nd) both sets and priority queue\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A leftist heap is a variant of a binary heap that is designed to support efficient merging of two heaps. Merging is the fundamental operation upon which others like insertion and deletion are based.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the fundamental operation on leftist heap?\na) insertion\nb) merging\nc) deletion\nd) swapping\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In a doubly linked list, inserting a node at the front shifts the current head to the second position. If `6` is inserted at the beginning of the list `1-2-3-4-5`, the result will be `6-1-2-3-4`, assuming the last element is removed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following doubly linked list: head-1-2-3-4-5-tail. What will be the list after performing the given sequence of operations?\n\na) head-6-1-2-3-4-5-tail\nb) head-6-1-2-3-4-tail\nc) head-1-2-3-4-5-6-tail\nd) head-1-2-3-4-5-tail\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a binary search tree, the number of different search paths to a specific key depends on the structure of the tree. For searching key `60`, the order of traversal over 7 nodes can occur in C(7,3) = 35 ways.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root to the node containing the value 60?, , Choices: ['A\\n35', 'B\\n64', 'C\\n128', 'D\\n5040'], Answer: A\n35"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: Balanced symbol expressions ensure that every opening bracket has a corresponding closing bracket of the same type and properly nested. An expression like `((A+B)+(C+D)` is unbalanced.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following statement is invalid with respect to balancing symbols?\na) [(A+B) + (C-D)]\nb) [{A+B}-{C-[D+E]}]\nc) ((A+B) + (C+D)\nd) {(A+B) + [C+D]}\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Easy\nContext: Insertion Sort is efficient for nearly sorted data because it performs fewer comparisons and shifts compared to other algorithms. Bubble Sort, though simple, is less efficient in general.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following sorting methods would be most suitable for sorting a list which is almost sorted?, , Choices: ['A\\nBubble Sort', 'B\\nInsertion Sort', 'C\\nSelection Sort', 'D\\nQuick Sort'], Answer: A\nBubble Sort"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Easy\nContext: A palindrome is a word that reads the same backward as forward. 'Maadam' is not a palindrome due to its asymmetric spelling.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which among the following is not a palindrome?\na) Madam\nb) Dad\nc) Malayalam\nd) Maadam\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Bit arrays are commonly used in applications like Bloom filters and bitmaps. To find the first occurrence of a `1` in a bit array, a `Find First One` operation is typically used.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which one of the following operations returns the first occurrence of bit 1 in bit arrays?\na) Find First Zero\nb) Find First One\nc) Counting lead Zeroes\nd) Counting lead One\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: The Jaccard Coefficient is a statistical measure used to compare the similarity between two sets. It is defined as the size of the intersection divided by the size of the union of the sets.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which indicator is used for similarity between two sets?\na) Rope Tree\nb) Jaccard Coefficient\nc) Tango Tree\nd) MinHash Coefficient\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: A binary tree supports three primary traversal orders: in-order, pre-order, and post-order. Level-order traversal is also applicable, but generally the number of basic traversal orders is considered to be 3.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many orders of traversal are applicable to a binary tree (In General)?\na) 1\nb) 4\nc) 2\nd) 3\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: Linked lists use dynamic memory allocation, where memory is allocated at runtime using functions like `malloc` or `new`, making them flexible in size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Linked list is considered as an example of ___________ type of memory allocation.\na) Dynamic\nb) Static\nc) Compile time\nd) Heap\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In any K-ary tree, the root node is always at depth 0. Depth is defined as the number of edges from the root to a given node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the depth of the root node of K-ary tree?\na) 2\nb) 1\nc) 0\nd) 3\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: The average depth of a binary tree gives an idea of how far nodes are from the root on average. It is often approximated by O(√N) in randomly constructed binary trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The average depth of a binary tree is given as?\na) O(N)\nb) O(log N)\nc) O(M log N)\nd) O(√N)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a B-tree of minimum degree t, each node can have at most 2t children (pointers), and hence a maximum of 2t pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A B-tree of minimum degree t can maximum ……….. pointers in a node., , Choices: ['A\\nt–1', 'B\\n2t–1', 'C\\n2t', 'D\\nt'], Answer: C\n2t"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In a singly or doubly linked list, searching requires sequential traversal from the head node, leading to a linear time complexity of O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The time required to search an element in a linked list of length n is, , Choices: ['A\\nO (log n)', 'B\\nO (n)', 'C\\nO (1)', 'D\\nO (n2)'], Answer: B\nO (n)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: Splay trees are self-adjusting binary search trees. They are used in applications such as cache implementation where frequently accessed elements are moved closer to the root.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following options is an application of splay trees?\na) cache Implementation\nb) networks\nc) send values\nd) receive values\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Easy\nContext: A graph is bipartite if and only if it does not contain any cycles of odd length. This is a necessary and sufficient condition for bipartiteness.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A graph ‘G’ with ‘n’ nodes is bipartite if it contains ……….., , Choices: ['A\\nn edges', 'B\\na cycle of odd length', 'C\\nno cycle of odd length', 'D\\nn2 edges'], Answer: C\nno cycle of odd length"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: A queue is a linear data structure where insertion (enqueue) occurs at the rear and deletion (dequeue) occurs at the front. This behavior classifies it as FIFO.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A linear list of elements in which deletion can be done from one end (front) and insertion can take place only at the other end (rear) is known as _____________\na) Queue\nb) Stack\nc) Tree\nd) Linked list\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: When a node with two children is deleted in a binary search tree, it is typically replaced with its in-order successor (the next larger node) to maintain the BST properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If a node having two children is deleted from a binary tree, it is replaced by its …….., , Choices: ['A\\nIn-order predecessor', 'B\\nIn-order successor', 'C\\nPre-order predecessor', 'D\\nNone of these'], Answer: B\nIn-order successor"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Easy\nContext: A priority queue allows elements to be processed based on priority. While it efficiently handles priority-based operations, arbitrary deletions (deleting any element) are not straightforward or efficient.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not an advantage of a priority queue?\na) Easy to implement\nb) Processes with different priority can be efficiently handled\nc) Applications with differing requirements\nd) Easy to delete elements in any case\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Easy\nContext: Heaps are typically complete binary trees, which are well-suited to array representations. Arrays provide better memory efficiency and caching compared to linked tree structures.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Why is heap implemented using array representations than tree(linked list) representations though both tree representations and heaps have same complexities?\n\nThen why go with array representation when both are having same values ?\na) arrays can store trees which are complete and heaps are not complete\nb) lists representation takes more memory hence memory efficiency is less and go with arrays and arrays have better caching\nc) lists have better caching\nd) In lists insertion and deletion is difficult\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Easy\nContext: Open addressing and separate chaining are two methods to resolve hash collisions. Open addressing can be easier to implement because it does not require additional data structures like linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is an advantage of open addressing over separate chaining?\na) it is simpler to implement\nb) table never gets full\nc) it is less sensitive to hash function\nd) it has better cache performance\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In a binary search tree (BST), the minimum element is found by traversing left from the root until the leftmost node is reached.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How will you find the minimum element in a binary search tree?\na)\n\npublic void min(Tree root)\n{\n while(root.left() != null)\n {\n  root = root.left();\n }\n System.out.println(root.data());\n}\npublic void min(Tree root)\n{\n while(root != null)\n {\n  root = root.left();\n }\n System.out.println(root.data());\n}\npublic void min(Tree root)\n{\n while(root.right() != null)\n {\n  root = root.right();\n }\n System.out.println(root.data());\n}\npublic void min(Tree root)\n{\n while(root != null)\n {\n  root = root.right();\n }\n System.out.println(root.data());\n}\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: In threaded binary trees, null pointers are replaced with references to in-order predecessors and successors to allow for efficient non-recursive traversal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are null nodes filled with in a threaded binary tree?\na) inorder predecessor for left node and inorder successor for right node information\nb) right node with inorder predecessor and left node with inorder successor information\nc) they remain null\nd) some other values randomly\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: In a d-heap (a generalization of a binary heap where each node has d children), most operations like insert and delete are efficient, but merging two d-heaps is not efficient without specialized data structures.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which operation is not efficiently performed in a d-heap?\na) insert\nb) delete\nc) find\nd) merge\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Easy\nContext: In a circular linked list representation of a queue, maintaining a single pointer to the rear node allows both enQueue (insert at rear) and deQueue (delete from front) operations to be performed in constant time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A circularly linked list is used to represent a Queue. A single variable p is used to access the Queue. To which node should p point such that both the operations enQueue and deQueue can be performed in constant time? (GATE 2004) , , Choices: ['A\\nrear node', 'B\\nfront node', 'C\\nnot possible with a single pointer', 'D\\nnode next to front'], Answer: A\nrear node"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Easy\nContext: A binomial heap supports efficient union operations, unlike binary heaps. It consists of a collection of binomial trees, allowing union in logarithmic time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The main distinguishable characterstic of a binomial heap from a binary heap is that\na) it allows union operations very efficiently\nb) it does not allow union operations that could easily be implemented in binary heap\nc) the heap structure is not similar to complete binary tree\nd) the location of child node is not fixed i.e child nodes could be at level (h-2) or (h-3), where h is height of heap and h>4\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Easy\nContext: For pre-order and post-order traversals to be the same, the tree must have only one node. With more than one node, the traversal orders will differ.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The maximum number of nodes in a tree for which post-order and pre-order traversals may be equal is ______\na) 3\nb) 1\nc) 2\nd) any number\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Medium\nContext: If a Directed Acyclic Graph (DAG) has more than one valid topological sort, then it cannot have exactly one Hamiltonian path. A unique topological sort would imply exactly one such path.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If there are more than 1 topological sorting of a DAG is possible, which of the following is true.\na) Many Hamiltonian paths are possible\nb) No Hamiltonian path is possible\nc) Exactly 1 Hamiltonian path is possible\nd) Given information is insufficient to comment anything\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: AVL trees are more strictly balanced than Red-Black trees, which may result in more rotations during insertion and deletion. Red-Black trees allow faster updates but are less balanced.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true, , Choices: ['A\\nThe AVL trees are more balanced compared to Red Black Trees, but they may cause more rotations during insertion and deletion.', 'B\\nHeights of AVL and Red-Black trees are generally same, but AVL Trees may cause more rotations during insertion and deletion.', 'C\\nRed Black trees are more balanced compared to AVL Trees, but may cause more rotations during insertion and deletion.', 'D\\nHeights of AVL and Red-Black trees are generally same, but Red Black trees may cause more rotations during insertion and deletion.'], Answer: A\nThe AVL trees are more balanced compared to Red Black Trees, but they may cause more rotations during insertion and deletion."
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A Hash tree (or Merkle tree) uses hashing to support direct access and data integrity verification. It does not provide sequential access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true for a Hash tree?\na) Hashing is used for sequential access\nb) Indexing is used for direct access\nc) Hash tree allows only sequential access\nd) Hashing is used for direct access\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: A triply linked list is an extension of doubly linked lists and is dynamic in nature, allowing flexible memory usage. It supports forward and backward traversal and an additional pointer for special operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true about a triply linked list?\na) Dynamic in nature\nb) Allows random access\nc) Less memory wastage\nd) Reverse traversing is difficult\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Huffman coding is a popular application of binary trees used in data compression algorithms. It constructs an optimal prefix code based on the frequency of characters.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An important application of binary tree is ______, , Choices: ['A\\nHuffman coding', 'B\\nstack implementation', 'C\\nqueue implementation', 'D\\ntraverse a cyclic graph'], Answer: A\nHuffman coding"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: A graph can consist of only vertices and no edges (called an edgeless graph). However, it cannot contain edges without vertices, since edges must connect vertices.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true?\na) A graph may contain no edges and many vertices\nb) A graph may contain many edges and no vertices\nc) A graph may contain no edges and no vertices\nd) A graph may contain no vertices and many edges\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The number of inversions in an array indicates how far the array is from being sorted. A common method to compute inversions efficiently is via a modified merge sort algorithm.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Choose the correct function from the following which determines the number of inversions in an array?\na) Using bubble sort comparisons\nb) Using merge sort with inversion count logic\nc) Using simple count of unequal elements\nd) Using linear scan for each element\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A B+ tree is a type of self-balancing tree structure that allows both rapid sequential access (via leaf node chaining) and rapid random access (through internal indexing).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true?\na) B + tree allows only the rapid random access\nb) B + tree allows only the rapid sequential access\nc) B + tree allows rapid random access as well as rapid sequential access\nd) B + tree allows rapid random access and slower sequential access\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: Priority queues can be implemented using multiple queues for different priority levels. A minimum of 2 queues is required—one for high and one for low priority elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Minimum number of queues required for priority queue implementation?, , Choices: ['A\\n5', 'B\\n4', 'C\\n3', 'D\\n2'], Answer: D\n2"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: To move the last element of a singly linked list to the front, one must first find the second-last node (q), update q’s next to NULL, then set the last node (p)’s next to head, and update head to p.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The following C function takes a simply-linked list as input argument. It modifies the list by moving the last element to the front of the list and returns the modified list. Some part of the code is left blank. Choose the correct alternative that contain the correct pseudocode for the blank line. , #include <iostream>\nstruct Node {\n    int value;\n    Node *next;\n};\n\nNode* move_to_front(Node *head) {\n    Node *p, *q;\n    if (head == NULL || head->next == NULL)\n        return head;\n    q = NULL; p = head;\n    while (p->next != NULL) {\n        q = p;\n        p = p->next;\n    }\n    __________________________________\n    return head;\n}, Choices: ['A\\nq = NULL; next of p = head; head = p;', 'B\\nnext of q = NULL; head = p; next of p = head;', 'C\\nhead = p; next of p = q; next of q = NULL;', 'D\\nnext of q = NULL; next of p = head; head = p;'], Answer: D\nnext of q = NULL; next of p = head; head = p;"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Standard operator precedence rules apply: division and multiplication before addition. The expression `a/b + c*d` with values a=4, b=2, c=2, d=1 becomes 2 + 2 = 4.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Evaluate the following and choose the correct answer.\na/b+c*d where a=4, b=2, c=2, d=1.\na) 1\nb) 4\nc) 5\nd) 2\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Threaded binary trees use null pointers to link to in-order predecessor and successor nodes, allowing all standard traversals (in-order, pre-order, post-order) to be performed efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following tree traversals work if the null left pointer pointing to the predecessor and null right pointer pointing to the successor in a binary tree?\na) inorder, postorder, preorder traversals\nb) inorder\nc) postorder\nd) preorder\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In expression trees, evaluating and converting them to infix form involves recursive traversal. This problem assumes a correct traversal and evaluation path to yield 12.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "From the given expression tree, identify the infix expression, evaluate it and choose the correct result.\n\na) 5\nb) 10\nc) 12\nd) 16\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: When implementing a queue with a linked list, inserting at one end (e.g., rear) and deleting from the other (e.g., front) maintains FIFO order. Option a describes this behavior correctly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true about linked list implementation of queue?\na) In push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end\nb) In push operation, if new nodes are inserted at the beginning, then in pop operation, nodes must be removed from the beginning\nc) In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from end\nd) In push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from beginning\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: According to operator precedence, multiplication is done before addition and subtraction. The expression `1+2*3-2` evaluates as `1 + 6 - 2 = 5`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Evaluate the following statement using infix evaluation algorithm and choose the correct answer. 1+2*3-2\na) 3\nb) 6\nc) 5\nd) 4\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In Fibonacci heaps, insertion is simple, but certain lines in the code may cause structural issues. The line referenced (Line 9) likely introduces an error in maintaining heap properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is wrong with the following code of insertion in fibonacci heap.\nChoose the correct option\n\na) Line -11\nb) Line -3\nc) Line 9\nd) Line 7\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In Binary Search Tree deletion, when a node has two children, it's replaced with its inorder successor or predecessor. The inorder successor is either a leaf or has no left child.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In delete operation of BST, we need inorder successor (or predecessor) of a node when the node to be deleted has both left and right child as non-empty. Which of the following is true about inorder successor needed in delete operation?, , Choices: ['A\\nInorder Successor is always a leaf node', 'B\\nInorder successor is always either a leaf node or a node with empty left child', 'C\\nInorder successor may be an ancestor of the node', 'D\\nInorder successor is always either a leaf node or a node with empty right child'], Answer: B\nInorder successor is always either a leaf node or a node with empty left child"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: The given function resembles a Max-Heapify function which ensures the max-heap property. It swaps the largest of parent and child and recursively fixes the heap.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given the code, choose the correct option that is consistent with the code. (Here A is the heap)\n\nbuild(A,i)\n left-> 2*i\n right->2*i +1\n temp- > i\n if(left<= heap_length[A] ans A[left] >A[temp])\n temp -> left\n if (right = heap_length[A] and A[right] > A[temp])\n temp->right\n if temp!= i\n swap(A[i],A[temp])\n build(A,temp)\n\na) It is the build function of max heap\nb) It is the build function of min heap\nc) It is general build function of any heap\nd) It is used to search element in any heap\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Post-order traversal of an expression tree prints operands first, followed by operators. For (7 - (4 * 5)) + (9 / 3), the post-order is 745*-93/+.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "For the expression (7-(4*5))+(9/3) which of the following is the post order tree traversal?, , Choices: ['A\\n*745-93/+', 'B\\n93/+745*-', 'C\\n745*-93/+', 'D\\n74*+593/-'], Answer: C\n745*-93/+"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Stack implemented with arrays has fixed size; resizing requires reallocation. This limits flexibility and is the main drawback of array-based stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Array implementation of Stack is not dynamic, which of the following statements supports this argument?\na) space allocation for array is fixed and cannot be changed during run-time\nb) user unable to give the input for stack operations\nc) a runtime exception halts execution\nd) improper program compilation\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The Move-To-Front heuristic reorganizes data to improve access time. However, it may bring infrequently accessed nodes to the front, potentially decreasing performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true about the Move-To-Front Method for rearranging nodes?\na) node with highest access count is moved to head of the list\nb) requires extra storage\nc) may over-reward infrequently accessed nodes\nd) requires a counter for each node\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Searching in AVL trees is Θ(log n) due to their balanced nature, while unbalanced BSTs may degrade to O(n) in worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is TRUE?, , Choices: ['A\\nThe cost of searching an AVL tree is Θ (log n) but that of a binary search tree is O(n)', 'B\\nThe cost of searching an AVL tree is Θ (log n) but that of a complete binary tree is Θ (n log n)', 'C\\nThe cost of searching a binary search tree is O (log n ) but that of an AVL tree is Θ(n)', 'D\\nThe cost of searching an AVL tree is Θ (n log n) but that of a binary search tree is O(n)'], Answer: A\nThe cost of searching an AVL tree is Θ (log n) but that of a binary search tree is O(n)"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Stack operations like push and pop must respect stack size. The given sequence respects the size limit and does not cause overflow or underflow.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following operations performed on a stack of size 5 : Push (a); Pop() ; Push(b); Push(c); Pop(); Push(d); Pop();Pop(); Push (e) Which of the following statements is correct?, , Choices: ['A\\nUnderflow occurs', 'B\\nStack operations are performed smoothly', 'C\\nOverflow occurs', 'D\\nNone of the above'], Answer: B\nStack operations are performed smoothly"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: In a linked list implementation of a queue, you can insert at the beginning and remove from the end, or vice versa, depending on your implementation. Both configurations are valid.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true about linked list implementation of queue?, , Choices: ['A\\nIn push operation, if new nodes are inserted at the beginning of linked list, then in pop operation, nodes must be removed from end.', 'B\\nIn push operation, if new nodes are inserted at the end, then in pop operation, nodes must be removed from the beginning.', 'C\\nBoth of the above', 'D\\nNone of the above'], Answer: C\nBoth of the above"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In B-trees, the higher the order (maximum number of children), the more keys each node can hold. This reduces the frequency of splits because nodes can accommodate more insertions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true?\na) larger the order of B-tree, less frequently the split occurs\nb) larger the order of B-tree, more frequently the split occurs\nc) smaller the order of B-tree, more frequently the split occurs\nd) smaller the order of B-tree, less frequently the split occurs\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Using standard operator precedence (exponentiation > multiplication/division > addition/subtraction), evaluate a + b * c - d / e ^ f with given values: 1 + 2*3 - 4/4 = 1 + 6 - 1 = 6.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Evaluate the following infix expression using algorithm and choose the correct answer. a+b*c-d/e^f where a=1, b=2, c=3, d=4, e=2, f=2.\na) 6\nb) 8\nc) 9\nd) 7\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: In a trie (prefix tree), strings are stored such that the path from the root to a leaf represents a string. Each node contains character edges to its children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true about the trie?\na) root is letter a\nb) path from root to the leaf yields the string\nc) children of nodes are randomly ordered\nd) each node stores the associated keys\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In normal binary trees, many pointers in the structure may be null (especially in leaf nodes), which leads to space inefficiency. Threaded binary trees solve this by reusing null pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are the disadvantages of normal binary tree traversals?\na) there are many pointers which are null and thus useless\nb) there is no traversal which is efficient\nc) complexity in implementing\nd) improper traversals\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In evaluating `a^b + c` with a=2, b=2, c=2, we compute 2^2 + 2 = 4 + 2 = 6.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Using the evaluation of infix expression, evaluate a^b+c and choose the correct answer. (a=2, b=2, c=2)\na) 12\nb) 8\nc) 10\nd) 6\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Binary trees can be both complete and full, but not all binary trees satisfy these properties. Therefore, none of the listed options are universally true.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is true about Binary Trees?, , Choices: ['A\\nEvery binary tree is either complete or full.', 'B\\nEvery complete binary tree is also a full binary tree.', 'C\\nEvery full binary tree is also a complete binary tree.', 'D\\nNo binary tree is both complete and full.', 'E\\nNone of the above'], Answer: E\nNone of the above"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Standard infix evaluation respects operator precedence: multiplication/division before addition/subtraction. The expression `4*2 + 3 - 5/5` = `8 + 3 - 1` = `10`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Evaluate the following statement using infix evaluation algorithm and choose the correct answer. 4*2+3-5/5\na) 10\nb) 11\nc) 16\nd) 12\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In a weak-heap, each right child has a greater value than its parent. It is a relaxed version of the min-heap with specific rules enabling better performance in certain cases.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Choose the correct properties of weak-heap.\na) Every node has value greater than the value of child node\nb) Every right child of node has greater value than parent node\nc) Every left child of node has greater value than parent node\nd) Every left and right child of node has same value as parent node\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: A threaded binary tree replaces null pointers with pointers to in-order predecessor or successor, enabling traversal without stacks or queues.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a threaded binary tree traversal?\na) a binary tree traversal using stacks\nb) a binary tree traversal using queues\nc) a binary tree traversal using stacks and queues\nd) a binary tree traversal without using stacks and queues\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: To evaluate an expression tree (or syntax tree), post-order traversal is used because it first visits subtrees (operands) before applying the operator (root).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which tree traversal technique is used to evaluate the expression represented by syntax tree?\na) Pre-order traversal\nb) In-order traversal\nc) Post-order traversal\nd) Breadth first traversal\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: If delete and decrease-key operations are rare and provided with direct access, an unsorted array allows O(1) insertions and direct deletions, making it optimal for minimizing total cost.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An algorithm performs (logN)^1/2 find operations, N insert operations, (logN)^1/2 delete operations, and (logN)^1/2 decrease-key operations on a set of data items with keys drawn from a linearly ordered set. For a delete operation, a pointer is provided to the record that must be deleted. For the decrease-key operation, a pointer is provided to the record that has its key decreased. Which one of the following data structures is the most suited for the algorithm to use, if the goal is to achieve the best total asymptotic complexity considering all the operations?, , Choices: ['A\\nUnsorted array', 'B\\nMin-heap', 'C\\nSorted array', 'D\\nSorted doubly linked list'], Answer: A\nUnsorted array"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In a hash table with chaining using a list head, deleting an element pointed to by a reference is done in constant time, giving a time complexity of O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of delete function in the hash table using list head?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: AA-Trees are balanced binary search trees with worst-case time complexity for operations like search, insert, and delete being O(log N), similar to AVL or Red-Black trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case analysis of an AA-Tree?\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(N²)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a ternary heap, each node has 3 children. The height is log base 3 of n. Decreasing a key may involve bubbling down the tree, taking O(3 * log n / log 3) time in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for decreasing priority of key in a maximum ternary heap of n elements?\na) O(log n / log 3)\nb) O(3 log n / log 3)\nc) O(n)\nd) O(1)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a circular linked list, searching for a specific element still requires traversing up to n elements in the worst case, giving a time complexity of O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of searching for an element in a circular linked list?, , Choices: ['A\\nO(n)', 'B\\nO(nlogn)', 'C\\nO(1)', 'D\\nO(n²)'], Answer: A\nO(n)"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Finding all tandem repeats (repeated substrings appearing consecutively) can be done using suffix trees in O(n log n + z), where z is the number of such repeats.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a time complexity for finding all the tandem repeats?\na) Ɵ(n)\nb) Ɵ(n!)\nc) Ɵ(1)\nd) O(n log n + z)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: While hash tables offer O(1) average-case time complexity, self-balancing BSTs offer O(log n). Hence, BSTs are worse than hash tables in the average case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Self – balancing binary search trees have a much better average-case time complexity than hash tables.\na) True\nb) False\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Generalized suffix trees can be used to find the longest palindromic substring in linear time using clever traversal and string manipulations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a time complexity for finding the longest palindromic substring in a string by using the generalized suffix tree?\na) Linear Time\nb) Exponential Time\nc) Logarithmic Time\nd) Cubic Time\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Dynamic arrays provide amortized O(1) time complexity for insertion at the end. But resizing may take O(n), so worst case is O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of inserting at the end in dynamic arrays?\na) O(1)\nb) O(n)\nc) O(log n)\nd) Either O(1) or O(n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: When using separate chaining with a list head in a hash table, if a key is present at the head, it can be found in constant time O(1) on average.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of search function in a hash table using list head?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Finding the minimum number of steps to reach the end of an array (e.g., jump game) can be solved using greedy or dynamic programming in O(n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the minimum possible time complexity to find the number of steps to reach the end of an array?\na) O(n)\nb) O(n²)\nc) O(n^{3/2})\nd) O(1)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Appending to a variable-length array may cause reallocation when capacity is exceeded, leading to O(n) time in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which among the following is the worst-case time complexity for appending an element in a variable-length array?\na) O(n)\nb) O(1)\nc) O(n²)\nd) O(log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A Van Emde Boas (vEB) tree can store up to M elements with linear space O(M). It offers fast operations like insert, delete, and search in O(log log M) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for storing the maximum number of elements in Van Emde Boas tree if M is the maximum number of elements?\na) O(log M)\nb) O(M!)\nc) O(M)\nd) O(1)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a ternary heap, each node has up to 3 children. The height of the heap is log base 3 of n, so inserting takes O(log n / log 3) time in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for inserting a new item in a ternary heap of n elements?\na) O(log n / log 3)\nb) O(n!)\nc) O(n)\nd) O(1)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Implementing a stack using queues (especially a single queue) can lead to O(n) time complexity for some operations, making it inefficient for large datasets.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Why is implementation of stack operations on queues not feasible for a large dataset (Assume the number of elements in the stack to be n)?\na) Because of its time complexity O(n)\nb) Because of its time complexity O(log(n))\nc) Extra memory is not required\nd) There are no problems\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: Merge Sort is a divide-and-conquer algorithm with a guaranteed worst-case time complexity of O(n log n), unlike other elementary sorts like Bubble or Insertion Sort.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following sorting algorithms does not have a worst case running time of O(n²) ?, , Choices: ['A\\nInsertion sort', 'B\\nMerge sort', 'C\\nQuick sort', 'D\\nBubble sort'], Answer: B\nMerge sort"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a singly or doubly linked list, searching for a specific element requires traversing the list from the head to the desired node, resulting in O(n) time in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the asymptotic time complexity to find an element in the linked list?\na) O(1)\nb) O(n)\nc) O(n²)\nd) O(n⁴)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Inserting at the second position in a linked list requires only a single traversal step and pointer adjustment, which takes constant time, i.e., O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the asymptotic time complexity to insert an element at the second position in the linked list?\na) O(1)\nb) O(n)\nc) O(n²)\nd) O(n³)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a binary min-heap, the maximum element is not necessarily at the root and could be in any of the leaf nodes. To find it requires scanning up to n/2 leaf nodes, giving Θ(n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Let H be a binary min-heap consisting of n elements implemented as an array. What is the worst case time complexity of an optimal algorithm to find the maximum element in H?, , Choices: ['A\\nΘ(1)', 'B\\nΘ(logn)', 'C\\nΘ(n)', 'D\\nΘ(nlogn)'], Answer: C\nΘ(n)"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In separate chaining, the worst-case scenario occurs when all elements hash to the same bucket, resulting in a linear search through a linked list. This gives O(n) worst-case search time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case search time of a hashing using separate chaining algorithm?\na) O(n log n)\nb) O(n)\nc) O(n²)\nd) O(n³)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: The Build Heap operation for constructing a binary heap from an array of n elements has a time complexity of O(n), not O(n log n), due to the reduced cost of heapifying lower levels.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of Build Heap operation? \n(Build Heap is used to build a max(or min) binary heap from a given array. Build Heap is used in Heap Sort as a first step for sorting.), , Choices: ['A\\nO(n log n)', 'B\\nO(n²)', 'C\\nO(n)', 'D\\nO(log n)'], Answer: C\nO(n)"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: If an adjacency matrix is used to represent a graph, checking for the existence of an edge between two vertices takes O(1) time, and does not depend on the number of vertices or edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "On which of the following statements does the time complexity of checking if an edge exists between two particular vertices not depend?\na) Depends on the number of edges\nb) Depends on the number of vertices\nc) Is independent of both the number of edges and vertices\nd) It depends on both the number of edges and vertices\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: When a binary search tree is used for chaining in a hash table, insertion into the tree (assuming it is balanced) takes O(log n), but inserting at the head or tail of a list in chaining takes O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of insert function in a hash table using a binary tree?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Splay trees provide amortized time complexity guarantees. A sequence of j operations on a splay tree with at most h nodes takes O(j log h) time in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following property of splay tree is correct?\na) it holds probability usage of the respective sub trees\nb) any sequence of j operations starting from an empty tree with h nodes at most, takes O(j log h) time complexity\nc) sequence of operations with h nodes can take O(log h) time complexity\nd) splay trees are unstable trees\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Project scheduling can be modeled using optimization techniques such as Dynamic Programming, especially when overlapping subproblems are involved.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Project scheduling is an example of ……….., , Choices: ['A\\nGreedy programming', 'B\\nDynamic programming \\n (A) Greedy programming \\n (B) Dynamic programming', 'C\\nDivide and conquer', 'D\\nNone of the above.'], Answer: B\nDynamic programming \n (A) Greedy programming \n (B) Dynamic programming"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The given recursive function reverses an array. Each recursive call processes one pair of elements, so the time complexity is linear, i.e., O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the time complexity of the following code?\n\n#include <bits/stdc++.h> \nusing namespace std; \nvoid func(int arr[], int left, int right) \n{ \n    if (left >= right) \n    return; \n \n    int temp = arr[left];  \n    arr[left] = arr[right]; \n    arr[right] = temp; \n \n    func(arr, left + 1, right - 1);  \n}      \n \nvoid printArray(int arr[], int size) \n{ \n    for (int i = 0; i < size; i++) \n    cout << arr[i] << \" \"; \n} \n \nint main() \n{ \n int arr[] = {1,2,3,4}; \n int n = sizeof(arr) / sizeof(arr[0]); \n func(arr, 0, n-1); \n printArray(arr, n); \n return 0; \n}\n\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Inserting n² elements into an AVL tree with n initial elements involves multiple insertions, each costing O(log n), leading to a total time complexity of Θ(n² log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of inserting n² elements into an AVL-tree with n elements initially ?, , Choices: ['A\\nΘ(n⁴)', 'B\\nΘ(n²)', 'C\\nΘ(n² log n)', 'D\\nΘ(n³)'], Answer: C\nΘ(n² log n)"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a circular linked list, to count nodes we loop until we reach the head again. The correct method must check `while(temp != head)` and increment the count properly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How do you count the number of elements in the circular linked list?\na)\n\npublic int length(Node head)\n{\n int length = 0;\n if( head == null)\n  return 0;\n Node temp = head.getNext();\n while(temp != head)\n {\n  temp = temp.getNext();\n  length++;\n }\n return length;\n}\npublic int length(Node head)\n{\n int length = 0;\n if( head == null)\n  return 0;\n Node temp = head.getNext();\n while(temp != null)\n {\n  temp = temp.getNext();\n  length++;\n }\n return length;\n}\npublic int length(Node head)\n{\n int length = 0;\n if( head == null)\n  return 0;\n Node temp = head.getNext();\n while(temp != head && temp != null)\n {\n  temp = head.getNext();\n  length++;\n }\n return length;\n}\npublic int length(Node head)\n{\n int length = 0;\n if( head == null)\n  return 0;\n Node temp = head.getNext();\n while(temp != head && temp == null)\n {\n  temp = head.getNext();\n  length++;\n }\n return length;\n}\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Level order traversal visits nodes breadth-first, processing each node once. The total complexity is linear in the number of nodes, O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of level order traversal?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Red-black trees are preferred over hash tables when ordered data or range queries are needed. Hash tables require resizing and do not maintain order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Why Red-black trees are preferred over hash tables though hash tables have constant time complexity?\na) no they are not preferred\nb) because of resizing issues of hash table and better ordering in red-black trees\nc) because they can be implemented using trees\nd) because they are balanced\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a singly linked list, deleting a node given only a pointer to it requires traversal from the head to find the previous node, making the worst-case time complexity O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Let P be a singly linked list. Let Q be the pointer to an intermediate node x in the list. What is the worst-case time complexity of the best known algorithm to delete the node Q from the list?, , Choices: ['A\\nO(n)', 'B\\nO(log² n)', 'C\\nO(log n)', 'D\\nO(1)'], Answer: A\nO(n)"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Hash tables generally have lower average-case time complexity for insert, search, and delete compared to Binary Search Trees (BST), which may degrade to O(n) in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the disadvantage of BST over the hash table?\na) BST is easier to implement\nb) BST can get the keys sorted by just performing inorder traversal\nc) BST can perform range query easily\nd) Time complexity of hash table in inserting, searching and deleting is less than that of BST\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: The Van Emde Boas (vEB) tree provides extremely fast operations for search, insert, and delete, with time complexity O(log log M), where M is the universe size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for searching a key or integer in Van Emde Boas data structure?\na) O(log M!)\nb) O(M!)\nc) O(M²)\nd) O(log log M)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Skip lists improve over linked lists by allowing fast search, insertion, and deletion in expected O(log n) time, compared to O(n) in regular linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity improvement of skip lists from linked lists in insertion and deletion?\na) O(n) to O(log n) where n is number of elements\nb) O(n) to O(1) where n is number of elements\nc) no change\nd) O(n) to O(n²) where n is number of elements\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Inserting a node at the end of a singly linked list requires traversing all nodes from the head unless a tail pointer is maintained, resulting in O(n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the asymptotic time complexity to add a node at the end of singly linked list, if the pointer is initially pointing to the head of the list?\na) O(1)\nb) O(n)\nc) Θ(n)\nd) Both O(n) and Θ(n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In heapsort, multiple heapify operations may be required depending on element swaps. The array snapshot suggests at least two heapify operations were done at the root.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Suppose we are sorting an array of eight integers using heapsort, and we have just finished some heapify (either maxheapify or minheapify) operations. The array now looks like this: 16 14 15 10 12 27 28. How many heapify operations have been performed on root of heap?, , Choices: ['A\\n1', 'B\\n2', 'C\\n3 or 4', 'D\\n5 or 6'], Answer: B\n2"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a skewed binary search tree (like a linked list), all operations—search, insert, and delete—take linear time in the number of nodes, i.e., O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity for search, insert and delete operations in a general Binary Search Tree for a skewed tree ?, , Choices: ['A\\nO(n) for all', 'B\\nO(log n) for all', 'C\\nO(log n) for search and insert, and O(n) for delete', 'D\\nO(log n) for search, and O(n) for insert and delete'], Answer: A\nO(n) for all"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The given code reverses an array in-place using a loop that swaps elements from both ends toward the center. This operation has a linear time complexity of O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the time complexity of the following code?\n\n#include <bits/stdc++.h> \nusing namespace std; \nvoid func(int arr[], int left, int right) \n{ \n     while (left < right) \n { \n  int temp = arr[left]; \n  arr[left] = arr[right]; \n  arr[right] = temp; \n  left++; \n  right--; \n } \n \n}  \n \nvoid printArray(int arr[], int size) \n{ \n    for (int i = 0; i < size; i++) \n    cout << arr[i] << \" \"; \n} \n \nint main() \n{ \n int arr[] = {1,4,3,5}; \n int n = sizeof(arr) / sizeof(arr[0]); \n func(arr, 0, n-1); \n printArray(arr, n); \n return 0; \n}\n\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n log n)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The best-case height of a B-tree with k keys and order n is logₙ(k+1) − 1. This occurs when the tree is perfectly balanced and maximally filled.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the best case height of a B-tree of order n and which has k keys?\na) logₙ(k+1) − 1\nb) nk\nc) logₖ(n+1) − 1\nd) k log n\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Circular linked lists are suitable for implementing both stacks and queues due to their ability to cycle through elements without needing null termination.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A circular linked list can be used for ……….., , Choices: ['A\\nStack', 'B\\nQueue \\n (A) Stack \\n (B) Queue', 'C\\nBoth Stack & Queue', 'D\\nNeither Stack or Queue'], Answer: C\nBoth Stack & Queue"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In sparse matrix addition, only the non-zero elements need to be processed. Hence, the worst-case time complexity is O(n), where n is the number of non-zero elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Is O(n) the Worst case Time Complexity for addition of two Sparse Matrix?\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Both the reversal algorithm and the juggling algorithm for array rotation have linear time complexity O(n), though they use different approaches and space.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Reversal algorithm and juggling algorithm for array rotation have the same time complexity.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: To count the number of elements in a singly or circular linked list, each node must be visited once. This results in linear time complexity, O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity to count the number of elements in the linked list?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n²)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Using suffix automaton or enhanced string techniques, it is possible to find the longest common prefix between any suffix in constant time, i.e., Θ(1), after preprocessing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a time complexity for finding the longest prefix that is common between suffix in a string?\na) Θ(n)\nb) Θ(n!)\nc) Θ(1)\nd) O(log n!)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Merging two max-heaps of size n can be done by copying elements from both into an array and using Build-Heap, which has a linear time complexity of O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given two max heaps of size n each, what is the minimum possible time complexity to make a one max-heap of size from elements of two max heaps?, , Choices: ['A\\nO(n²)', 'B\\nO(n log log n)', 'C\\nO(n)', 'D\\nO(n log n)'], Answer: C\nO(n)"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Skew heaps are self-adjusting heaps where operations like insert and delete have an amortized time of O(log n), but the worst-case time complexity can reach O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The worst case running time of all operations in a skew heap is given as?\na) O(n)\nb) O(n log n)\nc) O(n²)\nd) O(m log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: When searching through k+1 auxiliary trees, such as in the union-find structure with trees, the time complexity per operation can be O(log log n), making total complexity (k+1)·O(log log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for searching k+1 auxiliary trees?\na) (k+2) O(log log n)\nb) (k+1) O(log n)\nc) (k+2) O(log n)\nd) (k+1) O(log log n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Substring checking (e.g., using KMP or Rabin-Karp algorithms) can be done in linear time, i.e., O(n), where n is the length of the string.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a time complexity for checking a string of length n is substring or not?\na) O(log n!)\nb) O(n!)\nc) O(n²)\nd) O(n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In the worst case, a query operation over a set of n elements (e.g., a linear scan or unindexed search) can take O(n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of query operation (n is the number of candidates)?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In simple chaining used for hash tables, a doubly linked list can make deletion more efficient by allowing constant-time removal without needing to search for the previous node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In simple chaining, what data structure is appropriate?\na) Singly linked list\nb) Doubly linked list\nc) Circular linked list\nd) Binary trees\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a circular linked list, inserting at the head takes O(n) if there's no tail pointer. Thus, it's not O(1) unless special conditions apply, making option b false.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is false about a circular linked list?\na) Every node has a successor\nb) Time complexity of inserting a new node at the head of the list is O(1)\nc) Time complexity for deleting the last node is O(n)\nd) We can traverse the whole circular linked list by starting from any point\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: Binary search has a worst-case complexity of O(log n), which is significantly better than linear search. However, in edge cases (like unsorted data), both may fall back to linear scanning.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The worst case complexity of binary search matches with ………, , Choices: ['A\\ninterpolation search', 'B\\nlinear search', 'C\\nmerge sort', 'D\\nnone of the above'], Answer: B\nlinear search"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Building a heap from an array using the bottom-up approach (heapify) has time complexity O(n), but if each insert is done individually, the complexity is O(n log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An array consists of n elements. We want to create a heap using the elements. The time complexity of building a heap will be in order of\na) O(n² log n)\nb) O(n log n)\nc) O(n²)\nd) O(n log² n)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Tango trees are a type of binary search tree that achieve a competitive ratio of O(log log n) using preferred path decomposition and auxiliary trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of for achieving competitive ratio by tango tree?\na) O(log n)\nb) O(n²)\nc) O(n!)\nd) O(log log n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In an adjacency list representation, checking if an edge exists between two vertices may require scanning the list of one vertex, resulting in O(degree) = O(E) in worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Time complexity to check if an edge exists between two vertices would be ___________\na) O(V²)\nb) O(V + E)\nc) O(1)\nd) O(E)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Deleting an arbitrary node from a binary heap involves locating the node (O(n)), replacing it with the last node, and then heapifying (O(log n)). Combined worst-case: O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The worst case complexity of deleting any arbitrary node value element from heap is __________\na) O(log n)\nb) O(n)\nc) O(n log n)\nd) O(n²)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: If each bin has a constant number of candidates and m bins are checked, the time complexity of insertion is proportional to the number of bins: O(m).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the time complexity of insertion operation if all the candidates are evenly spaced so that each bin has constant no. of candidates? (m = number of bins intersecting candidate intersects)\na) O(1)\nb) O(m)\nc) O(m²)\nd) O(log m)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Inserting an alphabet into a tree-like structure using a hash map can be done in constant time assuming ideal hashing and constant-time insert in each map level.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a time complexity for inserting an alphabet in the tree using hash maps?\na) O(log n!)\nb) O(n!)\nc) O(n²)\nd) O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: Quick Sort is a classic example of the Divide and Conquer design paradigm where the array is divided into parts based on a pivot, and each part is recursively sorted.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The quick sort algorithm exploit ……… design technique., , Choices: ['A\\nGreedy', 'B\\nDynamic programming', 'C\\nDivide and Conquer', 'D\\nBacktracking'], Answer: C\nDivide and Conquer"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Segregating positive and negative numbers in an array can be done using a partitioning approach similar to Quick Sort’s partition step, achieving linear time O(N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider an array consisting of –ve and +ve numbers. What would be the worst case time complexity of an algorithm to segregate the numbers having same sign altogether i.e all +ve on one side and then all -ve on the other ?, , Choices: ['A\\nO(N)', 'B\\nO(N Log N)', 'C\\nO(N * N)', 'D\\nO(N Log Log N)'], Answer: A\nO(N)"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The Van Emde Boas tree supports insertion, deletion, and search operations in O(log log M) time, where M is the size of the universe of keys.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for deleting a key or integer in Van Emde Boas data structure?\na) O(log M!)\nb) O(log log M)\nc) O(M!)\nd) O(M²)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Reversing a word using a stack involves pushing each character and then popping them to reverse the order. This process takes linear time O(N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of reversing a word using stack algorithm?\na) O(N log N)\nb) O(N²)\nc) O(N)\nd) O(M log N)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Rope data structures are used for efficient string manipulation, especially insertions and concatenations, which can be done in O(log n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for inserting the string and forming a new string in the rope data structure?\na) O(log n)\nb) O(n!)\nc) O(n²)\nd) O(1)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Using two stacks to implement a double-ended queue (deque) involves constant time O(1) for operations at the top, but may require O(n) for operations at the opposite end due to shifting.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A double-ended queue supports operations like adding and removing items from both the sides of the queue. They support four operations like addFront(adding item to top of the queue), addRear(adding item to the bottom of the queue), removeFront(removing item from the top of the queue) and removeRear(removing item from the bottom of the queue). You are given only stacks to implement this data structure. You can implement only push and pop operations. What’s the time complexity of performing addFront and addRear? (Assume ‘m’ to be the size of the stack and ‘n’ to be the number of elements)\na) O(m) and O(n)\nb) O(1) and O(n)\nc) O(n) and O(1)\nd) O(n) and O(m)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Merge Sort is the most suitable sorting algorithm for linked lists due to its efficient O(n log n) time and ability to be implemented without random access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity?\na) Insertion Sort\nb) Quick Sort\nc) Heap Sort\nd) Merge Sort\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: When chaining is implemented using a list head, the worst-case scenario occurs when all keys hash to the same bucket, requiring a linear search through a linked list, giving O(n) time for insertion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of insert function in the hash table when the list head is used for chaining?\na) O(1)\nb) O(n log n)\nc) O(log n)\nd) O(n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Merge Sort is the optimal sorting algorithm for linked lists because it doesn’t require random access and maintains O(n log n) time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity?, , Choices: ['A\\nInsertion Sort', 'B\\nQuick Sort', 'C\\nHeap Sort', 'D\\nMerge Sort'], Answer: D\nMerge Sort"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The naive method to count inversions in an array is to use two nested loops, leading to O(n²) time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of the following code that determines the number of inversions in an array?\n\na) O(n)\nb) O(n log n)\nc) O(n²)\nd) O(log n)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: In a queue implemented with an array or linked list, enqueue (insertion at the rear) takes constant time O(1) in the average and worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of enqueue operation?\na) O(log n)\nb) O(n log n)\nc) O(n)\nd) O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: If elements are evenly distributed among bins, deletion from a bin takes O(m), where m is the number of bins intersected during deletion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the time complexity of delete operation if all the candidates are evenly spaced so that each bin has constant number of candidates? (m = number of bins intersecting candidate intersects)\na) O(1)\nb) O(m)\nc) O(m²)\nd) O(log m)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: One key advantage of chained hashing (external hashing) over open addressing is ease of deletion, as linked list operations allow direct removal without shifting elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An advantage of chained hash table (external hashing) over the open addressing scheme is, , Choices: ['A\\nWorst case complexity of search operations is less', 'B\\nSpace used is less', 'C\\nDeletion is easier', 'D\\nNone of the above'], Answer: C\nDeletion is easier"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Rope data structures allow efficient editing of large strings. Deletion in a rope takes O(log n) time by splitting and concatenating balanced tree nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for deleting the string to form a new string in the rope data structure?\na) O(n²)\nb) O(n!)\nc) O(log n)\nd) O(1)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: In a priority queue, inserting a node based on position (priority) may require traversing or adjusting elements, resulting in worst-case linear time complexity O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity to insert a node based on position in a priority queue?\na) O(n log n)\nb) O(log n)\nc) O(n)\nd) O(n²)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Hash tables typically offer constant average-case time complexity for insert, delete, and search operations, which is better than the O(log n) average of balanced BSTs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the advantage of a hash table over BST?\na) hash table has a better average time complexity for performing insert, delete and search operations\nb) hash table requires less space\nc) range query is easy with hash table\nd) easier to implement\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: Selection sort has the same time complexity in best, average, and worst cases—O(n²)—making it the slowest among common algorithms even in the best case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the sorting techniques has highest best-case runtime complexity?, , Choices: ['A\\nQuick sort', 'B\\nSelection sort', 'C\\nInsertion sort', 'D\\nBubble sort'], Answer: B\nSelection sort"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Circular linked lists are commonly used in CPU scheduling (Round Robin) because they allow the scheduler to cycle through processes efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following application makes use of a circular linked list?, , Choices: ['A\\nUndo Operation', 'B\\nRecursive function calls', 'C\\nAllocating CPU to resources', 'D\\nImplement Hash Tables'], Answer: C\nAllocating CPU to resources"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In the worst case, searching a singly linked list requires traversing all n nodes to find a specific element, resulting in O(n) comparisons.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In the worst case, the number of comparisons needed to search a singly linked list of length n for a given element is, , Choices: ['A\\nlog(2*n)', 'B\\nn/2', 'C\\nlog(2*n) - 1', 'D\\nn'], Answer: D\nn"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The average-case height of a binary search tree is O(log n) when nodes are inserted in random order, making searches and updates efficient.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the average case time complexity for finding the height of the binary tree?\na) h = O(log log n)\nb) h = O(n log n)\nc) h = O(n)\nd) h = O(log n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In a hash table using a binary tree (e.g., in chaining), delete operations in a balanced binary search tree take O(log n) time, not constant.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of the delete function in the hash table using a binary tree?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: A hash tree (Merkle tree) is used for data synchronization and verification. In the worst case, all nodes may need to be compared, resulting in O(n) time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Hash tree is used in data synchronisation. In the worst case the data synchronisation takes ______ time.\na) O(log n)\nb) O(n²)\nc) O(n log n)\nd) O(n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a ternary heap, each node has three children, so the height is log base 3 of n. Deleting the root requires bubbling down and comparing up to 3 children per level, giving time complexity O(3 log n / log 3).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for deleting root key in a ternary heap of n elements?\na) O(log n / log 3)\nb) O(3 log n / log 3)\nc) O(n)\nd) O(1)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Balancing parentheses requires traversing the string once and using a stack or counter, resulting in O(n) time complexity where n is the string length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of balancing parentheses algorithm?\na) O(n)\nb) O(n log n)\nc) O(m log n)\nd) O(n²)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Given a postorder traversal of a BST, it is possible to reconstruct the unique tree in O(n) time using a stack and recursion-based strategy.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "You are given the postorder traversal, P, of a binary search tree on the n elements 1, 2, ..., n. You have to determine the unique binary search tree that has P as its postorder traversal. What is the time complexity of the most efficient algorithm for doing this?, , Choices: ['A\\nO(log n)', 'B\\nO(n)', 'C\\nO(n log n)', 'D\\nNone of the above, as the tree cannot be uniquely determined.'], Answer: B\nO(n)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Binary tree sort using a self-balancing BST ensures sorted output and guarantees O(n log n) time in the worst case by keeping the tree balanced.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The binary tree sort implemented using a self–balancing binary search tree takes ______ time in worst case.\na) O(n log n)\nb) O(n)\nc) O(n²)\nd) O(log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a circular linked list, all nodes are connected in a circle, making it appear as though there is no true beginning or end.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a circular linked list:, , Choices: ['A\\nComponents are all linked together in some sequential manner.', 'B\\nThere is no beginning and no end.', 'C\\nComponents are arranged hierarchically.', 'D\\nForward and backward traversal within the list is permitted.'], Answer: B\nThere is no beginning and no end."
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: In a self-organizing list with linear search, the worst-case scenario requires traversing all elements, giving O(n) time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The worst case running time of a linear search on the self-organizing list is ____\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n²)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: Linear search checks each element sequentially until the target is found or the end is reached, resulting in a worst-case time complexity of Θ(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of linear search algorithm?, , Choices: ['A\\nΘ(1)', 'B\\nΘ(n)', 'C\\nΘ(log n)', 'D\\nΘ(n²)'], Answer: B\nΘ(n)"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a ternary heap, each node has 3 children. Increasing the priority of a key involves bubbling it up the tree, which takes O(log n / log 3) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for increasing priority of key in a maximum ternary heap of n elements?\na) O(log n / log 3)\nb) O(n!)\nc) O(n)\nd) O(1)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: The worst case of Quick Sort occurs when the pivot selection leads to unbalanced partitions, causing O(n²) time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The worst case of quick sort has order ………., , Choices: ['A\\nO(n²)', 'B\\nO(n)', 'C\\nO(n log² n)', 'D\\nO(log² n)'], Answer: A\nO(n²)"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Fibonacci Series (with memoization), Tower of Hanoi (recursive), and Dijkstra’s algorithm all demonstrate dynamic programming principles when overlapping subproblems exist.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is an example of dynamic programming approach?, , Choices: ['A\\nFibonacci Series', 'B\\nTower of Hanoi', 'C\\nDijkstra’s Shortest Path', 'D\\nAll of the above'], Answer: D\nAll of the above"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Chaining in hashing is less sensitive to the choice of hash function because collisions are handled using separate lists rather than probing schemes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the advantage of hashing with chaining?\na) cache performance is good\nb) uses less space\nc) less sensitive to hash function\nd) has a time complexity of O(n) in the worst case\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Red-black tree constraints (black height balance, red child rule) ensure logarithmic tree height, guaranteeing O(log n) time complexity for operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Why do we impose restrictions like:\n- root property is black\n- every leaf is black\n- children of red node are black\n- all leaves have same black height\n\na) to get logarithm time complexity\nb) to get linear time complexity\nc) to get exponential time complexity\nd) to get constant time complexity\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Both AVL trees and B-trees maintain balanced structures that ensure logarithmic time complexity O(log n) in the worst case for insertion and deletion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "B-tree and AVL tree have the same worst case time complexity for insertion and deletion.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Merge Sort can be used to count inversions in an array efficiently. This modified version runs in O(n log n) time by counting inversions during the merge step.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of the code that uses merge sort for determining the number of inversions in an array?\na) O(n²)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The juggling algorithm for array rotation performs element swaps based on the greatest common divisor (GCD) of the array size and rotation steps. Its time complexity is O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of the juggling algorithm to rotate an array?\na) O(1)\nb) O(n)\nc) O(d)\nd) O(n·d)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Converting infix expressions to postfix (Reverse Polish Notation) using a stack-based algorithm can be done in linear time O(n), where n is the length of the expression.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of an infix to postfix conversion algorithm?\na) O(n log n)\nb) O(n)\nc) O(n²)\nd) O(m log n)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Inserting into a doubly linked list takes O(1) time if the pointer to the insertion point is known. However, finding the correct position can take O(n) in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of inserting a node in a doubly linked list?\na) O(n log n)\nb) O(log n)\nc) O(n)\nd) O(1)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Finding the most frequent substring of a given minimum length can be done using a sliding window and hashmap or suffix tree in linear time O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a time complexity for finding frequently occurring substring of minimum length in a string?\na) Θ(n)\nb) Θ(n!)\nc) O(n² + n)\nd) O(log n!)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a balanced binary search tree with 2ⁿ elements, search operations take time proportional to the tree height, which is O(log n). So the worst-case time is Θ(log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The worst case running time to search for an element in a balanced binary search tree with n = 2^k elements is:\na) Θ(n log n)\nb) Θ(n·2ⁿ)\nc) Θ(n)\nd) Θ(log n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Reversing a string involves swapping characters from both ends toward the center, which takes O(n) time where n is the string length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity to reverse a string?, , Choices: ['A\\nO(n²)', 'B\\nO(1)', 'C\\nO(log n)', 'D\\nO(n)'], Answer: D\nO(n)"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The provided code rotates an array to the left by `d` positions using a loop that shifts elements one-by-one `d` times. Each shift takes O(n), and it runs d times, resulting in O(n*d) complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the time complexity of the following code?\n\n<code snippet>\n\n\na) O(n*d)\nb) O(n)\nc) O(d)\nd) O(n²)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In rope data structures, creating a new node and concatenating ropes are done using tree operations that can take O(1) time when no balancing is required.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for creating a new node and then performing concatenation in the rope data structure?\na) O(log n)\nb) O(n!)\nc) O(n²)\nd) O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: Bubble Sort performs pairwise comparisons and swaps in nested loops, giving a worst-case time complexity of O(n²).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider that n elements are to be sorted. What is the worst case time complexity of Bubble sort?, , Choices: ['A\\nO(1)', 'B\\nO(log² n)', 'C\\nO(n)', 'D\\nO(n²)'], Answer: D\nO(n²)"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Floyd’s Cycle Detection algorithm (also known as the Tortoise and Hare algorithm) detects cycles using two pointers moving at different speeds, making it highly efficient.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider a small circular linked list. How to detect the presence of cycles in this list effectively?, , Choices: ['A\\nKeep one node as head and traverse another temp node till the end to check if its ‘next’ points to head', 'B\\nHave fast and slow pointers with the fast pointer advancing two nodes at a time and slow pointer advancing by one node at a time', 'C\\nCannot determine, you have to pre-define if the list contains cycles', 'D\\nCircular linked list itself represents a cycle. So no new cycles cannot be generated'], Answer: B\nHave fast and slow pointers with the fast pointer advancing two nodes at a time and slow pointer advancing by one node at a time"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In circular linked lists, nodes are linked in a loop without a terminating NULL, and traversal can start at any point. Valid statements about their structure often include loop-based properties like P1 and P4.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following Statement is correct about Circular Linked List?, , Choices: ['A\\nOnly P4', 'B\\nOnly P1', 'C\\nP1 and P2', 'D\\nP1 and P4.'], Answer: D\nP1 and P4."
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In array-based stack implementations, the pop operation simply decrements the index (top pointer) and is therefore done in constant time, O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of pop() operation when the stack is implemented using an array?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Inserting a node at the beginning of a linked list requires changing the head pointer and the next pointer of the new node, which is a constant time O(1) operation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity to insert a node at the beginning of the list?, , Choices: ['A\\nO(log n)', 'B\\nO(n)', 'C\\nO(1)', 'D\\nNone'], Answer: C\nO(1)"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A self-balancing binary search tree (BST) can be used to count the number of inversions in an array in O(n log n) time by keeping track of inserted elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of the code that uses self-balancing BST for determining the number of inversions in an array?\na) O(n²)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a hash table with chaining using doubly linked lists, insertions occur at the head or tail of the list and take constant time, i.e., O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of insert function in a hash table using a doubly linked list?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Implementing a queue using two stacks requires moving all elements during the dequeue operation. If `m` elements exist, dequeue takes O(m) time in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "You are asked to perform a queue operation using a stack. Assume the size of the stack is some value ‘n’ and there are ‘m’ number of variables in this stack. The time complexity of performing deQueue operation is (Using only stack operations like push and pop) (Tightly bound).\na) O(m)\nb) O(n)\nc) O(m·n)\nd) Data is insufficient\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The worst-case height of an AVL tree is approximately 1.44 log₂(n), where n is the number of nodes. This follows from AVL balancing rules.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case possible height of AVL tree?, , Choices: ['A\\n2 log n (Assume base of log is 2)', 'B\\n1.44 log n (Assume base of log is 2)', 'C\\nDepends upon implementation', 'D\\nΘ(n)'], Answer: B\n1.44 log n (Assume base of log is 2)"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In a hash tree (e.g., Merkle tree), insertion can involve O(logₖ(n)) time, where k is the arity of the tree and n is the number of elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of the insertion in the hash tree?\na) O(logₖ(n))\nb) O(n²)\nc) O(n logₖ(n))\nd) O(k·n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a suffix tree, the number of nodes in the worst case is 2n where n is the length of the string, because each suffix may form a new branch.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "For what size of nodes, the worst case of usage of space in suffix tree seen?\na) n Nodes\nb) 2n Nodes\nc) 2n nodes\nd) n! nodes\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a ternary heap, increasing a key’s priority may require bubbling it up through levels. The height is log base 3 of n, and with up to 3 comparisons per level, time is O(3 log n / log 3).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for increasing priority of key in a minimum ternary heap of n elements?\na) O(log n / log 3)\nb) O(3 log n / log 3)\nc) O(n)\nd) O(1)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: To check if a graph is bipartite using an adjacency matrix, we perform BFS or DFS which runs in O(V²) time due to the dense matrix representation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would the time complexity to check if an undirected graph with V vertices and E edges is Bipartite or not given its adjacency matrix?\na) O(E²)\nb) O(V²)\nc) O(E)\nd) O(V)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Merge Sort is preferred for sorting linked lists because it does not require random access and maintains O(n log n) time complexity in all cases.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following sorting algorithms can be used to sort a random linked list with minimum time complexity?\na) Insertion Sort\nb) Quick Sort\nc) Heap Sort\nd) Merge Sort\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Dynamic Programming uses memoization to store intermediate results of subproblems, which helps avoid redundant computations and improve efficiency.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following uses memorization?, , Choices: ['A\\nGreedy approach', 'B\\nDivide and conquer approach', 'C\\nDynamic programming approach', 'D\\nNone of the above'], Answer: C\nDynamic programming approach"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a balanced BST, reporting all elements in a range [a, b] requires a traversal to the range (O(log n)) and printing k elements, resulting in Θ(log n + k) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a balanced binary search tree with n elements, what is the worst-case time complexity of reporting all elements in the range [a,b]? Assume that the number of reported elements is k., , Choices: ['A\\nΘ(log n)', 'B\\nΘ(log n + k)', 'C\\nΘ(k log n)', 'D\\nΘ(n log k)'], Answer: B\nΘ(log n + k)"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The Van Emde Boas tree supports operations like finding the minimum and maximum in constant O(1) time due to its structure and recursive splitting of the universe.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for finding a maximum and minimum integer in Van Emde Boas data structure?\na) O(log M!)\nb) O(M!)\nc) O(1)\nd) O(log log M)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Finding all maximal palindromes in a string can be done in linear time O(n) using Manacher’s algorithm.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a time complexity for finding all the maximal palindrome in a string?\na) Θ(n)\nb) Θ(n!)\nc) Θ(1)\nd) O(log n!)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Building a ternary heap (heap with 3 children per node) using a bottom-up heapify approach takes linear time O(n), similar to binary heaps.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for creating a ternary heap using swapping?\na) O(log n / log 3)\nb) O(n!)\nc) O(n)\nd) O(1)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: Interpolation search is efficient on uniformly distributed, sorted data. It achieves a time complexity of Θ(log log n) in the best case when distribution is ideal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If the data collection is in sorted form and equally distributed then the run time complexity of interpolation search is ………, , Choices: ['A\\nΘ(n)', 'B\\nΘ(1)', 'C\\nΘ(log n)', 'D\\nΘ(log log n)'], Answer: D\nΘ(log log n)"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Inserting at the beginning of a triply linked list (similar to a doubly linked list but with an extra pointer) still takes O(1) time when the pointer to the head is known.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which among the following is the time complexity for inserting at the beginning of a triply linked list?\na) O(n)\nb) O(1)\nc) O(log n)\nd) O(n²)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Floyd’s Cycle Detection Algorithm (fast and slow pointers) is the most efficient method to detect cycles in a circular or general linked list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider a small circular linked list. How to detect the presence of cycles in this list effectively?\na) Keep one node as head and traverse another temp node till the end to check if its ‘next’ points to head\nb) Have fast and slow pointers with the fast pointer advancing two nodes at a time and slow pointer advancing by one node at a time\nc) Cannot determine, you have to pre-define if the list contains cycles\nd) Circular linked list itself represents a cycle. So no new cycles cannot be generated\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Rope data structures enable efficient string manipulation. Splitting a string in a rope (balanced binary tree) can be done in O(log n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for splitting the string into two new strings in the rope data structure?\na) O(n²)\nb) O(n!)\nc) O(log n)\nd) O(1)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Finding x-pattern occurrences of length n can be done in Θ(n + x) time using pattern matching algorithms like KMP or Aho-Corasick.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a time complexity for x pattern occurrence of length n?\na) O(log n!)\nb) Θ(n!)\nc) O(n²)\nd) Θ(n + x)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Skip lists offer logarithmic time complexities similar to balanced binary search trees for insert, delete, and search operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "To which data structure are skip lists similar in terms of time complexities in worst and best cases?\na) balanced binary search trees\nb) binary search trees\nc) binary trees\nd) linked lists\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In an adjacency matrix, each vertex is checked against all others, resulting in O(V²) time to compute or count edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The time complexity to calculate the number of edges in a graph whose information is stored in form of an adjacency matrix is ____________\na) O(V)\nb) O(E²)\nc) O(E)\nd) O(V²)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: Quick Sort uses the Divide and Conquer paradigm, where the array is partitioned recursively based on pivots.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Quick sort algorithm is an example of ………., , Choices: ['A\\nGreedy approach', 'B\\nImproved binary search', 'C\\nDynamic Programming', 'D\\nDivide and conquer'], Answer: D\nDivide and conquer"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a singly linked list, deleting a node is O(1) if a pointer to the node and its previous node is already available. This is the best-case time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the best case time complexity of deleting a node in a Singly Linked list?\na) O(n)\nb) O(n²)\nc) O(n log n)\nd) O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In the worst case, deleting an element from an unsorted data structure may require scanning all elements, resulting in O(n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of delete operation (n is the number of candidates)?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a hash table using chaining with doubly linked lists, insertion is done at the head or tail in O(1) time, and search operations can also be optimized to O(1) under ideal hashing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of search function in a hash table using a doubly linked list?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The provided code implements a dynamic programming solution to find the minimum number of jumps needed to reach the end of an array. The two nested loops result in O(n²) time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the time complexity of the following code?\n\n<code omitted for brevity>\n\na) O(n log n)\nb) O(n)\nc) O(√n)\nd) O(n²)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: A skew heap uses recursion to perform merges. A recursive implementation can fail if the stack depth exceeds limits, especially in degenerate cases. Hence, stack space becomes a limitation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Why would a recursive implementation fail in skew heaps?\na) skew heaps are self adjusting\nb) efficiency gets reduced\nc) lack of stack space\nd) time complexity\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Red-Black Trees provide logarithmic time complexity for insert, delete, and search operations, including finding predecessor and successor.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are the operations that could be performed in O(log n) time complexity by red-black tree?\na) insertion, deletion, finding predecessor, successor\nb) only insertion\nc) only finding predecessor, successor\nd) for sorting\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Free memory blocks in memory management systems are typically maintained in a circular linked list and organized by increasing address to support merging of adjacent blocks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How are free blocks linked together mostly and in what addressing order?\na) circular linked list and increasing addressing order\nb) linked list and decreasing addressing order\nc) linked list and in no addressing order\nd) none of the mentioned\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Performing Θ(N) delete, O(log N) insert and find, and Θ(N) decrease-key operations on a sorted doubly linked list gives an overall complexity of O(N log N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "N items are stored in a sorted doubly linked list. For a delete operation, a pointer is provided to the record to be deleted. For a decrease-key operation, a pointer is provided to the record on which the operation is to be performed. An algorithm performs the following operations on the list in this order: Θ(N) delete, O(log N) insert, O(log N) find, and Θ(N) decrease-key. What is the time complexity of all these operations put together?, , Choices: ['A\\nO(log² N)', 'B\\nO(N)', 'C\\nO(N log N)', 'D\\nΘ(N² log N)'], Answer: C\nO(N log N)"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Circular linked lists are often used in CPU scheduling, such as round-robin schedulers, to allocate time slices to multiple processes in a loop.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following application makes use of a circular linked list?\na) Recursive function calls\nb) Undo operation in a text editor\nc) Implement Hash Tables\nd) Allocating CPU to resources\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The naive nearest neighbor search in an unsorted list of N items requires scanning all points, resulting in O(N) time in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of finding the nearest neighbour?\na) O(N)\nb) O(N log N)\nc) O(log N)\nd) O(N³)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The provided code includes nested loops. The outer loop runs O(n) and the inner loop may also run O(n), giving a worst-case time complexity of O(n²).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the worst case time complexity of the following code?\n\n<code omitted>\n\na) O(√n)\nb) O(n)\nc) O(n^{3/2})\nd) O(n²)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: The time complexity of BFS traversal is O(V + E). If a graph has n vertices and n^1.25 edges, then BFS will run in O(n^1.25).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the time complexity of the BFS traversal of a graph with n vertices and n¹·²⁵ edges?\na) O(n)\nb) O(n¹·²⁵)\nc) O(n²·²⁵)\nd) O(n²)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: When you need to access an element at a specific index in constant time, array-based representations are the best choice as they provide direct access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What kind of linked list is best to answer questions like “What is the item at position n?”\na) Singly linked list\nb) Doubly linked list\nc) Circular linked list\nd) Array implementation of linked list\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Maintaining dynamic sets of weighted trees using advanced data structures (like union-find with union by rank and path compression) can be achieved in O(log n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for maintaining a dynamic set of weighted trees?\na) O(n)\nb) O(n²)\nc) O(log n)\nd) O(n!)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a circular linked list, the last node's 'next' pointer points back to the head instead of NULL, ensuring the list loops continuously.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What differentiates a circular linked list from a normal linked list?\na) You cannot have the ‘next’ pointer point to null in a circular linked list\nb) It is faster to traverse the circular linked list\nc) In a circular linked list, each node points to the previous node instead of the next node\nd) Head node is known in circular linked list\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In an unrolled linked list, insertion may require shifting elements in the array part or splitting nodes, which could take linear time O(n) in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which among the following is the time complexity for inserting an element in an unrolled linked list?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n²)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a ternary heap (where each node has 3 children), decreasing a key’s priority involves bubbling up, taking O(log n / log 3) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for decreasing priority of key in a minimum ternary heap of n elements?\na) O(log n / log 3)\nb) O(n!)\nc) O(n)\nd) O(1)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The recursive solution for the 0/1 Knapsack problem uses a brute-force approach, exploring all combinations. The final value depends on correct implementation and inputs. Based on standard 0/1 Knapsack inputs, the correct output might be 300.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following dynamic programming code snippet for solving the 0/1 Knapsack problem:\n\ndef knapsack(values, weights, capacity, n):\n    if n == 0 or capacity == 0:\n        return 0\n    if weights[n-1] > capacity:\n        return knapsack(values, weights, capacity, n-1)\n    else:\n        return max(values[n-1] + knapsack(values, weights, capacity - weights[n-1], n-1),\n                   knapsack(values, weights, capacity, n-1))\n\nWhat is the maximum value obtained if capacity = 50, values = [60, 100, 120], weights = [10, 20, 30]?\nChoices: ['A\\n180', 'B\\n220', 'C\\n280', 'D\\n300']\n\nAnswer: D\n300"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: In a priority queue implemented using a linear array, insertion based on key requires scanning for the correct position, leading to O(n) time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity to insert a node based on key in a priority queue?\na) O(n log n)\nb) O(log n)\nc) O(n)\nd) O(n²)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Pairing heaps are self-adjusting heaps. Their time complexity analysis was inspired by that of splay trees, which also use amortized analysis.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Pairing heaps time complexity was inspired by that of?\na) splay tree\nb) treap\nc) red-black tree\nd) avl tree\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In chaining with a list head, inserting at the beginning of the linked list takes constant time O(1) under ideal hashing assumptions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of insert function in a hash table using list head?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: Van Emde Boas trees offer fast operations for search, insert, and delete in O(log log M) time, where M is the universe size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for searching a key or integer in Van Emde Boas data structure?\na) O(M!)\nb) O(log M!)\nc) O(log log M)\nd) O(M²)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Hashing provides O(1) time complexity on average for search operations, assuming a good hash function and low collision rate.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which searching technique takes O(1) time complexity for searching the data?, , Choices: ['A\\nBinary Search', 'B\\nLinear Search', 'C\\nAVL Tree Search', 'D\\nHashing'], Answer: D\nHashing"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: In the worst case (e.g., sorted input), Quick Sort’s partitioning may lead to unbalanced recursion, giving time complexity O(n²/2).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In worst case Quick Sort has order ………., , Choices: ['A\\nO(n log n)', 'B\\nO(n²/2)', 'C\\nO(log n)', 'D\\nO(n²/4)'], Answer: B\nO(n²/2)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In dynamic tree structures like auxiliary trees (used in link-cut trees), update operations (e.g., link, cut) can have amortized time complexity of O(log log n), depending on implementation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for the update cost on auxiliary trees?\na) O(log log n)\nb) (k−1) O(log n)\nc) k² O(log n)\nd) (k+1) O(log log n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Counting inversions using Merge Sort is more efficient (O(n log n)) than using a nested loop approach (O(n²)), thus giving better performance for large arrays.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The time complexity of the code that determines the number of inversions in an array using merge sort is lesser than that of the code that uses loops for the same purpose.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: Adding an edge to an adjacency list takes constant time O(1) since it involves pushing to the back of a vector.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the time complexity of the following function which adds an edge between two vertices i and j, with some weight ‘weigh’ to the graph having V vertices?\n\n<code omitted>\n\na) O(1)\nb) O(V)\nc) O(V²)\nd) O(log V)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In a Directed Acyclic Word Graph (DAWG), checking if S1 is a substring of S2 takes O(|S1|) time as it depends only on the length of the pattern string.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity to check if a string (length S1) is a substring of another string (length S2) stored in a Directed Acyclic Word Graph, given S2 > S1?\na) O(S1)\nb) O(S2)\nc) O(S1 + S2)\nd) O(1)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Inserting n elements into a sorted linked list one by one requires traversal for each insert, resulting in a total time of Θ(n²) in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of inserting n elements into an empty linked list, if the linked list needs to be maintained in sorted order?, , Choices: ['A\\nΘ(n)', 'B\\nΘ(n log n)', 'C\\nΘ(n²)', 'D\\nΘ(1)'], Answer: C\nΘ(n²)"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Converting prefix notation to infix using a stack-based approach processes each token once, resulting in O(n) time where n is the number of symbols.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The time complexity of converting a prefix notation to infix notation is _________\na) O(n) where n is the length of the equation\nb) O(n) where n is number of operands\nc) O(1)\nd) O(log n) where n is length of the equation\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The Tower of Hanoi problem has exponential time complexity O(2ⁿ), making it one of the slowest recursive algorithms with the highest runtime.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Program with highest run-time complexity is ………….., , Choices: ['A\\nTower of Hanoi', 'B\\nFibonacci Series', 'C\\nPrime Number Series', 'D\\nNone of these'], Answer: A\nTower of Hanoi"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Van Emde Boas trees support operations like insert, delete, and search in O(log log M) time, where M is the universe size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for inserting a key or integer in Van Emde Boas data structure?\na) O(log M!)\nb) O(M!)\nc) O(M²)\nd) O(log log M)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Inserting an element at the front of a linked list when the head is known is a constant-time operation, as no traversal is needed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What would be the asymptotic time complexity to insert an element at the front of the linked list (head is known)?\na) O(1)\nb) O(n)\nc) O(n²)\nd) O(n³)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The Θ (Theta) notation in asymptotic analysis represents the tight bound, usually associated with the average case but also applies when upper and lower bounds match.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The Θ notation in asymptotic evaluation represents ……….., , Choices: ['A\\nBase case', 'B\\nAverage case', 'C\\nWorst case', 'D\\nNULL case'], Answer: B\nAverage case"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The Floyd-Warshall algorithm is a dynamic programming-based algorithm used to find the shortest paths between all pairs of vertices in O(V³) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Floyd Warshall Algorithm used to solve the shortest path problem has a time complexity of __________\na) O(V²)\nb) O(V³)\nc) O(E·V)\nd) O(E²)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Red-Black trees are preferred over AVL trees in scenarios with frequent insertions and deletions because they require fewer rotations and offer faster amortized performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "When would it be optimal to prefer Red-black trees over AVL trees?\na) when there are more insertions or deletions\nb) when more search is needed\nc) when tree must be balanced\nd) when log(nodes) time complexity is needed\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a hash table using chaining with doubly linked lists, deletion is efficient and performed in constant time O(1) if a pointer to the node is provided.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of delete function in the hash table using a doubly linked list?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Evaluating a postfix expression (Reverse Polish Notation) using a stack processes each token once, leading to linear time complexity O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of evaluation of postfix expression algorithm?\na) O(N)\nb) O(N log N)\nc) O(N²)\nd) O(M log N)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The Floyd-Warshall algorithm applies dynamic programming to solve the all-pairs shortest path problem in a weighted graph.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The Floyd-Warshall algorithm for all-pair shortest paths computation is based on:, , Choices: ['A\\nGreedy paradigm.', 'B\\nDivide-and-Conquer paradigm.', 'C\\nDynamic Programming paradigm.', 'D\\nNone of the above.'], Answer: C\nDynamic Programming paradigm."
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In naive merging of two sorted arrays (or lists), each element must be compared and placed into a new array, resulting in a worst-case time complexity of O(N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The worst case analysis for a naïve merge is given as?\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(N²)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a binary search tree (BST), the worst case occurs when the tree becomes skewed, leading to O(n) complexity. The average case for balanced BSTs is O(log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are the worst case and average case complexities of a binary search tree?\na) O(n), O(n)\nb) O(log n), O(log n)\nc) O(log n), O(n)\nd) O(n), O(log n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: If implemented using a circular array, both ENQUEUE and DEQUEUE operations in a queue can be performed in constant time O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A queue is implemented using an array such that ENQUEUE and DEQUEUE operations are performed efficiently. Which one of the following statements is CORRECT (n refers to the number of items in the queue)?, , Choices: ['A\\nBoth operations can be performed in O(1) time', 'B\\nAt most one operation can be performed in O(1) time but the worst case time for the other operation will be Ω(n)', 'C\\nThe worst case time complexity for both operations will be Ω(n)', 'D\\nWorst case time complexity for both operations will be Ω(log n)'], Answer: A\nBoth operations can be performed in O(1) time"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Dijkstra's algorithm implemented using a binary heap and adjacency list has a time complexity of O((|E| + |V|) log |V|).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Let G(V, E) be an undirected graph with positive edge weights. Dijkstra's single-source shortest path algorithm can be implemented using the binary heap data structure with time complexity:, , Choices: ['A\\nO(|V|²)', 'B\\nO(|E| + |V| log |V|)', 'C\\nO(|V| log |V|)', 'D\\nO((|E| + |V|) log |V|)'], Answer: D\nO((|E| + |V|) log |V|)"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Circular linked lists are ideal for applications like CPU scheduling in operating systems, where processes are managed in a circular queue-like structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following application makes use of a circular linked list?\na) Undo operation in a text editor\nb) Recursive function calls\nc) Allocating CPU to resources\nd) Implement Hash Tables\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Inserting or deleting at the beginning of an array requires shifting all elements, resulting in a time complexity of O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for inserting/deleting at the beginning of the array?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: In most queue implementations (especially circular arrays or linked lists), DEQUEUE (removal from the front) is a constant-time O(1) operation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following operations on a queue data structure has a time complexity of O(1)?\n\nA) Enqueue \nB) Dequeue \nC) Peek \nD) Clear, , Choices: ['A\\nA and B', 'B\\nB only', 'C\\nC only', 'D\\nA and D'], Answer: B\nB only"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: If a hash table uses a balanced binary tree for chaining (instead of a linked list), the average search time is O(log n), but if it’s incorrectly assumed the key is always at the root, the worst-case could be O(n). However, under ideal conditions and assuming direct access, some sources may still classify it as O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of the search function in a hash table using a binary tree?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Deleting a node at index i in a binary heap may require both upward and downward heapify operations. The time complexity is O(d), where d is the depth of the heap.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "An operator delete(i) for a binary heap data structure is to be designed to delete the item in the i-th node. Assume that the heap is implemented in an array and i refers to the i-th index of the array. If the heap tree has depth d (number of edges on the path from the root to the farthest leaf), then what is the time complexity to re-fix the heap efficiently after the removal of the element?, , Choices: ['A\\nO(1)', 'B\\nO(d) but not O(1)', 'C\\nO(2d) but not O(d)', 'D\\nO(d2^d) but not O(2d)'], Answer: B\nO(d) but not O(1)"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a circular linked list, the time to search for an element is O(n) in the worst case as each node might have to be visited.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of searching for an element in a circular linked list?\na) O(n)\nb) O(n log n)\nc) O(1)\nd) O(n²)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In direct address tables, insertion takes O(1) time as each key maps directly to a slot based on its value.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity to insert an element into the direct address table?\na) O(n)\nb) O(log n)\nc) O(n log n)\nd) O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The top tree is a dynamic tree structure. Initializing it requires constructing subtrees for each node, which takes O(n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for the initialization of top tree?\na) O(n)\nb) O(n²)\nc) O(log n)\nd) O(n!)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Using a self-balancing BST to count inversions in an array reduces the time complexity from O(n²) in nested loops to O(n log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The time complexity of the code that determines the number of inversions in an array using self-balancing BST is lesser than that of the code that uses loops for the same purpose.\na) true\nb) false\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: Binary search divides the search space in half at each step, resulting in a worst-case time complexity of Θ(log n), not Θ(n). The original answer may be incorrect.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case run-time complexity of binary search algorithm?, , Choices: ['A\\nΘ(n²)', 'B\\nΘ(n log n)', 'C\\nΘ(n³)', 'D\\nΘ(n)'], Answer: D\nΘ(n)"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Inserting into a sorted array in the worst case requires shifting all elements after the insertion point, resulting in O(n) time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of inserting an element into the sorted array?\na) O(n log n)\nb) O(log n)\nc) O(n)\nd) O(n²)\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In the worst case, inserting or deleting elements at the end of a dynamic array requires resizing, which takes O(n) time. However, this is amortized and not typical.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In special case, the time complexity of inserting/deleting elements at the end of dynamic array is __________\na) O(n)\nb) O(√n)\nc) O(log n)\nd) O(1)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In the best-case and average-case scenarios, inserting into a hash table or direct address table is O(1). Thus, the worst-case insertion can still be O(1) under ideal hashing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time complexity of insertion operation (n = no. of candidates)?\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a binary min heap, operations like insert, delete, and decrease-key are O(log n), but merging with another heap is costlier and takes O(n) if not using specialized structures.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following Binary Min Heap operation has the highest time complexity?, , Choices: ['A\\nInserting an item under the assumption that the heap has capacity to accommodate one more item', 'B\\nMerging with another heap under the assumption that the heap has capacity to accommodate items of other heap', 'C\\nDeleting an item from heap', 'D\\nDecreasing value of a key'], Answer: B\nMerging with another heap under the assumption that the heap has capacity to accommodate items of other heap"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a circular linked list, nodes form a cycle and none of them point to NULL; instead, the last node points to the head.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a circular linked list, how many nodes contain NULL as the address?, , Choices: ['A\\nOnly one node', 'B\\nOnly two nodes', 'C\\nEvery node', 'D\\nNone'], Answer: D\nNone"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: When a graph is represented by an adjacency list, checking whether an edge exists between two vertices may require scanning through the adjacency list, which takes O(V) in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Time complexity to find if there is an edge between 2 particular vertices is _________\na) O(V)\nb) O(E)\nc) O(1)\nd) O(V + E)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Finding the longest repeated substring in a string using suffix arrays or suffix trees can be done in linear time O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a time complexity for finding the longest substring that is repeated in a string?\na) O(log n!)\nb) Θ(n!)\nc) O(n² + n)\nd) Θ(n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Ukkonen’s algorithm constructs a suffix tree in O(n log n) time in the worst case, though it performs better in practice and is often considered linear.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of Ukkonen’s algorithm?\na) O(log n!)\nb) O(n!)\nc) O(n²)\nd) O(n log n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Building a heap is called heapifying. This process organizes the array into a heap by applying the heapify function from the bottom up.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the process of building a ternary heap called?\na) Heapify\nb) Hashing\nc) Linking\nd) Merging\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: When candidates are evenly distributed in bins and a query operation intersects k bins, the total time complexity is O(k).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the time complexity of query operation if all the candidates are evenly spaced so that each bin has constant number of candidates? (k = number of bins query rectangle intersects)\na) O(1)\nb) O(k)\nc) O(k²)\nd) O(log k)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: The optimal algorithm to find the intersection node of two linked lists runs in Θ(m+n) by aligning the traversal length of both lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Suppose there are two singly linked lists both of which intersect at some point and become a single linked list. The head or start pointers of both the lists are known, but the intersecting node and lengths of lists are not known. What is the worst-case time complexity of the optimal algorithm to find the intersecting node from two intersecting linked lists?, , Choices: ['A\\nΘ(n·m)', 'B\\nΘ(n²), where m > n', 'C\\nΘ(m+n)', 'D\\nΘ(min(n, m))'], Answer: C\nΘ(m+n)"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Path compression optimizes disjoint set operations. When combined with union by rank, its worst-case time complexity becomes O(M log N) where M is the number of operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case efficiency for a path compression algorithm?\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(M log N)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: If only the front pointer is maintained in a queue implemented using a linked list, insertion (at rear) and emptying the queue both require O(n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In linked list implementation of queue, if only front pointer is maintained, which of the following operations take worst-case linear time?\na) Insertion\nb) Deletion\nc) To empty a queue\nd) Both Insertion and To empty a queue\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Rotating elements one by one involves shifting the entire array multiple times, making it the most expensive among rotation algorithms with time complexity O(n*d).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following algorithms to rotate an array has the maximum time complexity?\na) Rotate elements one by one\nb) Juggling algorithm\nc) Reversal algorithm\nd) Using a temporary array\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In rope data structures, each operation like finding a character at index x or splitting a string is supported in O(log n) time due to the tree-based representation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for finding the node at x position where n is the length of the rope?\na) O(log n)\nb) O(n!)\nc) O(n²)\nd) O(1)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Although binary tree sort with self-balancing BSTs achieves O(n log n) complexity in the worst case, it can be slower than Merge Sort due to higher constant factors and tree rotations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Binary tree sort implemented using a self-balancing binary search tree takes O(n log n) time in the worst case but is still slower than Merge Sort.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: To construct an AVL tree without rotations, one can sort the input, find the median as root, and build the tree recursively to maintain balance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given an empty AVL tree, how would you construct an AVL tree when a set of numbers is given without performing any rotations?\na) Just build the tree with the given input\nb) Find the median of the set of elements given, make it as root and construct the tree\nc) Use trial and error\nd) Use dynamic programming to build the tree\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The provided C++ code rotates an array using a temporary array, which requires three linear scans, giving overall time complexity of O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the time complexity of the following code?\n\n<code omitted>\n\na) O(d)\nb) O(n)\nc) O(n²)\nd) O(n*d)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In asymptotic notation, expressions with exponential growth (e.g., 2^f(n)) dominate polynomial or linear terms, making 2^Θ(n) worse than Θ(n^3), Θ(n + 9378), or nΘ(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following asymptotic notation is the worst among all?, , Choices: ['A\\nΘ(n+9378)', 'B\\nΘ(n³)', 'C\\nnΘ(1)', 'D\\n2Θ(n)'], Answer: D\n2Θ(n)"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: Finding the longest common substring between two strings S1 and S2 can be done using dynamic programming or suffix automata in Θ(n1 + n2) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for finding the longest substring that is common in strings S1 and S2 (n1 and n2 are the string lengths of S1 and S2 respectively)?\na) O(log n!)\nb) Θ(n!)\nc) O(n² + n₁)\nd) Θ(n₁ + n₂)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: To compute the total length of strings on all edges of a tree (like a suffix tree), we may need to traverse each node and sum string lengths, which can result in O(n²) in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity for finding the total length of all strings on all edges of a tree?\na) Θ(n)\nb) Θ(n!)\nc) Θ(1)\nd) O(n²)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The Bellman-Ford algorithm has a time complexity of Θ(V·E). In a complete graph, E = V(V−1) = Θ(V²), so the total becomes Θ(V·V²) = Θ(V³).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity of Bellman-Ford single-source shortest path algorithm on a complete graph of n vertices?, , Choices: ['A\\nΘ(V²)', 'B\\nΘ(V² log V)', 'C\\nΘ(V³)', 'D\\nΘ(V³ log V)'], Answer: C\nΘ(V³)"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In simple chaining used in hash tables, doubly linked lists are often preferred as they simplify deletion of elements by allowing backward traversal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In simple chaining, what data structure is appropriate?\na) Doubly linked list\nb) Circular linked list\nc) Singly linked list\nd) Binary trees\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: If frequent random access by position is needed, an array-based representation of a linked list provides constant-time O(1) access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What kind of linked list is best to answer questions like “What is the item at position n?”\na) Singly linked list\nb) Doubly linked list\nc) Circular linked list\nd) Array implementation of linked list\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In weak heaps, the minimum element is usually stored at the root. Thus, searching for the minimum value takes constant time O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the worst case time in searching minimum value in weak-heap?\na) O(log n)\nb) O(n)\nc) O(n log n)\nd) O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Direct address tables map keys directly to an index in an array. Deleting an element requires only overwriting the index, so time complexity is O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the time complexity to delete an element from the direct address table?\na) O(n)\nb) O(log n)\nc) O(n log n)\nd) O(1)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Depth First Traversal (DFS) visits each vertex and edge once in a graph. Its time complexity is Θ(|V| + |E|), where V is the number of vertices and E is the number of edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Time complexity of Depth First Traversal is …………, , Choices: ['A\\nΘ(|V| + |E|)', 'B\\nΘ(|V|)', 'C\\nΘ(|E|)', 'D\\nΘ(|V|·|E|)'], Answer: A\nΘ(|V| + |E|)"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: To calculate the sum of all leaf nodes in a binary tree, we must traverse each node at least once. Thus, the time complexity is O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The time complexity of calculating the sum of all leaf nodes in an n-node binary tree is __________, , Choices: ['A\\nO(n²)', 'B\\nO(n + 1)', 'C\\nO(1)', 'D\\nO(n)'], Answer: D\nO(n)"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: The optimal Build Heap operation uses a bottom-up approach, which has a linear time complexity of O(n) instead of O(n log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the best case complexity in building a heap?\na) O(n log n)\nb) O(n²)\nc) O(n log² n)\nd) O(n)\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The code reverses the first k elements of an array, which takes O(k) time since it performs k/2 swaps.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the time complexity of the following code?\n\n<code omitted>\n\na) O(k)\nb) O(n)\nc) O(k log k)\nd) O(n log n)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The postfix expression 2 3 + 4 5 6 – – * evaluates as: 2 + 3 = 5, 5 – 6 = –1, 4 – (–1) = 5, 5 * 5 = 25.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the value of the postfix expression 2 3 + 4 5 6 – – *?\na) 19\nb) 21\nc) –4\nd) 25\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Operations like Find Next and Find Previous are often supported in ordered data structures like balanced search trees or linked lists with additional pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Can operations like Find Next and Find Previous be implemented?\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Stacks are inherently used for operations such as expression evaluation, recursion, and reversing strings. Job scheduling typically involves queues or priority queues.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not an inherent application of stack?\na) Reversing a string\nb) Evaluation of postfix expression\nc) Implementation of recursion\nd) Job scheduling\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Recursion is implemented via a function call stack. Internally, this stack is often implemented using an array-based structure or a true stack data structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which data structure is used for implementing recursion?\na) Stack\nb) Queue\nc) List\nd) Array\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Most infix expression evaluation algorithms convert the input to postfix or prefix and evaluate in a single pass using a stack. Thus, one pass is sufficient.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many passes does the evaluation of infix expression algorithm make through the input?\na) One\nb) Two\nc) Three\nd) Four\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: The given recursive function prints a linked list in reverse order using post-order traversal logic.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What does the following function do for a given Linked List with first node as head?\n\nvoid fun1(struct node* head)\n{\n  if(head == NULL)\n    return;\n  \n  fun1(head->next);\n  printf(\"%d  \", head->data);\n}, Choices: ['A\\nPrints all nodes of linked list', 'B\\nPrints all nodes of linked list in reverse order', 'C\\nPrints alternate nodes of Linked List', 'D\\nPrints alternate nodes in reverse order'], Answer: B\nPrints all nodes of linked list in reverse order"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Double hashing generates more probe sequences than linear or quadratic probing due to the use of two hash functions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which technique has the greatest number of probe sequences?\na) Linear probing\nb) Quadratic probing\nc) Double hashing\nd) Closed hashing\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Dynamic arrays perform poorly when reallocation is costly and the array size is small. In such cases, the overhead of dynamic resizing isn't worth the benefit.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In which of the following cases are dynamic arrays not preferred?\na) If the size of the array is unknown\nb) If the size of the array changes after few iterations\nc) If the memory reallocation is expensive\nd) If the array holds fewer elements\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: In the given Java classes, the correct push method initializes a new node with the given item and sets it as the new top of the stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given the Node and Stack classes below, which push() implementation correctly adds an item to the stack?\n<code omitted>\n\nd) [Option A is correct]\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In memory allocation, freelists can be implemented implicitly via garbage collection or explicitly via calls to malloc/new.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are implicit and explicit implementations of freelists?\na) Garbage collection and new/malloc respectively\nb) New/malloc and garbage collection respectively\nc) Implicit implementation is not favored\nd) Explicit implementation is not favored\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The rope data structure allows for efficient insertion and deletion due to its tree-like structure, often outperforming arrays.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Is insertion and deletion operation faster in rope than in an array?\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: A triply linked list does not inherently prevent the insertion of duplicate nodes. Nodes with identical data can still be added.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A node will be rejected while inserting if the given node is already present in a triply linked list.\na) True\nb) False\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a B-tree of order n, each non-root node must contain at least ⌈n/2⌉ − 1 keys, which simplifies to at least (n−1)/2 keys for simplicity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A B-tree of order n is an order-n multiway tree in which each non-root node contains __________\na) at most (n − 1)/2 keys\nb) exactly (n − 1)/2 keys\nc) at least 2n keys\nd) at least (n − 1)/2 keys\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: The function shown likely computes Fibonacci numbers by simulating queue-based iteration. Thus, the correct behavior is to print Fibonacci numbers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following pseudo-code. Assume that IntQueue is an integer queue. What does the function fun do? , , Choices: ['A\\nPrints numbers from 0 to n−1', 'B\\nPrints numbers from n−1 to 0', 'C\\nPrints first n Fibonacci numbers', 'D\\nPrints first n Fibonacci numbers in reverse order.'], Answer: C\nPrints first n Fibonacci numbers"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Buddy memory allocation manages free memory blocks by dividing memory into powers of two and maintaining multiple free lists, each for a specific block size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is buddy memory management of free lists?\na) Modified version of first fit\nb) Buddy allocation keeps several free lists, each one holds blocks which are of one particular size\nc) Modified version of best fit\nd) A tree representation of free lists\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Accessing an index beyond the bounds of an array in Java throws an ArrayIndexOutOfBoundsException, as shown in the given code.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the output of the following Java code?\n\npublic class array {\n\tpublic static void main(String args[]) {\n\t\tint []arr = {1,2,3,4,5};\n\t\tSystem.out.println(arr[5]);\n\t}\n}\na) 4\nb) 5\nc) ArrayIndexOutOfBoundsException\nd) InvalidInputException\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Skew merging is an efficient variant of merge used in skew heaps. It has amortized logarithmic time complexity due to its adaptive merging.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the amortized efficiency of skew merge?\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(N²)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Binary trees can be traversed using strategies like depth-first (pre-order, in-order, post-order) or breadth-first (level order). The question asks about one of these.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the traversal strategy used in the binary tree?\na) Depth-first traversal\nb) Breadth-first traversal\nc) Random traversal\nd) Priority traversal\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Tracking a stack operation sequence helps identify the order of elements popped. The correct answer must reflect the final stack state after each operation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If the sequence of operations - push(1), push(2), pop, push(1), push(2), pop, pop, pop, push(2), pop - is performed on a stack, the sequence of popped out values is:\n, Choices: ['A\\n2,2,1,1,2', 'B\\n2,2,1,2,2', 'C\\n2,1,2,2,1', 'D\\n2,1,2,2,2'], Answer: A\n2,2,1,1,2"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Stack operations such as reversing strings, evaluating expressions, and simulating recursion are inherent. Job scheduling typically uses queues or heaps.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which data structure can be used to test a palindrome?\na) Tree\nb) Heap\nc) Stack\nd) Priority queue\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Prefix expressions are evaluated from right to left, while postfix expressions are evaluated from left to right.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given a prefix and a postfix notation, what is the difference between them?\na) The postfix equation is solved starting from the left whereas the prefix notation is solved from the right\nb) The postfix equation is solved starting from the right whereas the prefix notation is solved from the left\nc) Both equations are solved starting from the same side (right)\nd) Both equations are solved starting from the same side (left)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The transformation w′(u, v) = w(u, v) + f(u) − f(v) preserves shortest paths if and only if f(u) is the shortest distance from a source node in a graph with zero-weight edges from the source.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Let G=(V,E) be a directed, weighted graph with weight function w:E→R. For some function f:V→R, for each edge (u,v)∈E, define w′(u,v) = w(u,v)+f(u)−f(v). Which one of the options completes the following sentence so that it is TRUE? “The shortest paths in G under w are shortest paths under w′ too, _________”, , Choices: ['A\\nfor every f:V→R', 'B\\nif and only if ∀u∈V, f(u) is positive', 'C\\nif and only if ∀u∈V, f(u) is negative', 'D\\nif and only if f(u) is the distance from s to u in the graph obtained by adding a new vertex s to G and edges of zero weight from s to every vertex of G'], Answer: A\nfor every f:V→R"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Breadth-First Search (BFS) uses a queue to explore all neighboring nodes before moving to the next level. Thus, a queue is required for BFS.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The data structure required for Breadth First Traversal on a graph is ………, , Choices: ['A\\nQueue', 'B\\nStack', 'C\\nArray', 'D\\nTree'], Answer: A\nQueue"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The correct implementation of an insert_key function for a priority list ensures proper placement based on the key while maintaining order. The logic must track both previous and current nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Select the appropriate code that inserts elements into the list based on the given key value.\n(head and trail are dummy nodes to mark the end and beginning of the list; they do not contain any priority or element)\na) [Option A is correct code shown in prompt]\nb) [Other versions incorrectly track or link nodes]\nc) [Includes faulty pointer logic]\nd) [Breaks list structure],\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Hash tables rely on a hash function to compute the index where an input record should be stored in the underlying array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is used in hash tables to determine the index of any input record?\na) Hash function\nb) Hash linked list\nc) Hash tree\nd) Hash chaining\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: In a Directed Acyclic Graph (DAC), source vertices have no incoming edges, and sink vertices have no outgoing edges. From the given graph stack states, we identify the entry/exit points.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "If a Graph Structured Stack contains {1,2,3,4}, {1,5,3,4}, {1,6,7,4}, and {8,9,7,4}, what would be the source and sink vertices of the DAC?\na) Source – 1, 8 Sink – 7, 4\nb) Source – 1 Sink – 8, 4\nc) Source – 1, 8 Sink – 4\nd) Source – 4, Sink – 1, 8\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: An inversion is a pair (i, j) such that i < j and arr[i] > arr[j]. It's used to count disorder in an array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the condition for two elements arr[i] and arr[j] to form an inversion?\na) arr[i] < arr[j]\nb) i < j\nc) arr[i] < arr[j] and i < j\nd) arr[i] > arr[j] and i < j\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Linked lists offer better memory management and efficient insertion/deletion over arrays, saving both space and time under many circumstances.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Linked list data structure offers considerable saving in _____________\na) Computational Time\nb) Space Utilization\nc) Space Utilization and Computational Time\nd) Speed Utilization\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: XOR-linked lists use XOR operations instead of traditional pointers, offering a memory-efficient way to store links with a single field.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is an application of XOR-linked lists?, , Choices: ['A\\nImplementing stacks', 'B\\nImplementing queues', 'C\\nMemory-efficient linked list representation', 'D\\nCaching data structures'], Answer: C\nMemory-efficient linked list representation"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Top Trees are used for maintaining dynamic trees and support operations like link, cut, and expose, which help in manipulating subtrees efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the dynamic operations are used in Top Tree data structure implementation?\na) Link\nb) Cut\nc) Expose\nd) All of the mentioned\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: The missing line in the reverse() function for a singly linked list should set the head pointer to the last processed node (prev), completing the reversal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The following function reverse() is supposed to reverse a singly linked list. There is one line missing at the end of the function. What should replace the missing statement?\n, Choices: ['A\\nSet the value of head_ref to prev;', 'B\\nSet the value of head_ref to current;', 'C\\nSet the value of head_ref to next;', 'D\\nSet the value of head_ref to NULL;'], Answer: A\nSet the value of head_ref to prev;"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The array-based representation of binary trees supports random access, whereas linked representations lack this feature and require extra space for pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Disadvantages of linked list representation of binary trees over arrays?\na) Randomly accessing is not possible\nb) Extra memory for a pointer is needed with every element in the list\nc) Difficulty in deletion\nd) Random access is not possible and extra memory with every element\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Recursion is implemented using the call stack. Hence, stack is the underlying data structure used for implementing recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which data structure is used for implementing recursion?, , Choices: ['A\\nQueue', 'B\\nStack', 'C\\nArrays', 'D\\nList'], Answer: B\nStack"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Linked lists allocate memory dynamically at runtime, making them an example of dynamic memory allocation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Linked list is considered as an example of ___________ type of memory allocation.\na) Dynamic\nb) Static\nc) Compile time\nd) Heap\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A dequeue (double-ended queue) has many applications including job scheduling, flexible data access (like stacks and queues), and efficient sliding window computations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What are the applications of dequeue?\na) A-Steal job scheduling algorithm\nb) Can be used as both stack and queue\nc) To find the maximum of all subarrays of size k\nd) All of the mentioned\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Sparse matrices store only non-zero values, which reduces storage and improves speed. However, algorithms for sparse matrices are often more complex.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the disadvantage of sparse matrices over normal matrices?\na) Size\nb) Speed\nc) Easily compressible\nd) Algorithm complexity\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Multiplicative hashing computes h(k) = ⌊p × (k × s mod 2^w) / 2^w⌋. For the key 123456 and given parameters, h(k) = 67.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the value of h(k) for the key 123456?\nGiven: p = 14, s = 2654435769, w = 32\na) 123\nb) 456\nc) 70\nd) 67\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: MinHash is a technique used in hashing-based approaches to estimate similarity between sets (like Jaccard similarity).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which technique is used for finding similarity between two sets?\na) MinHash\nb) Stack\nc) Priority Queue\nd) PAT Tree\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Abstract Syntax Trees (ASTs) are widely used in compilers and static analyzers to represent the syntactic structure of code.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is an application of abstract syntax tree?\na) Static code analyzing\nb) Implement indexing in databases\nc) Used for dynamic memory allocation\nd) To represent networks of communication\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In red-black trees, each node is colored either red or black, and the root node is always black to maintain balance properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the special property of red-black trees and what should the root always be?\na) A color which is either red or black and root should always be black\nb) Height of the tree\nc) Pointer to next node\nd) A color which is either green or black\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: Binary Decision Diagrams (BDDs) are used to represent Boolean functions efficiently in computational logic and verification tasks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In which of the following cases is a Binary Decision Diagram used?\na) Representation of Boolean Functions\nb) String Matching\nc) Searching\nd) Sorting of numbers\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The algorithm to balance symbols in code typically includes checks for parentheses (), brackets [], and braces {}, using a stack to ensure proper nesting.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following does the balancing symbols algorithm include?\na) Balancing double quotes\nb) Balancing single quotes\nc) Balancing operators and brackets\nd) Balancing parentheses, brackets and braces\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Breadth-First Search (BFS) visits nodes level by level, similar to level order traversal in a binary tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following graph traversals closely imitates level order traversal of a binary tree?\na) Depth First Search\nb) Breadth First Search\nc) Depth & Breadth First Search\nd) Binary Search\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: In a max-heap, new elements are inserted and then bubbled up to maintain heap order. After inserting 1 and 7 into the heap [10, 8, 5, 3, 2], the result is [10, 8, 7, 3, 2, 1, 5].\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A Priority-Queue is implemented as a Max-Heap. Initially, it has 5 elements. The level-order traversal of the heap is: 10, 8, 5, 3, 2. Two new elements '1' and '7' are inserted in that order. What is the level-order traversal of the heap after insertion?, , Choices: ['A\\n10, 8, 7, 5, 3, 2, 1', 'B\\n10, 8, 7, 2, 3, 1, 5', 'C\\n10, 8, 7, 1, 2, 3, 5', 'D\\n10, 8, 7, 3, 2, 1, 5'], Answer: D\n10, 8, 7, 3, 2, 1, 5"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: A Directed Acyclic Graph (DAG) with V vertices can have at most V(V-1)/2 edges while still maintaining its acyclic property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "With V (greater than 1) vertices, how many edges at most can a Directed Acyclic Graph possess?\na) (V*(V-1))/2\nb) (V*(V+1))/2\nc) (V+1)C2\nd) (V-1)C2\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a Binary Search Tree (BST), in-order traversal visits nodes in ascending order and hence yields sorted output.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following traversal outputs the data in sorted order in a BST?, , Choices: ['A\\nPreorder', 'B\\nInorder', 'C\\nPostorder', 'D\\nLevel order'], Answer: B\nInorder"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Run-Length Encoding (RLE) is a form of lossless data compression used to encode sequences of repeated values in bit arrays.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Run-Length encoding is used to compress data in bit arrays.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: To implement a queue using stacks, the minimum number required is two—one for enqueue and another for dequeue operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The minimum number of stacks needed to implement a queue is:, , Choices: ['A\\n3', 'B\\n1', 'C\\n2', 'D\\n4'], Answer: C\n2"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The C++ Standard Library provides the rotate() function in the <algorithm> header to rotate the elements within a container.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Predefined function rotate() in C++ is available under which header file?\na) math\nb) stdio\nc) stdlib\nd) algorithm\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In a singly linked list, deleting the last element requires traversal from the head to find the node before the last one, leading to time complexity dependent on list length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider a single linked list where F and L are pointers to the first and last elements respectively of the linked list. The time for performing which of the given operations depends on the length of the linked list?, , Choices: ['A\\nDelete the first element of the list', 'B\\nInterchange the first two elements of the list', 'C\\nDelete the last element of the list', 'D\\nAdd an element at the end of the list'], Answer: C\nDelete the last element of the list"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Converting infix expressions like (A+B)*(C−D)/E*F into prefix notation requires proper operator ordering. The correct prefix form is * / * + A B - C D E F.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The prefix of (A+B)*(C−D)/E*F is:, , Choices: ['A\\n/+-AB*CD', 'B\\n/*+-ABCD*EF', 'C\\n*/*+AB-CDEF', 'D\\n**AB+CD/EF'], Answer: C\n*/*+AB-CDEF"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: An array is a collection of elements stored in contiguous memory locations, all of the same data type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of these best describes an array?\na) A data structure that shows a hierarchical behavior\nb) Container of objects of similar types\nc) Arrays are immutable once initialized\nd) Array is not a data structure\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: B-trees are widely used in databases and file systems for external memory storage due to their balanced structure and efficient disk I/O.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the most widely used external memory data structure?\na) AVL tree\nb) B-tree\nc) Red-black tree\nd) Both AVL tree and Red-black tree\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In database systems, B+ trees are preferred because they support range queries efficiently and store data in leaves in sorted order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which one of the following data structures is preferred in database-system implementation?\na) AVL tree\nb) B-tree\nc) B+ tree\nd) Splay tree\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In the Union-Find (Disjoint Set) data structure, path compression leads to ranks increasing from the leaves up toward the root.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In the Union/Find algorithm, the ranks of the nodes on a path will increase monotonically from?\na) Leaf to root\nb) Root to node\nc) Root to leaf\nd) Left subtree to right subtree\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In a max-heap or min-heap, the root is the largest or smallest element. Subtree roots can still be larger/smaller than the overall root, so the statement is false.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The roots of the elements of the subtrees are smaller than the root of the heap.\na) True\nb) False\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The given function performs a reverse operation on the input array between two indices using a standard two-pointer swap method.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the below program. What is the expected output? , void fun(int arr[], int start, int end)\n{\n    while (start < end) {\n        int temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}, Choices: ['A\\nSwapping the elements pairwise', 'B\\nSorting the elements', 'C\\nReverse an array', 'D\\nNone'], Answer: C\nReverse an array"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Converting a postfix expression to infix is generally easier to implement compared to prefix because postfix evaluation uses a straightforward stack approach.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given two processes (conversion of postfix to infix and prefix to infix), which of the following is easier to implement?\na) Both are easy to implement\nb) Postfix to infix is harder than prefix to infix\nc) Postfix to infix is easier than prefix to infix\nd) Insufficient data\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: An unrolled linked list stores elements in blocks, and the space complexity is O(n) since each element must be stored explicitly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following represents the space complexity for an unrolled linked list?\na) O(1)\nb) O(n)\nc) O(n²)\nd) O(n³)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Performing a specific sequence of stack operations (push, pop, top) affects the content of the stack. The last value popped can be determined through trace.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider these functions:\npush() : push an element into the stack\npop() : pop the top-of-the-stack element\ntop() : returns the item stored in top-of-the-stack-node\nWhat will be the output after performing these sequence of operations?\na) 20\nb) 4\nc) Stack underflow\nd) 5\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The number of different randomized binary search trees that can be formed from a given permutation of (1,3,2) is determined by unique insertion orders.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many randomized binary search trees can be formed by the numbers (1, 3, 2)?\na) 2\nb) 3\nc) 6\nd) 5\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In low-level languages, pointer manipulation often requires more CPU cycles and memory access than arithmetic operations like multiplication/division.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Pointer manipulation is generally more time-consuming than multiplication and division.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Splay trees are self-adjusting binary search trees that perform access operations and restructuring in logarithmic amortized time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the self-adjusting binary search tree?\na) AVL Tree\nb) Splay Tree\nc) Top Tree\nd) Ternary Tree\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: A sparse matrix is a matrix in which most elements are zero, making it efficient for space but algorithmically complex in some cases.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which matrix has most of the elements (not all) as zero?\na) Identity Matrix\nb) Unit Matrix\nc) Sparse Matrix\nd) Zero Matrix\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a full binary tree, the total number of nodes N is always 2*L – 1, where L is the number of leaf nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a full binary tree, if there are L leaves, then the total number of nodes N is?, , Choices: ['A\\nN = 2*L', 'B\\nN = L + 1', 'C\\nN = L – 1', 'D\\nN = 2*L – 1'], Answer: D\nN = 2*L – 1"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: According to the cut property in graph theory, the minimum weight edge crossing a cut must be included in the Minimum Spanning Tree (MST).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Let s and t be two vertices in an undirected graph G = (V, E) with positive edge weights. Let [X, Y] be a partition of V such that s ∈ X and t ∈ Y. Consider the edge e having the minimum weight among all edges with one vertex in X and the other in Y. The edge e must definitely belong to:, , Choices: ['A\\nThe minimum weighted spanning tree of G', 'B\\nThe weighted shortest path from s to t', 'C\\nEach path from s to t', 'D\\nThe weighted longest path from s to t'], Answer: A\nThe minimum weighted spanning tree of G"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A min-heap is a complete binary tree where each node's value is less than or equal to its children's values. It satisfies the heap property and is always complete.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A min-Heap is a complete binary tree., , Choices: ['A\\nTrue', 'B\\nFalse'], Answer: A\nTrue"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: A palindrome is a string that reads the same backward as forward. For example, \"ABCCBA\" is a palindrome.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is a palindromic string?, , Choices: ['A\\n\"APPLE\"', 'B\\n\"ABCDE\"', 'C\\n\"APPLA\"', 'D\\n\"ABCCBA\"'], Answer: D\n\"ABCCBA\""
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In Jaccard similarity approximation using MinHashing, the number of hash functions required for an error rate ε is approximately 1/ε². For ε ≤ 0.05, around 400 hashes are needed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many hashes will be needed for calculating Jaccard index with an expected error less than or equal to 0.05?\na) 100\nb) 200\nc) 300\nd) 400\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Null nodes in trees, such as in Treaps or certain binary trees, are often treated as having infinite priority to ensure proper rotations and balancing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the priority of a null node?\na) 1\nb) 0\nc) Random number\nd) Infinity\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A bit array is a compact data structure used for storing individual bits efficiently, often used in Bloom filters and bitmap indexing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is a bit array?\na) Data structure that compactly stores bits\nb) Data structure for representing arrays of records\nc) Array in which elements are not present in continuous locations\nd) An array in which most of the elements have the same value\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A heap is a complete binary tree where each parent node is greater (max-heap) or smaller (min-heap) than its children, depending on the heap type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A complete binary tree with the property that the value at each node is at least as large as the values at its children is known as:, , Choices: ['A\\nBinary search tree', 'B\\nAVL tree', 'C\\nCompletely balanced tree', 'D\\nHeap'], Answer: D\nHeap"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: XOR-linked lists reduce space by storing the XOR of previous and next pointers in a single field, thus halving the space needed for links.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is an advantage of XOR list?\na) Most debugging tools cannot follow the XOR chain, making debugging difficult\nb) You need to remember the address of the previously accessed node in order to calculate the next node’s address\nc) In some contexts XOR of pointers is not defined\nd) XOR list decreases the space requirement in doubly linked list\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: In a graph with a Eulerian walk, the number of vertices with odd degrees must be either 0 (Eulerian circuit) or 2 (Eulerian path).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Number of vertices with odd degrees in a graph having a Eulerian walk is ________\na) 0\nb) Can’t be predicted\nc) 2\nd) Either 0 or 2\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The minimum number of jumps problem finds the minimum steps to reach the end of an array, given that each element represents the maximum jump length from that position.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the minimum number of jumps required to reach the end of the array arr[] = {1,3,6,3,6,8,5}?\na) 1\nb) 2\nc) 3\nd) Not possible to reach the end\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Stack operations like push and pop modify the content and size of the stack. Tracing each operation can determine the final count of elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following operation performed on a stack of size 5.\n\nPush(1);\nPop();\nPush(2);\nPush(3);\nPop();\nPush(4);\nPop();\nPop();\nPush(5);\n\nAfter the completion of all operations, the number of elements present in the stack is?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: A hash function is a key component in hashing, which maps keys to addresses for storage or retrieval in hash tables.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following helps keys to be mapped into addresses?\na) Hash function\nb) Separate chaining\nc) Open addressing\nd) Chaining using a linked list\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Prefix notation (Polish notation) places operators before operands. The prefix form of A - B / (C * D ^ E) is -A/B*C^DE.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The prefix form of A - B / (C * D ^ E) is?\na) -A/B*C^DE\nb) -A/BC*^DE\nc) -ABCD*^DE\nd) -/*^ACBDE\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: An Abstract Data Type (ADT) is a model for a data structure that specifies the behavior from the point of view of a user, particularly its storage structure in memory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Representation of data structure in memory is known as:, , Choices: ['A\\nRecursive', 'B\\nAbstract data type', 'C\\nStorage structure', 'D\\nFile structure'], Answer: B\nAbstract data type"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In direct addressing, dynamic sets reduce the amount of memory needed by allocating only required keys instead of a large array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the advantage of using a dynamic set in direct addressing?\na) It saves time\nb) It saves space\nc) It saves both time and space\nd) It reduces code complexity\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: 2-3 trees are balanced search trees that provide efficient searching by maintaining sorted keys and having 2 or 3 children per node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following data structures can provide efficient searching of the elements?\na) Unordered lists\nb) Binary search tree\nc) Treap\nd) 2-3 tree\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Medium\nContext: Self-organizing lists improve the performance of linear search by reordering elements to reflect frequency of access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The self-organizing list improves the efficiency of _______?\na) Binary search\nb) Jump search\nc) Sublist search\nd) Linear search\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The problem describes a variation of stack operations with constraints. Moving elements between two containers and returning them simulates stack behavior.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "You have two jars, one with 10 rings and another with none, stacked vertically. You want to remove the last ring from the first jar, but the second jar is weak and cannot store rings for long.\na) Empty the first jar one by one into the second jar\nb) Move rings to the second jar, then move them back one by one to the first\nc) There exists no possible way to do this\nd) Break the jar and remove the last one\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A suffix array is a sorted array of all suffixes of a string. It is commonly used in string matching problems and must be sorted for efficient access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is false?\na) Suffix array is always sorted\nb) Suffix array is used in string matching problems\nc) Suffix array is always unsorted\nd) Suffix array contains all the suffixes of the given string\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In postfix expressions, operators follow their operands. The postfix form of an infix expression depends on operator precedence and associativity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the postfix expression for the corresponding infix expression?\n\na) abc*+de*+\nb) abc+*de*+\nc) a+bc*de+*\nd) abc*+(de)*+\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: In graph theory, every path is also a trail, and every trail is a path when all edges and vertices are distinct.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following statements for a simple graph is correct?\na) Every path is a trail\nb) Every trail is a path\nc) Every trail is a path as well as every path is a trail\nd) Path and trail have no relation\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A heap is a binary tree-based structure where parent nodes follow a specific order relative to their children. A valid max-heap has each parent greater than its children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following sequences of array elements forms a heap?, , Choices: ['A\\n{23, 17, 14, 6, 13, 10, 1, 12, 7, 5}', 'B\\n{23, 17, 14, 6, 13, 10, 1, 5, 7, 12}', 'C\\n{23, 17, 14, 7, 13, 10, 1, 5, 6, 12}', 'D\\n{23, 17, 14, 7, 13, 10, 1, 12, 5, 7}'], Answer: C\n{23, 17, 14, 7, 13, 10, 1, 5, 6, 12}"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The move-to-front method performs poorly for sequential access patterns because it constantly moves elements to the front, disrupting the natural access order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following method performs poorly when elements are accessed in sequential order?\na) Count method\nb) Move to front method\nc) Transpose method\nd) Ordering method\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: The C++ program iterates through the string \"Hello Geeks\" to count characters until the null terminator, returning the total character length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will the below program print?\n\n// C++ program to find the length of string\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    string str = \"Hello Geeks\";\n    int i;\n    for (i = 0; str[i] != '\\0'; ++i);\n    cout << i;\n    return 0;\n}, Choices: ['A\\n0', 'B\\n1', 'C\\n5', 'D\\n11'], Answer: D\n11"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Given custom operator precedence and associativity, arithmetic expressions can be evaluated differently than usual conventions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Assume +, -, * are usual arithmetic operators. * has the lowest precedence, + has the highest precedence, and – has medium. + and * are left-associative whereas – is right-associative. What is the value of the expression 3 – 8 + 2 – 9 * 3?\na) 4\nb) 6\nc) 8\nd) 10\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The provided Java method uses a stack to identify and print matching parentheses by tracking their indices.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following program prints the index of every matching parenthesis?\na) [First program with index output incremented]\nb) [Second program]\nc) [Third with reverse condition]\nd) [Fourth program with unmatched pairing]\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A 2-3 tree is a balanced search tree where all leaves are at the same level. However, postorder traversal does not yield sorted elements—only inorder does.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is not true about the 2-3 tree?\na) All leaves are at the same level\nb) It is perfectly balanced\nc) Postorder traversal yields elements in sorted order\nd) It is a B-tree of order 3\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: XOR linked lists are memory-efficient doubly linked lists used in constrained environments, but come with certain trade-offs for usability.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following statements are true?\ni) XOR lists are used in environments with limited space, like embedded devices\nii) Garbage collectors may not support XOR lists\niii) Calculating next requires remembering previous node\niv) XOR lists are always more efficient than all alternatives\na) i, ii, iii, iv\nb) i, ii, iii\nc) i, ii\nd) i\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In Java, ArrayLists are dynamic arrays. The correct syntax uses the generic type and constructor to instantiate the list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is the correct syntax to declare an ArrayList in Java?\na) ArrayList al = new ArrayList();\nb) ArrayList al = new ArrayList[];\nc) ArrayList al() = new ArrayList();\nd) ArrayList al[] = new ArrayList[];\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In a queue implemented using a linked list, both front and rear pointers are used to track the beginning and end. Inserting into an empty queue requires updating both pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In linked list implementation of a queue, front and rear pointers are tracked. Which of these pointers will change during an insertion into EMPTY queue?\na) Only front pointer\nb) Only rear pointer\nc) Both front and rear pointer\nd) No pointer will be changed\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: The word reversal algorithm using stacks requires one stack to hold the input and one to reverse the output.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many stacks are required for reversing a word algorithm?\na) one\nb) two\nc) three\nd) four\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In tree-based data structures, leaf and internal nodes may hold pointers. The rightmost child in certain trees may retain a parent pointer.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which node contains a pointer to its parent?\na) root node\nb) right most child\nc) left most child\nd) left sibling\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In circular linked lists, nodes loop back to the head. The given program checks if a list loops back to its head node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the below program, and identify which operation is performed., int solve(struct Node* head)\n{\n    if (head == NULL)\n        return 1;\n    struct Node* ptr;\n    ptr = head->next;\n    while (ptr != NULL && ptr != head)\n        ptr = ptr->next;\n    return (ptr == head);\n}, Choices: ['A\\nChecking for List is empty or not', 'B\\nChecking for the list is Circular or not', 'C\\nCount the number of elements in the list', 'D\\nNone'], Answer: B\nChecking for the list is Circular or not"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: The adjacency matrix of a graph is symmetric only for undirected graphs. For directed graphs, it is not symmetric.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Adjacency matrix of all graphs are symmetric.\na) False\nb) True\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Tango trees are binary search trees that adaptively restructure to access patterns, maintaining search tree properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which type of tree is tango tree?\na) Ternary Tree\nb) AVL Tree\nc) Binary Search Tree\nd) K-ary Tree\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In array-based queue implementations, the queue becomes full when the rear index reaches the array’s maximum size minus one.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A normal queue, if implemented using an array of size MAX_SIZE, gets full when?\na) Rear = MAX_SIZE – 1\nb) Front = (rear + 1) mod MAX_SIZE\nc) Front = rear + 1\nd) Rear = front\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: Lexicographical order of strings stored in a trie is achieved by performing an inorder traversal over the trie.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What traversal over trie gives the lexicographical sorting of the set of the strings?\na) postorder\nb) preorder\nc) inorder\nd) level order\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Union-find with union by height optimizes disjoint-set structures. The depth of any tree in this scheme is logarithmic in size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the depth of any tree if the union operation is performed by height?\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(M log N)\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The size of the array is computed using the expression `a - b/c + d` after input substitution. The C++ program evaluates this as `10 - 20/30 + 40 = 10 - 0 + 40 = 50`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the following piece of code in C++, how many elements will be stored in the array ‘arr’ if the user enters the values of a, b, c, and d as 10, 20, 30, and 40 respectively?\n\n#include<iostream>\nusing namespace std;\nint main() \n{\n    int a, b, c, d;\n    cout<<\"Enter the value of a, b, c, d: \";\n    cin>>a>>b>>c>>d;\n    int arr[a - b/c + d];\n}\n\na) 30\nb) 40\nc) 50\nd) 60\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In Top trees, various operations such as link, cut, expose, and merge are used. Among these, 'merge' is commonly used as an internal operation to combine parts of the tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following are used as an internal operation in Top tree?\na) Merge\nb) Cut\nc) Expose\nd) Link\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: The function in the provided C++ code performs a breadth-first traversal of a binary tree, visiting nodes level by level using a queue.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider the below program, and identify what the function is doing.,\n#include <iostream>\n#include <queue>\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int item) {\n        data = item;\n        left = right = nullptr;\n    }\n};\nvoid function(Node* root) {\n    if (root == nullptr)\n        return;\n    std::queue<Node*> q;\n    q.push(root);\n    while (!q.empty()) {\n        Node* node = q.front();\n        q.pop();\n        std::cout << node->data << \" \";\n        if (node->left != nullptr)\n            q.push(node->left);\n        if (node->right != nullptr)\n            q.push(node->right);\n    }\n}, Choices: ['A\\nIn order traversal of a tree', 'B\\nNormal traversal of a tree', 'C\\nLevel order traversal of  a tree', 'D\\nNone'], Answer: C\nLevel order traversal of  a tree"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A leftist heap is structured so that the shortest path to a leaf is always on the right, making it biased or deeper on the left.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Why is this heap named leftist heap?\na) only left subtrees exist\nb) the tree is biased to get deep down the left\nc) it is balanced\nd) right trees are unbalanced\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Tree traversals include preorder, inorder, and postorder. Randomized traversal is not a standard algorithm used in trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following traversing algorithm is not used to traverse in a tree?\na) Post order\nb) Pre order\nc) Post order\nd) Randomized\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: The heap can be constructed in linear time, O(n), using bottom-up heapify techniques.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The running time for creating a heap of size n is?\na) O(n)\nb) O(log n)\nc) O(n log n)\nd) O(n^2)\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: XOR linked lists reduce memory usage by storing the XOR of previous and next pointers in each node, acting as a space-efficient doubly linked list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is xor linked list?\na) uses of bitwise XOR operation to decrease storage requirements for doubly linked lists\nb) uses of bitwise XOR operation to decrease storage requirements for linked lists\nc) uses of bitwise operations to decrease storage requirements for doubly linked lists\nd) just another form of linked list\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: The number of connected components in a graph can be determined by analyzing its adjacency matrix and using traversal algorithms such as DFS.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given the following adjacency matrix of a graph(G), determine the number of components in the G.\na) 1\nb) 2\nc) 3\nd) 4\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a postorder traversal, nodes are visited in the order left-right-root. Reconstructing a pre-order traversal involves reverse engineering the tree structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The post-order traversal of a binary tree is O P Q R S T. Then possible pre-order traversal will be ________\na) T Q R S O P\nb) T O Q R P S\nc) T Q O P S R\nd) T Q O S P R\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Farach provided the first suffix tree construction for all alphabets in linear time, significantly improving previous algorithms like Weiner's and Ukkonen's.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Who among the following provided the first suffix tree contribution for all alphabet?\na) Weiner\nb) Farach\nc) Ukkonen\nd) Alexander Morse\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: To determine whether an expression contains balanced parentheses, a stack is commonly used because of its LIFO structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The data structure required to check whether an expression contains balanced parenthesis is __________\na) Stack\nb) Queue\nc) Tree\nd) Array\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A binary tree is considered weight-balanced if the number of internal nodes in each subtree differs by at most one, and height-balanced if the depth difference between any two leaves is at most one.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What do the following definitions convey?\ni. A binary tree is balanced if for every node it holds that the number of inner nodes in the left and right subtree differ by at most 1.\nii. A binary tree is balanced if for any two leaves the difference of the depth is at most 1.\na) weight balanced and height balanced tree definitions\nb) height balanced and weight balanced tree definitions\nc) definitions of weight balanced tree\nd) definitions of height balanced tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: The given function prints the linked list nodes in reverse order by using recursion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What does the following function do for a given Linked List with first node as head?\n\nvoid fun1(struct node* head)\n{\n    if(head == NULL)\n        return;\n    fun1(head->next);\n    printf(\"%d  \", head->data);\n}\n\na) Prints all nodes of linked lists\nb) Prints all nodes of linked list in reverse order\nc) Prints alternate nodes of Linked List\nd) Prints alternate nodes in reverse order\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A suffix array lists the starting positions of suffixes of a string sorted in lexicographical order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What will be the suffix array of the string “engineering”?\na) 2 3 8 4 9 1 7 5 0 6 10\nb) 5 0 6 1 4 9 1 7 0 2 3 8\nc) 5 0 6 10 2 4 9 1 7 3 8\nd) 5 0 6 10 2 3 8 4 9 1 7\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Separate chaining is a collision resolution technique in hash tables that uses linked lists to store multiple values that hash to the same index.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is identical to that of a separate chaining hash node?\na) Linked list\nb) Array\nc) Stack\nd) Queue\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Inserting an element after a given pointer in a linked list takes constant time as it only involves pointer manipulation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "In a linked list with n nodes, the time taken to insert an element after an element pointed by some pointer is ________\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n log n)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: For a sorted array, binary search can be used to find if an element appears more than n/2 times in Θ(log n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The minimum number of comparisons required to determine if an integer appears more than n/2 times in a sorted array of n integers is ________\na) Θ(n)\nb) Θ(log n)\nc) Θ(n log n)\nd) Θ(1)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Quadratic probing resolves collisions by computing a new hash location using a quadratic function of the number of attempts.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "For the given hash table, in what location will the element 58 be hashed using quadratic probing?\na) 1\nb) 2\nc) 7\nd) 6\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Separate chaining and open addressing are common collision resolution strategies in hashing. Separate chaining is generally simpler to implement.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Separate chaining is easier to implement as compared to open addressing.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: AND-Inverter Graphs (AIGs) are a compact and efficient representation of Boolean functions and are often more efficient than Binary Decision Diagrams (BDDs).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The And Inverter Graph representation of a Boolean function is more efficient than the Binary Decision Diagram.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: AA Trees are a type of balanced binary search tree. They use a concept called 'levels' instead of colors (as in Red-Black trees) to maintain balance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "AA Trees are implemented using?\na) Colors\nb) Levels\nc) Node size\nd) Heaps\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a ternary tree, child nodes can be internal nodes or leaf nodes. Not all child nodes are necessarily leaf nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Can a child node always be called a leaf node in a ternary tree?\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: A binary string consists only of characters '0' and '1'. Any other characters make it non-binary.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following statement is a binary string?\na) \"ab\"\nb) \"121212\"\nc) \"01010101110\"\nd) None\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Suffix Tree Clustering (STC) is a data clustering algorithm used in search engines to group similar results by matching phrases via suffix trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following data clustering algorithms uses suffix trees in search engines?\na) Weiner’s algorithm\nb) Farach’s algorithm\nc) Lempel–Ziv–Welch’s algorithm\nd) Suffix Tree Clustering\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A ternary tree is a tree data structure in which each node can have up to three children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many child nodes does each node of a ternary tree contain?\na) 4\nb) 6\nc) 5\nd) 3\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A fundamental property of trees in graph theory is that a tree with n vertices has exactly n-1 edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "All trees with n vertices consist of how many edges?\na) n\nb) n-2\nc) n+1\nd) n-1\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: For a connected planar graph, Euler’s formula states V - E + F = 2, where V is vertices, E is edges, and F is regions (faces).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A connected planar graph having 6 vertices and 7 edges contains how many regions?\na) 15\nb) 3\nc) 1\nd) 11\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In expression conversion, prefix (Polish) notation requires placing the operator before its operands. Parentheses are eliminated by using the order of operators.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The prefix form of A-B/ (C * D ^ E) is:\nOptions:\n- A\n-/*^ACBDE\n- B\n-ABCD*^DE\n- C\n-A/B*C^DE\n- D\n-A/BC*^DE\n\nAnswer: C\n-A/B*C^DE"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The balancing symbols algorithm is used in compilers and interpreters to ensure proper nesting of brackets, parentheses, and braces. It operates in a single linear pass.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many passes does the balancing symbols algorithm make through the input?\na) one\nb) two\nc) three\nd) four\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Load factor in hashing is defined as the number of elements divided by the number of slots in the table. A higher load factor indicates more collisions and reduced performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given a hash table T with 25 slots that stores 2000 elements, the load factor α for T is __________\nOptions:\n- A\n80\n- B\n0.0125\n- C\n8000\n- D\n1.25\n\nAnswer: A\n80"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: When a collision occurs in a hash table, alternative indices must be generated to place the colliding key. This process is known as collision resolution or handling.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The task of generating alternative indices for a node is called?\na) Collision handling\nb) Collision detection\nc) Collision recovery\nd) Closed hashing\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Sparse matrices are matrices with a large number of zero elements. Efficient representations like Dictionary of Keys and Linked Lists are used to store only non-zero entries.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not the method to represent Sparse Matrix?\na) Dictionary of Keys\nb) Linked List\nc) Array\nd) Heap\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Balanced parentheses in expressions can be checked using stacks, where each opening bracket is pushed and matched with a corresponding closing one popped from the stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What data structure can be used to check if syntax has balanced parenthesis?\nOptions:\n- A\nQueue\n- B\nTree\n- C\nList\n- D\nStack\n\nAnswer: D\nStack"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a B+ tree, the order of a leaf node determines how many key-value pairs it can store. Given storage constraints like block size, pointer size, and field size, the order can be calculated to optimize disk access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The order of a leaf node in a B+ tree is the maximum number of children it can have. Suppose that block size is 1 kilobytes, the child pointer takes 7 bytes long and search field value takes 14 bytes long. The order of the leaf node is ________.\nOptions: ['A\\n16', 'B\\n63', 'C\\n64', 'D\\n68']\nAnswer: A\n16"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: The substr function in C++ returns a substring starting from a specified index and for a specified length. Chaining substr calls affects what part of the string is ultimately returned.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the output of the below code?\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    string str = \"GeeksForGeeks\";\n    cout << str.substr(2).substr(4);\n    return 0;\n}\nOptions: ['A\\neksForGeeks', 'B\\nForGEeks', 'C\\nGeeks', 'D\\norGeeks']\nAnswer: D\norGeeks"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In a doubly linked list, each node points to both its previous and next node. Deleting a node is done in constant time O(1), provided a pointer to the node is already known.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The time required to delete a node x from a doubly linked list having n nodes is……\nOptions: ['A\\nO(n)', 'B\\nO(log n)', 'C\\nO(1)', 'D\\nO(n log n)']\nAnswer: C\nO(1)"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: In a path graph, only the internal nodes have degree 2. The two end nodes have degree 1, so a path with n > 2 vertices has (n - 2) nodes of degree 2.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the number of vertices of degree 2 in a path graph having n vertices, here n > 2?\na) n-2\nb) n\nc) 2\nd) 0\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Insertion at the beginning of a doubly linked list involves updating both previous and next pointers to maintain list integrity and avoid pointer corruption.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you insert a node at the beginning of the list?\na)\n\npublic class insertFront(int data)\n{\n Node node = new Node(data, head, head.getNext());\n node.getNext().setPrev(node);\n head.setNext(node);\n size++;\n}\n... (other options omitted for brevity)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Self-balancing binary search trees automatically adjust their structure after insertions and deletions to maintain a balanced height and ensure logarithmic operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a self–balancing binary search tree?\na) 2-3 tree\nb) Threaded binary tree\nc) AA tree\nd) Treap\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In an unrolled linked list, each node contains an array of elements. When an element can't fit, data is moved to the next node to preserve efficiency and structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What happens if a node cannot fit an element in an unrolled linked list?\na) The element is discarded\nb) The elements are moved to the next node\nc) The node is discarded\nd) Error message is shown\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A bit array (or bit vector) is a data structure used to efficiently store and manipulate bits, often used in bitmap indexing and space-efficient algorithms.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a bit array?\na) Data structure for representing arrays of records\nb) Data structure that compactly stores bits\nc) An array in which most of the elements have the same value\nd) Array in which elements are not present in continuous locations\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The Jaccard Index measures similarity between two sets. The closer the value is to 1, the more similar the sets are.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When are the members of two sets more common relatively?\na) Jaccard Index is Closer to 1\nb) Jaccard Index is Closer to 0\nc) Jaccard Index is Closer to -1\nd) Jaccard Index is Farther to 1\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Medium\nContext: Bubble sort compares adjacent elements and swaps them if out of order. The number of swaps (interchanges) depends on the initial ordering of elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of interchanges required to sort 5, 1, 6, 2, 4 in ascending order using Bubble Sort is\nOptions: ['A\\n6', 'B\\n5', 'C\\n7', 'D\\n8']\nAnswer: B\n5"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In data structures, a top pointer is typically used in stack implementations to keep track of the element at the top. In tree or heap representations, 'top' may also refer to the root or level-based organization.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For which of the following purpose a top pointer can be used?\na) Storing the address of the head pointer\nb) Storing the address of the previous node\nc) Storing the address of the next node\nd) Storing equal values on the same level\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Data compression algorithms like LZW (Lempel–Ziv–Welch) use structures like suffix trees to represent repeated patterns and efficiently encode them. Suffix trees are useful for searching repeated substrings.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following algorithm of data compression uses a suffix tree?\na) Weiner’s algorithm\nb) Farach’s algorithm\nc) Lempel – Ziv – Welch’s algorithm\nd) Alexander Morse’s algorithm\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The degree of a node is the number of its edges. A transformation that removes degree-2 nodes while connecting their neighbors alters the tree structure, and the final edge count can be derived based on degrees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A binary tree with n > 1 nodes has n1, n2 and n3 nodes of degree one, two and three respectively. The degree of a node is defined as the number of its neighbors.\nStarting with the above tree, while there remains a node v of degree two in the tree, add an edge between the two neighbors of v and then remove v from the tree. How many edges will remain at the end of the process?\nOptions: ['A\\n2 * n1 - 3', 'B\\nn2 + 2 * n1 - 2', 'C\\nn3 - n2', 'D\\nn2 + n1 - 2']\nAnswer: A\n2 * n1 - 3"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Quadratic probing is a collision resolution strategy in open addressing. It uses a quadratic function to compute the next index in the probe sequence to avoid clustering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following schemes does quadratic probing come under?\na) rehashing\nb) extended hashing\nc) separate chaining\nd) open addressing\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Postfix (Reverse Polish) notation represents expressions without parentheses by placing operators after operands. It is used in stack-based expression evaluation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The postfix form of A*B+C/D is:\nOptions: ['A\\n*AB/CD+', 'B\\nAB*CD/+', 'C\\nA*BC+/D', 'D\\nABCD+/*']\nAnswer: B\nAB*CD/+"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The height of a binary tree is the length of the longest path from the root to a leaf. The minimum number of nodes corresponds to a linear tree, and the maximum corresponds to a full binary tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The height of a tree is the length of the longest root-to-leaf path in it. The maximum and minimum number of nodes in a binary tree of height 5 are:\nOptions: ['A\\n63 and 6, respectively', 'B\\n64 and 5, respectively', 'C\\n32 and 6, respectively', 'D\\n31 and 5, respectively']\nAnswer: A\n63 and 6, respectively"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In C, dynamically allocating a matrix using a single pointer requires allocating a contiguous memory block of size rows * columns and casting the result to the appropriate type.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you allocate a matrix using a single pointer in C? (r and c are the number of rows and columns respectively)\na) int *arr = malloc(r * c * sizeof(int));\nb) int *arr = (int *)malloc(r * c * sizeof(int));\nc) int *arr = (int *)malloc(r + c * sizeof(int));\nd) int *arr = (int *)malloc(r * c * sizeof(arr));\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A heap can be constructed in O(n) time using a bottom-up approach by heapifying each internal node in reverse level order, starting from the last non-leaf node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An array of integers of size n can be converted into a heap by adjusting the heaps rooted at each internal node of the complete binary tree starting at the node ⌊(n - 1)/2⌋, and doing this adjustment up to the root node. The time required to construct a heap in this manner is:\nOptions: ['A\\nO(log n)', 'B\\nO(n)', 'C\\nO(n log log n)', 'D\\nO(n log n)']\nAnswer: B\nO(n)"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A rope (cord) is a binary tree data structure used to store and manipulate large strings efficiently by splitting them into smaller chunks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is also known as Rope data structure?\na) Linked List\nb) Array\nc) String\nd) Cord\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Stack underflow occurs when attempting to pop from an empty stack. This function checks for an empty stack and retrieves the top element if available.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following function do?\npublic Object some_func() throws emptyStackException {\n if (isEmpty()) throw new emptyStackException(\"underflow\");\n return first.getEle();\n}\na) pop\nb) delete the top-of-the-stack element\nc) retrieve the top-of-the-stack element\nd) push operation\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In the linked list implementation of a queue, the queue is empty when there are no nodes. This is typically indicated by a null front pointer.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In linked list implementation of a queue, the important condition for a queue to be empty is?\na) FRONT is null\nb) REAR is null\nc) LINK is empty\nd) FRONT == REAR - 1\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: C++ provides built-in algorithms in the STL (Standard Template Library), including `reverse()`, which is used to reverse elements in a container such as an array or vector.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the predefined function for array reversal in C++?\na) reverse()\nb) arr_reverse()\nc) array_reverse()\nd) rev()\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In the dynamic equivalence problem (e.g., union-find), N-1 merges are performed using union operations. If optimized with union by rank and path compression, the time complexity becomes O(N log N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the total time spent for N-1 merges in a dynamic equivalence problem?\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(M log N)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Prefix notation (also called Polish notation) places operators before operands. Converting infix to prefix involves reversing the expression and adjusting parentheses and precedence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The prefix form of an infix expression p + q − r * t is:\nOptions: ['A\\n+ pq − *rt', 'B\\n− +pqr * t', 'C\\n− +pq * rt', 'D\\n− + * pqrt']\nAnswer: C\n− +pq * rt"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In spatial indexing and data retrieval, bin structures are influenced by both the size and location of queries and candidates. These factors affect the accuracy and efficiency of results.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Efficiency of bin depends upon ___________\na) size of query and candidates\nb) location of query and candidates\nc) location and size of query and candidates\nd) depends on the input\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Unrolled linked lists reduce pointer overhead by storing multiple elements per node. However, this increases per-node memory usage and management complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a drawback of an unrolled linked list?\na) Small memory overhead\nb) Cache management\nc) High overhead per node\nd) Slow insertion and deletion\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: A priority queue is an abstract data type in which each element is associated with a priority. Elements are served based on priority rather than just the order they arrive.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is the priority queue an abstract data type?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: Event-driven simulations use queues to manage events sorted by time. Priority queues or min-heaps are common to ensure the earliest event is processed first.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure is commonly used to implement the event-driven simulation of complex systems, such as in computer network simulations or traffic simulations?\nOptions: ['A\\nStack', 'B\\nTree', 'C\\nArray', 'D\\nQueue']\nAnswer: D\nQueue"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A binary tree is said to be height-balanced if the difference in height between the left and right subtrees of any node is at most one. This ensures O(log n) operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A binary tree is balanced if the difference between left and right subtree of every node is not more than ____\na) 1\nb) 3\nc) 2\nd) 0\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: The given pseudo-code converts a decimal number to binary using a stack. Each remainder from dividing by 2 is pushed onto the stack, then popped in reverse order to print binary.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Following is a pseudo code of a function that takes a number as an argument, and uses a stack S to do processing.\ndef fun(n):\n    S = []  # Say it creates an empty stack S\n    while n > 0:\n        # This line pushes the value of n%2 to stack S\n        S.append(n % 2)\n        n = n // 2\n\n    # Run while Stack S is not empty\n    while S:\n        print(S.pop(), end=' ')\nOptions: ['A\\nPrints binary representation of n in reverse order', 'B\\nPrints binary representation of n', 'C\\nPrints the value of Logn', 'D\\nPrints the value of Logn in reverse order']\nAnswer: B\nPrints binary representation of n"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Tree-based questions sometimes involve simple computations like counting nodes, edges, or levels. This question likely tests a conceptual property of a given tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: 5\nOptions: ['A\\n5', 'B\\n4', 'C\\n3', 'D\\n2']\nAnswer: A\n5"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A Cartesian tree is a binary tree derived from a sequence of numbers. When elements are repeated, a tie-breaking rule (e.g., index order) is used to maintain heap and in-order properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a sequence of numbers to have repetitions, how a cartesian tree can be constructed in such situations without violating any rules?\na) use any tie-breaking rule between repeated elements\nb) cartesian tree is impossible when repetitions are present\nc) construct a max heap in such cases\nd) construct a min heap in such cases\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A suffix array is built from a suffix tree using a depth-first traversal. This allows efficient construction and lexicographical sorting of suffixes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suffix array can be created by performing __________ traversal of a suffix tree.\na) breadth-first\nb) level order\nc) depth-first\nd) either breadth-first or level order\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Binary trees can be implemented using arrays or linked lists. The linked list method supports dynamic size and easier insertion/deletion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Advantages of linked list representation of binary trees over arrays?\na) dynamic size\nb) ease of insertion/deletion\nc) ease in randomly accessing a node\nd) both dynamic size and ease in insertion/deletion\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A bit vector is a space-efficient data structure often used to track presence/absence of elements in sets, including for hash tables. It typically uses less space than arrays.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How is a bit vector better compared to a normal array for implementing the hash table?\na) It saves time\nb) It saves space\nc) It saves both time and space\nd) It reduces code complexity\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Parallel arrays are separate arrays where corresponding elements across arrays represent related data. They are often used to avoid struct types in lower-level programming.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are parallel arrays?\na) Arrays of the same size\nb) Arrays allocated one after the other\nc) Arrays of the same number of elements\nd) Arrays allocated dynamically\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Converting infix expressions to postfix requires use of a stack to temporarily hold operators and enforce precedence and associativity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure is needed to convert infix notation to postfix notation?\nOptions: ['A\\nBranch', 'B\\nQueue', 'C\\nTree', 'D\\nStack']\nAnswer: D\nStack"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: To evaluate or convert infix to postfix expressions, operator precedence and associativity rules must be followed. In postfix, operands appear in order followed by operators.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Assume that the operators +, -, × are left associative and ^ is right associative. The order of precedence (from highest to lowest) is ^, ×, +, -. The postfix expression corresponding to the infix expression a + b × c - d ^ e ^ f is:\nOptions: ['A\\nabc × + def ^ ^ -', 'B\\nabc × + de ^ f ^ -', 'C\\nab + c × d - e ^ f ^', 'D\\n- + a × bc ^ ^ def']\nAnswer: A\nabc × + def ^ ^ -"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: AVL trees are height-balanced binary search trees. The code recursively computes left and right subtree heights and checks balance at every node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the pseudo code:\n\nint avl(binarysearchtree root):\n     if(not root)\n       return 0\n     left_tree_height = avl(left_of_root)\n     if(left_tree_height== -1) \n       return left_tree_height\n     right_tree_height= avl(right_of_root)\n     if(right_tree_height==-1)\n       return right_tree_height\n\nDoes the above code check if a binary search tree is an AVL tree?\na) yes\nb) no\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Suffix trees are compressed tries of all suffixes of a string. With efficient algorithms like Ukkonen's, a suffix tree can be constructed in linear time relative to the string length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How much time does construction of suffix tree take?\na) O (log M)\nb) O (M!)\nc) Exponential to Length of Tree\nd) Linear to Length of Tree\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A Fibonacci heap offers improved amortized performance over a binomial heap for operations like decrease-key and delete, due to its more relaxed structure and lazy operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The Statement “Fibonacci heap has better amortized running time in compare to a binomial heap”.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: When performing a union operation on two Fibonacci heaps of order n, the resulting heap's order increases by 1 due to the merging of root lists and potential structural changes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the order of new heap created after union of heap H1 and H2 when created by the following code. Initially both are of the order n?\na) n+1\nb) n+n/2\nc) nlogn\nd) 2*n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Operator precedence defines the order in which operations are evaluated in expressions. Among common operators like +, *, &, |, and $, the bitwise OR (|) typically has the lowest priority.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Out of the following operators (|, *, +, &, $), the one having lowest priority is ________\na) +\nb) $\nc) |\nd) &\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: 2-3 trees are balanced search trees that maintain sorted order and support efficient insertions, deletions, and searches in logarithmic time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following data structures can provide efficient searching of the elements?\na) binary search tree\nb) unordered lists\nc) 2-3 tree\nd) treap\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The fetch operation in computing is responsible for retrieving an instruction from memory. It is part of the instruction cycle, typically handled by the control unit.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following performs the fetch operation?\na)\n\nb)\n\nc)\n\nd)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: In linear probing, clustering affects performance. The expected cost of a successful search is based on the cost of an unsuccessful one, because probing continues until a match or an empty slot is found.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In linear probing, the cost of an unsuccessful search can be used to compute the average cost of a successful search.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In Java, arrays use zero-based indexing. Printing arr[2] and arr[4] from the array {1,2,3,4,5} will return the third and fifth elements respectively.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the output of the following Java code?\npublic class array {\n  public static void main(String args[]) {\n    int []arr = {1,2,3,4,5};\n    System.out.println(arr[2]);\n    System.out.println(arr[4]);\n  }\n}\na) 3 and 5\nb) 5 and 3\nc) 2 and 4\nd) 4 and 2\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: An AVL tree is a self-balancing binary search tree. It maintains a balance factor to ensure that the height difference between left and right subtrees is at most 1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is an AVL tree?\na) a tree which is unbalanced and is a height balanced tree\nb) a tree which is balanced and is a height balanced tree\nc) a tree with at most 3 children\nd) a tree with three children\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A ternary heap is a variation of a binary heap where each node has up to three children. It must still maintain the heap property, either min-heap or max-heap.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which property should a ternary heap hold for execution?\na) Associative\nb) Commutative\nc) Tree\nd) Heap\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: If multiplying matrix A with matrix C results in the identity matrix, then matrix C is the inverse of A by definition of matrix inverse.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Matrix A when multiplied with Matrix C gives the Identity matrix I. What is C?\na) Identity matrix\nb) Inverse of A\nc) Square of A\nd) Transpose of A\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Skip lists are probabilistic data structures that allow fast search, insertion, and deletion. They use multiple layers to emulate balanced trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is a skip list like balanced tree?\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Stacks operate on a LIFO principle and are ideal for reversing sequences like strings or words, since the last character pushed will be the first one popped.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which is the most appropriate data structure for reversing a word?\na) stack\nb) queue\nc) graph\nd) tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Arrays have a fixed size once declared. If fewer elements are inserted, unused space leads to memory inefficiency.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the disadvantages of arrays?\na) Data structure like queue or stack cannot be implemented\nb) There are chances of wastage of memory space if elements inserted in an array are lesser than the allocated size\nc) Index value of an array can be negative\nd) Elements are sequentially accessed\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a heap, the root node always contains the minimum (min-heap) or maximum (max-heap) value. A linear scan of heap array for minimum will still return the root.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does this pseudo_code return?\nint myfun(heap_arr[]) {\n  int mini=INF;\n  for(int i=0;i<tot_node;i++)\n    mini=min(mini,heap_arr[i]);\n  return mini;\n}\na) Last added element to heap\nb) First element added to heap\nc) Root of the heap\nd) Leftmost node of the heap\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The upper bound of an array is the highest valid index. It represents the maximum index that can be accessed safely in the array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The largest element of an array index is called its ____________.\nOptions: ['A\\nlower bound.', 'B\\nrange.', 'C\\nupper bound.', 'D\\nAll of these.']\nAnswer: C\nupper bound."
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: Adjacency lists use space proportional to the number of edges, making them more efficient than adjacency matrices for sparse graphs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For some sparse graph an adjacency list is more space efficient against an adjacency matrix.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A B-tree is a general-purpose balanced search tree, not necessarily a binary tree. AVL, red-black, and splay trees are all types of self-balancing binary trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following tree data structures is not a balanced binary tree?\na) AVL tree\nb) Red-black tree\nc) Splay tree\nd) B-tree\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Evaluating prefix expressions involves scanning from right to left and applying operations to operands. This example is a complex prefix computation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Find the output of the following prefix expression:\n*+2-2 1/-4 2+-5 3 1\na) 2\nb) 12\nc) 10\nd) 4\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: When inserting a new value into a max heap, the value is added at the end and then bubbled up to maintain the heap property. This results in a reordering of elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a max heap, represented by the array: 40, 30, 20, 10, 15, 16, 17, 8, 4. Now consider that a value 35 is inserted into this heap. After insertion, the new heap is:\nOptions: ['A\\n40, 30, 20, 10, 15, 16, 17, 8, 4, 35', 'B\\n40, 35, 20, 10, 30, 16, 17, 8, 4, 15', 'C\\n40, 30, 20, 10, 35, 16, 17, 8, 4, 15', 'D\\n40, 35, 20, 10, 15, 16, 17, 8, 4, 30']\nAnswer: B\n40, 35, 20, 10, 30, 16, 17, 8, 4, 15"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Pairing heaps are simple yet efficient heap structures. Their performance benefits stem from their simple operations, particularly meld, which allow fast amortized performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the reason for the efficiency of a pairing heap?\na) simplicity\nb) time-efficient\nc) space-efficient\nd) advanced\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Syntax trees and parse trees are both used in compilers to represent the structure of code. Syntax trees omit extra grammatical detail, making them denser than parse trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Syntax trees are comparatively denser than parse trees.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The average depth of a binary tree refers to the average distance from the root to all nodes. For a randomly built tree, this depth is approximately O(√N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The average depth of a binary tree is given as?\na) O(N)\nb) O(√N)\nc) O(N²)\nd) O(log N)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Postfix expressions are evaluated using a stack where operands are pushed and operators cause the last operands to be popped and evaluated.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The data structure required to evaluate a postfix expression is:\nOptions: ['A\\nQueue', 'B\\nStack', 'C\\nArray', 'D\\nlinked-list']\nAnswer: B\nStack"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Hash table insertion involves computing a hash and probing for empty slots if collisions occur. The insertion index depends on the hash function and probe strategy.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Where does the number 14 get inserted in the following table?\na) 2\nb) 9\nc) 4\nd) 8\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In a singly linked list, deleting the last element requires traversing the entire list to find the node before the last one, making the operation O(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a singly linked list of the form where F is a pointer to the first element in the linked list and L is the pointer to the last element of the list. The time of which of the following operations depends on the length of the list?\nOptions: ['A\\nDelete the last element of the list', 'B\\nDelete the first element of the list', 'C\\nAdd an element after the last element of the list', 'D\\nInterchange the first two elements of the list']\nAnswer: A\nDelete the last element of the list"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: To set a specific bit to 0 in bitwise operations, the AND operator is used with a bitmask that has 0 in the desired bit position and 1 elsewhere.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following bitwise operations will you use to set a particular bit to 0?\na) OR\nb) AND\nc) XOR\nd) NAND\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Hash tables provide average constant time access using keys, unlike linked lists which require linear time search.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the advantage of the hash table over a linked list?\na) faster access of data\nb) easy to implement\nc) very efficient for less number of entries\nd) exhibit good locality of reference\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Balanced binary trees include AVL, red-black, and splay trees. B-trees are multi-way trees typically used for disk storage and are not binary.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following tree data structures is not a balanced binary tree?\na) Splay tree\nb) B-tree\nc) AVL tree\nd) Red-black tree\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The recurrence relation Fn = Fn−1 + Fn−2 defines the Fibonacci sequence, where each number is the sum of the two preceding ones.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The following formula will produce: Fn = Fn-1 + Fn-2\nOptions: ['A\\nArmstrong Number', 'B\\nFibonacci Series', 'C\\nEuler Number', 'D\\nPrime Number']\nAnswer: B\nFibonacci Series"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Infix expressions follow standard operator precedence and associativity rules. Evaluating such expressions requires a correct understanding of these rules.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Evaluation of infix expression is done based on precedence of operators.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Linked lists offer better performance for insertion/deletion, while arrays support better cache locality and constant-time random access. Accessing elements in a linked list is slower.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following points is/are not true about Linked List data structure when compared with an array?\na) Arrays have better cache locality that can make them better in terms of performance\nb) It is easy to insert and delete elements in Linked List\nc) Random access is not allowed in a typical implementation of Linked Lists\nd) Access of elements in linked list takes less time than compared to arrays\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Preorder traversal visits the root node first, then recursively visits the left and right subtrees. The function prints the node before visiting its children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following piece of code do?\n\npublic void func(Tree root) {\n System.out.println(root.data());\n func(root.left());\n func(root.right());\n}\n\na) Preorder traversal\nb) Inorder traversal\nc) Postorder traversal\nd) Level order traversal\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A leftist tree is a priority queue implemented using a binary tree that satisfies the leftist property. For a tree of rank r, it must have at least 2r−1 nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many nodes does a leftist tree with r nodes must have?\na) 2r\nb) 2r-1\nc) 2r\nd) 2r-1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Open addressing is one of the methods for handling collisions in hash tables. It searches for the next available slot when a collision occurs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following techniques is used for handling collisions in a hash table?\na) Open addressing\nb) Hashing\nc) Searching\nd) Hash function\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: This is an algorithmic question involving cyclic shifts of array elements. Performing the shift in-place requires careful index tracking without additional memory.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An array A consists of n integers in locations A[0], A[1]...A[n-1]. It is required to shift the elements of the array cyclically to the left by k places, where 1 <= k <= (n-1). Complete the algorithm by filling in the blanks.\nmin = n; i = 0;\nwhile (___________) {\n temp = A[i]; j = i;\n while (________) {\n   A[j] = ________;\n   j = (j + k) mod n;\n   If (j < min) then min = j;\n}\nA[(n + i - k) mod n] = ________;\ni = __________;\nOptions: ['A\\ni > min; j!= (n+i)mod n; A[j + k]; temp; i + 1 ;', 'B\\ni < min; j!= (n+i)mod n; A[j + k]; temp; i + 1;', 'C\\ni > min; j!= (n+i+k)mod n; A[(j + k)]; temp; i + 1;', 'D\\ni < min; j!= (n+i-k)mod n; A[(j + k)mod n]; temp; i + 1;']\nAnswer: D\ni < min; j!= (n+i-k)mod n; A[(j + k)mod n]; temp; i + 1;"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A sentinel is a dummy value placed at the end of a data structure (like an array) to mark the end and simplify algorithms like linear search.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The extra key inserted at the end of the array is called a ________.\nOptions: ['A\\nEnd key.', 'B\\nStop key.', 'C\\nSentinel.', 'D\\nTransposition.']\nAnswer: C\nSentinel."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A directed tree with n nodes has n-1 edges. The number of structurally unique directed trees with 3 nodes is 3, considering all possible root-child configurations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of different directed trees with 3 nodes are:\nOptions: ['A\\n2', 'B\\n3', 'C\\n4', 'D\\n5']\nAnswer: B\n3"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a B+ tree, leaf nodes are linked for sequential access. Once a leaf is found, accessing the next record is done in constant time using the sibling pointer.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Efficiency of finding the next record in B+ tree is ____\na) O(n)\nb) O(log n)\nc) O(nlog n)\nd) O(1)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In a binary min heap, the smallest element is at the root, but the largest element is not in a fixed location. To find it, a full scan is needed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a binary min heap containing n elements, the largest element can be found in __________ time.\na) O(n)\nb) O(nlogn)\nc) O(logn)\nd) O(1)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: A simple undirected graph with n vertices can have at most n(n-1)/2 edges. Any more will necessarily create a parallel edge or self-loop.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A graph with n vertices will definitely have a parallel edge or self loop if the total number of edges are __________.\nOptions: ['A\\nmore than n', 'B\\nmore than n+1', 'C\\nmore than (n+1)/2', 'D\\nmore than n(n-1)/2']\nAnswer: D\nmore than n(n-1)/2"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: Binary search assumes the list is sorted, whereas linear search does not. This makes element order critical for binary search.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A characteristic of the data that binary search uses but linear search ignores is the __________.\nOptions: ['A\\nOrder of the elements of the list.', 'B\\nLength of the list.', 'C\\nMaximum value in list.', 'D\\nType of elements of the list.']\nAnswer: A\nOrder of the elements of the list."
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a min-heap, the 7th smallest element is not necessarily at a specific location. Finding it requires traversing the heap selectively, taking O(log n) in optimized approaches.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a min-heap with n elements with the smallest element at the root, the 7th smallest element can be found in time:\nOptions: ['A\\ntheta(nlogn)', 'B\\ntheta(n)', 'C\\ntheta(logn)', 'D\\ntheta(1)']\nAnswer: C\ntheta(logn)"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: K-d trees are spatial data structures that allow efficient range searching and nearest neighbor queries. They are simpler than advanced multidimensional structures.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the simplest data structure that supports range searching?\na) Heaps\nb) binary search trees\nc) AA-trees\nd) K-d trees\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: A sorting algorithm is stable if it maintains the relative order of records with equal keys. This is useful when multiple keys are involved.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A stable sorting algorithm:\nOptions: ['A\\ndoes not crash.', 'B\\ndoes not run out of memory.', 'C\\ndoes not change the sequence of appearance of elements.', 'D\\ndoes not exist.']\nAnswer: C\ndoes not change the sequence of appearance of elements."
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: Reversing a queue using another queue is not feasible with queue-only operations, as queues do not support reverse-order access natively like stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: n elements of a Queue are to be reversed using another queue. The number of “ADD” and “REMOVE” operations required to do so is:\nOptions: ['A\\n2*n', 'B\\n4*n', 'C\\nn', 'D\\nThe task cannot be accomplished']\nAnswer: D\nThe task cannot be accomplished"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The code rotates an array left by 4 positions using temporary storage. The output is a rotated array where elements from the start are moved to the end.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following code?\n\n#include <iostream>\nusing namespace std;\nint main() {\n    int arr[] = {1,2,3,4,5,6};\n    int n = sizeof(arr)/sizeof(arr[0]);\n    int d=4;\n    int temp[10];\n    for(int i=0;i<d;i++) temp[i]=arr[i];\n    int j=0;\n    for(int i=d;i<n;i++,j++) arr[j]=arr[i];\n    int k=0;\n    for(int i=n-d;i<n;i++,k++) arr[i]=temp[k];\n    for(int i=0;i<n;i++) cout<<arr[i]<<\" \";\n    return 0;\n}\na) 5 6 1 2 3 4\nb) 6 5 4 3 1 2\nc) 3 4 5 6 1 2\nd) error\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Amortized analysis gives average performance over a sequence of operations. For heaps, deleting the minimum element takes O(log N) time in amortized complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The amortized time efficiency for performing deletion of a minimum element is?\na) O(N)\nb) O(log N)\nc) O(N²)\nd) O(M log N)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: An expression tree represents arithmetic expressions using a binary tree structure. Postfix expressions are typically used to construct expression trees bottom-up.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An expression tree is created using?\na) postfix expression\nb) prefix expression\nc) infix expression\nd) parenthesized expression\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Index mapping is a simple hashing approach where data values directly map to positions in the hash table without needing complex hash functions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which is a simple form of hashing where the data is directly mapped to an index in a hash table?\nOptions: ['A\\nCollision', 'B\\nIndex Mapping', 'C\\nFunctional Mapping', 'D\\nHash function']\nAnswer: B\nIndex Mapping"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Operator precedence determines the order of evaluation in expressions. Among the listed operators, exponentiation (^) has the highest precedence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Out of the following operators (^, *, +, &, $), the one having highest priority is _________\na) +\nb) $\nc) ^\nd) &\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In doubly linked lists, deleting a node when its address is known is efficient due to backward traversal capability, unlike singly linked lists which require full traversal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following operations is performed more efficiently by doubly linked list than by singly linked list?\nOptions: ['A\\nDeleting a node whose location is given', 'B\\nSearching an unsorted list for a given item', 'C\\nInverting a node after the node with a given location', 'D\\nTraversing a list to process each node']\nAnswer: A\nDeleting a node whose location is given"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In tree representations using symbols, nodes with children are typically denoted using specific symbols like triangles or special markers depending on convention.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following symbols and choose which of the symbols represent nodes having at least one child?\ni) Δ ii) ◊ iii) ∇ iv) T v) ⊥\na) iv) and v)\nb) iii) iv) and v)\nc) i) and ii)\nd) i) and iii)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: When converting prefix to infix expressions, the first step is to reverse the prefix string to start processing from the end.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When converting the prefix notation into an infix notation, the first step to be followed is ________\na) Reverse the equation\nb) Push the equation to the stack\nc) Push the equation onto the queue\nd) Push the equation to the stack or queue\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: K-d trees are efficient for range searching in multidimensional space. They are simpler than AA-trees and more effective than binary heaps for this use.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the simplest data structure that supports range searching?\na) AA-trees\nb) K-d trees\nc) Heaps\nd) binary search trees\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In an unbalanced binary search tree, the insertion and deletion operations can degrade to linear time O(n) in the worst case (e.g., skewed trees).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the worst-case complexities of insertion and deletion of a key in a binary search tree?\nOptions: ['A\\nΘ(logn) for both insertion and deletion', 'B\\nΘ(n) for both insertion and deletion', 'C\\nΘ(n) for insertion and Θ(logn) for deletion', 'D\\nΘ(logn) for insertion and Θ(n) for deletion']\nAnswer: B\nΘ(n) for both insertion and deletion"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a min-heap, each parent node is less than or equal to its children. This property ensures that the root is the smallest element.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a min-heap:\nOptions: ['A\\nparent nodes have values greater than or equal to their children', 'B\\nparent nodes have values less than or equal to their children', 'C\\nboth statements are true', 'D\\nboth statements are wrong']\nAnswer: B\nparent nodes have values less than or equal to their children"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: C++’s `map` container is a key-value associative container that can be used to implement adjacency lists for graph representations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: To create an adjacency list C++’s map container can be used.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The sequence of stack operations must be traced step-by-step. Pushing and popping affect the stack contents, and the final state reflects the order of operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output if the following sequence of operations are executed?\nPush(a,s);\nPush(b,s);\nPop(b);\nPush(c,s);\na) abc\nb) b\nc) ac\nd) acb\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A leftist heap is a variant of a binary heap that maintains balance using null path length (NPL), which for a null node is defined as -1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a leftist heap, the null path length of a null node is defined as?\na) 0\nb) 1\nc) null\nd) -1\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: This function buffers insertions and only pushes to the heap when full. Such buffering makes average insertion time constant (amortized O(1)).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the complexity of the given function for insertion?\ninsert(int n) {\n  if(buffer_size()< max_buffer_size())\n    buffer_arr[ind] = n;\n  else\n    move_to_heap(buffer, buffer+max_buffer_size());\n}\na) O(logn)\nb) amortized O(1)\nc) O(n)\nd) O(n*logn)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: This Java function fetches a value from a sparse array using row and column indices. It includes bounds checking before access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the following piece of code?\n\npublic Object function(int row_index, int col_index) {\n  if (row_index < 0 || col_index > N) {\n    System.out.println(\"column index out of bounds\");\n    return;\n  }\n  return (sparse_array[row_index].fetch(col_index));\n}\na) Store the element in the specified position\nb) Get the element from the specified position\nc) Alter the element in the specified position\nd) Remove the element from the specified position\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The function checks whether a node is a child of any ancestor and prints that ancestor, effectively printing the ancestors of a given node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the code below trying to print?\n\nvoid print(tree *root, tree *node) {\n  if(root == null) return 0;\n  if(root->left == node || root->right == node || print(root->left,node) || print(root->right,node)) {\n    print(root->data);\n  }\n}\na) Just printing all nodes\nb) Not a valid logic to do any task\nc) Printing ancestors of a node passed as argument\nd) Printing nodes from leaf node to a node passed as argument\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: A deque can be implemented using two stacks by reversing the order between stacks to support operations on both ends.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A Double-ended queue supports operations such as adding and removing items from both ends. You are given only stacks to implement this data structure. What are the total number of stacks required for this operation (you can reuse the stack)?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Depth-first traversal of a graph uses a stack either explicitly or via recursion to explore nodes as deep as possible before backtracking.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What data structure is used for depth-first traversal of a graph?\nOptions: ['A\\nQueue', 'B\\nStack', 'C\\nList', 'D\\nNone of these']\nAnswer: B\nStack"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In inorder threaded binary trees, inorder traversal should use the inorder successor, not predecessor, to move through the tree efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is wrong with the below code for inorder traversal of a threaded binary tree?\n\ninordertraversal(threadedtreenode root):\n  threadedtreenode q = inorderpredecessor(root)\n  while(q != root):\n    q = inorderpredecessor(q)\n    print q.data\n\na) inorder successor instead of inorder predecessor must be used\nb) code is correct\nc) it is code for post order\nd) it is code for pre order\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The function pops the last element of a vector. Pop and fetch operations from the end of a vector in C++ STL are O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: State the complexity of the algorithm given below.\n\nint function(vector<int> arr) {\n  int len = arr.length();\n  if(len == 0) return;\n  temp = arr[len-1];\n  arr.pop_back();\n  return temp;\n}\na) O(n)\nb) O(logn)\nc) O(1)\nd) O(n logn)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: Insertion sort is a stable sorting algorithm, meaning it preserves the relative order of elements with equal keys. Heap and quick sort are unstable.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following sorting algorithms is stable?\nOptions: ['A\\nInsertion sort', 'B\\nBubble sort', 'C\\nQuick sort', 'D\\nHeap sort']\nAnswer: A\nInsertion sort"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A stack overflow occurs when pushing an element onto a full stack, typically when the allocated memory for the stack is exhausted.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does ‘stack overflow’ refer to?\na) accessing item from an undefined stack\nb) adding items to a full stack\nc) removing items from an empty stack\nd) index out of bounds exception\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: In sparse graphs, an adjacency list is preferred over a matrix because it uses less memory and offers faster iteration over neighbors.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In which case is an adjacency list preferred over an adjacency matrix?\na) Dense graph\nb) Sparse graph\nc) Adjacency list is always preferred\nd) Complete graph\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: The Tiger tree hash is a type of hash tree structure commonly used in cryptographic applications to verify data integrity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a widely used form of the hash tree?\na) B+ – tree\nb) T tree\nc) Tiger tree hash\nd) Htree\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Doubly linked lists allow bidirectional traversal, which makes operations like deleting a known node more efficient than singly linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following operations is performed more efficiently by doubly linked list than by singly linked list?\nOptions: ['A\\nDeleting a node whose location is given', 'B\\nSearching of an unsorted list for a given item', 'C\\nInserting a new node after node whose location is given', 'D\\nTraversing the list to process each node']\nAnswer: A\nDeleting a node whose location is given"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: XOR linked lists use XOR of addresses instead of storing separate next and previous pointers. The code must maintain XOR logic during insertion and updates.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following pseudocode for insertion in an XOR list. What must the address fields of the new and adjacent nodes satisfy?\n\na) Address of new node = NULL XOR next; Address of next node = new XOR original\nb) Address of new node = NULL XOR current; Address of previous = new XOR null\nc) Address fields remain unchanged\nd) The logic cannot be implemented using XOR\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: The provided Java function checks if the queue is empty and returns the front element without removing it. This is typically a peek operation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following Java code do?\n\npublic Object function() {\n if(isEmpty())\n   return -999;\n else {\n   Object high;\n   high = q[front];\n   return high;\n }\n}\na) Dequeue\nb) Enqueue\nc) Return the front element\nd) Return the last element\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: A queue is a First In First Out (FIFO) data structure, but some implementations allow both FIFO and LILO characteristics depending on the use case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following properties is associated with a queue?\na) First In Last Out\nb) First In First Out and Last in Last Out\nc) Last In First Out\nd) Last In Last Out Only\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Open addressing in hash tables can lead to a situation where all slots are filled, causing the table to be considered full even if not all keys are stored.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A hash table may become full in the case when we use open addressing.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Separate chaining stores multiple elements in the same hash slot using linked lists, but using just the list head doesn't reduce collisions—it organizes them.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: By implementing separate chaining using a list head we can reduce the number of collisions drastically.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A parse tree represents the syntactic structure of code based on tokens generated by the lexical analyzer during compilation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Parse tree is constructed from the tokens produced by the lexical analyzer.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: A doubly linked list allows bidirectional traversal, making it easier to insert at both ends. Adding nodes before head and after tail updates the links accordingly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following doubly linked list: head-1-2-3-4-5-tail. What will be the list after performing the given sequence of operations?\na) head-0-1-2-3-4-5-6-tail\nb) head-1-2-3-4-5-6-tail\nc) head-6-1-2-3-4-5-0-tail\nd) head-0-1-2-3-4-5-tail\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: To check for balanced parentheses in an expression, a stack is used to push opening brackets and pop them when closing brackets are encountered.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The data structure required to check whether an expression contains a balanced parenthesis is?\na) Stack\nb) Queue\nc) Array\nd) Tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Under simple uniform hashing with chaining, the probability of avoiding the first few slots is calculated by raising the complement of their probabilities.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a hash table with 100 slots. Collisions are resolved using chaining. Assuming simple uniform hashing, what is the probability that the first 3 slots are unfilled after the first 3 insertions?\nOptions: ['A\\n(97 × 97 × 97)/100³', 'B\\n(99 × 98 × 97)/100³', 'C\\n(97 × 96 × 95)/100³', 'D\\n(97 × 96 × 95)/(3! × 100³)']\nAnswer: A\n(97 × 97 × 97)/100³"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: Input character classification in algorithms like parsers or lexical analyzers often depends on detecting multiple types such as alphabets, digits, and symbols.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many types of input characters are accepted by this algorithm?\na) one\nb) two\nc) three\nd) four\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In C, arrays support declaration and definition but do not support dynamic allocation natively without using pointers and malloc.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not possible with an array in C programming language?\nOptions: ['A\\nDeclaration', 'B\\nDefinition', 'C\\nDynamic Allocation', 'D\\nArray of strings']\nAnswer: C\nDynamic Allocation"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In open addressing, the load factor is defined as the ratio of the number of elements stored to the total number of available slots in the table.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the load factor for an open addressing technique?\na) 1\nb) 0.5\nc) 1.5\nd) 0\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Post-order traversal visits the left child, right child, and then the root. This order is crucial for operations like deleting trees or evaluating expressions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which among the following is the pseudo code for post-order traversal?\nOptions: ['A\\nOrder(node):\\n    if node is not null:\\n       Order(node.left)\\n       Order(node.right)\\n       print node.value', 'B\\nOrder(node):\\n    if node is not null:\\n       Order(node.right)\\n       Order(node.left)\\n       print node.value', 'C\\nOrder(node):\\n    if node is not null:\\n       Order(node.left)\\n       print node.value', 'D\\nNone of the above']\nAnswer: A\nOrder(node):\n    if node is not null:\n       Order(node.left)\n       Order(node.right)\n       print node.value"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: A pseudograph allows loops (self-edges). If an adjacency matrix contains non-zero diagonal entries, it indicates the presence of loops, hence a pseudograph.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given adjacency matrices, determine which of them are pseudographs?\ni) {{1,0},{0,1}}\nii) {{0,1},{1,0}}\niii) {{0,0,1},{0,1,0},{1,0,0}}\na) only i)\nb) ii) and iii)\nc) i) and iii)\nd) i), ii), and iii)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: A Graph Structured Stack is a variant used in Tomita's parsing algorithm to manage multiple parsing paths efficiently in natural language processing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Graph Structured Stack finds its application in _____________\na) Bogo Sort\nb) Tomita’s Algorithm\nc) Todd–Coxeter algorithm\nd) Heap Sort\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: A sparse matrix is one in which the number of zero elements is more than half the total number of elements, optimizing storage and computation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The matrix contains m rows and n columns. The matrix is called a Sparse Matrix if ________\na) Total number of zero elements > (m×n)/2\nb) Total number of zero elements = m + n\nc) Total number of zero elements = m/n\nd) Total number of zero elements = m − n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Indexed sequential search combines the speed of binary search with the simplicity of sequential search but requires additional space for the index.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The search technique for searching a sorted file that requires increased amount of space is ____________.\nOptions: ['A\\nIndexed sequential search', 'B\\nInterpolation search', 'C\\nSequential search', 'D\\nTree search']\nAnswer: A\nIndexed sequential search"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Medium\nContext: Direct addressing uses the key as the index in an array, allowing constant-time O(1) access when the universe of keys is small.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the search complexity in direct addressing?\na) O(n)\nb) O(logn)\nc) O(nlogn)\nd) O(1)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: ArrayIndexOutOfBoundsException in Java occurs at runtime when trying to access an index outside the array bounds.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When does the ArrayIndexOutOfBoundsException occur?\na) Compile-time\nb) Run-time\nc) Not an error\nd) Not an exception at all\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The number of distinct binary search trees with n distinct keys is given by the nth Catalan number. For n=4, it is 14.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many distinct binary search trees can be created out of 4 distinct keys?\nOptions: ['A\\n5', 'B\\n14', 'C\\n24', 'D\\n35']\nAnswer: B\n14"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Hashing allows O(1) average time complexity for searches using direct access via hash functions, assuming ideal distribution and no collisions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The searching technique that takes O(1) time to find data is:\nOptions: ['A\\nLinear Search', 'B\\nBinary Search', 'C\\nHashing', 'D\\nTree Search']\nAnswer: C\nHashing"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Binary search requires random access, which is not supported by linked lists. Linked lists perform best with sequential operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Linked lists are not suitable for the implementation of ___________\na) Insertion sort\nb) Radix sort\nc) Polynomial manipulation\nd) Binary search\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In an Acyclic Directed Graph (DAG), if v is reachable from u, it does not imply the reverse. This is due to the directed nature and absence of cycles.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For any two different vertices u and v of an Acyclic Directed Graph, if v is reachable from u, is u also reachable from v?\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: To implement a stack using two queues, making the push operation costly involves transferring all elements on each push to reverse the order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Making the push operation costly, select the code snippet which implements the same using two queues.\na) Perform push() with push as the costlier operation\nb) Perform push() with pop as the costlier operation\nc) Perform pop() with push as the costlier operation\nd) Perform pop() with pop as the costlier operation\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a B+ tree, leaf nodes store key-value pairs and data pointers. Their order is the maximum number of such pairs that fit in a block, calculated based on block size and field sizes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The order of a leaf node in a B+ tree is the maximum number of (value, data record pointer) pairs it can hold. Given that the block size is 1K bytes, data record pointer is 7 bytes, the value field is 9 bytes, and a block pointer is 6 bytes, what is the order of the leaf node?\nOptions: ['A\\n63', 'B\\n64', 'C\\n67', 'D\\n68']\nAnswer: A\n63"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The `rotate()` function in C++ STL takes three arguments: the beginning, the middle (new start), and the end iterator. It rotates the range.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many arguments are required by the predefined function rotate() in C++?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Converting infix to postfix respects operator precedence and associativity. The correct postfix form is obtained by traversing the expression accordingly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The postfix form of A*B+C/D is?\na) *AB/CD+\nb) AB*CD/+\nc) A*BC+/D\nd) ABCD+/*\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Prefix notation (Polish notation) places the operator before its operands. Conversion involves operator precedence and associativity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the Prefix notation for the given equation?\na) +A*CB\nb) *B+AC\nc) +A*BC\nd) *A+CB\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In linear probing, collisions are resolved by checking subsequent slots until an empty one is found. The key is hashed and shifted by one on each collision.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In the following given hash table, use linear probing to find the location of 49.\na) 7\nb) 6\nc) 2\nd) 0\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The Tower of Hanoi problem has a well-known recurrence relation where the number of moves required is 2^k – 1 for k disks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the number of moves required to solve Tower of Hanoi problem for k disks?\na) 2^k – 1\nb) 2^k + 1\nc) 2k + 1\nd) 2k – 1\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Inversions represent the number of pairs in an array where the order is incorrect. Reverse-sorted arrays have the maximum number of inversions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Under what condition are the number of inversions in an array maximum?\na) when the array is sorted\nb) when the array is reverse sorted\nc) when the array is half sorted\nd) depends on the given array\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: A dequeue (double-ended queue) supports insertions and deletions at both ends, and is often implemented using doubly linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a dequeue?\na) A queue with insert/delete defined for both front and rear ends of the queue\nb) A queue implemented with a doubly linked list\nc) A queue implemented with both singly and doubly linked lists\nd) A queue with insert/delete defined for front side of the queue\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: This problem tests stack and queue manipulation. The operations require simulating the data movements carefully to track the resulting top of stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The five items: A, B, C, D, and E are pushed in a stack, one after another starting from A. The stack is popped four items and each element is inserted in a queue. Two elements are deleted from the queue and pushed back on the stack. Now one item is popped from the stack. The popped item is:\nOptions: ['A\\nA', 'B\\nB', 'C\\nC', 'D\\nD']\nAnswer: D\nD"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: AA trees are a form of balanced binary search trees that mimic the structure of 2–3 trees and maintain logarithmic height.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following BSTs is isometric with the 2-3 tree?\na) Splay tree\nb) AA tree\nc) Heap\nd) Red – Black tree\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: This function iterates through a linked list and returns the index (position) of a node with a matching value. If not found, it returns Integer.MIN_VALUE.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the following piece of code?\n\npublic int function(int data) {\n Node temp = head;\n int var = 0;\n while(temp != null) {\n   if(temp.getData() == data) {\n     return var;\n   }\n   var = var + 1;\n   temp = temp.getNext();\n }\n return Integer.MIN_VALUE;\n}\na) Find and delete a given element in the list\nb) Find and return the given element in the list\nc) Find and return the position of the given element in the list\nd) Find and insert a new element in the list\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: This Java function uses a stack to match each closing parenthesis with its corresponding opening one, printing their indices.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following programs prints the index of every matching parenthesis?\na) [Java code matching opening and closing brackets and printing indices]\nb) [Same with incorrect logic for index matching]\nc) [Logic reversed for ')' before '(']\nd) [Unmatched index misplacement]\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In a weighted graph, multiplying edge weights by a constant factor preserves relative path costs, so the shortest path remains unchanged. Adding/subtracting does not preserve path relationships.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Assuming value of every weight to be greater than 10, in which of the following cases will the shortest path of a directed weighted graph from 2 vertices u and v never change?\na) add all values by 10\nb) subtract 10 from all the values\nc) multiply all values by 10\nd) in both the cases of multiplying and adding by 10\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Suffix arrays are efficient structures for string processing and can be constructed in O(nlogn) time using sorting-based approaches.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suffix array can be created in O(nlogn) time.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a binary heap of height h, the leaf nodes can appear at height h or h–1 due to the complete binary tree structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The leaf node for a heap of height h will be at which position?\na) h\nb) h–1\nc) h or h–1\nd) h–2\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: The basic operation in a pairing heap is merging, which allows efficient support for insertions, deletions, and decrease-key operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the basic operation performed in a pairing heap?\na) merge\nb) deletion\nc) insertion\nd) swapping\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: A Graph Structured Stack (GSS) used in parsing algorithms like Tomita’s is represented as a Directed Acyclic Graph (DAG).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A Graph Structured Stack is a _____________\na) Undirected Graph\nb) Directed Graph\nc) Directed Acyclic Graph\nd) Regular Graph\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Each node in a doubly linked list typically contains three fields: data, pointer to the next node, and pointer to the previous node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The minimum number of fields with each node of a doubly linked list is:\nOptions: ['A\\n1', 'B\\n2', 'C\\n3', 'D\\n4']\nAnswer: C\n3"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Balanced BSTs like AVL trees allow faster searching (O(log n)) compared to binary heaps which only guarantee fast access to the min/max.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is an advantage of a balanced binary search tree, like an AVL tree, compared to a binary heap?\na) insertion takes less time\nb) deletion takes less time\nc) searching takes less time\nd) construction of the tree takes less time than binary heap\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Tango trees use a partitioning technique to group access paths efficiently, improving access time for dynamic search trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is the partitioning method used by the Tango Tree?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A hash function computes an index (or location) for storing or retrieving a value in a hash table based on the key.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a hash function?\na) A function that allocates memory to keys\nb) A function that computes the location of the key in the array\nc) A function that creates an array\nd) A function that computes the location of the values in the array\n\nAnswer: b"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: Prefix expressions are evaluated by scanning the expression from right to left using a stack for operand management.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: While evaluating a prefix expression, the string is read from?\na) left to right\nb) right to left\nc) center to right\nd) center to left to right\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In tree data structures, a node with child nodes is referred to as the parent node. Its immediate descendants are called children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the name of the node having child nodes?\na) Brother\nb) Sister\nc) Mother\nd) Parent\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: When an algorithm has two independent time complexities, the overall complexity is determined by the slower-growing function, i.e., the maximum of the two.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An algorithm is made up of two independent time complexities f(n) and g(n). Then the complexity of the algorithm is in the order of:\nOptions: ['A\\nf(n) × g(n)', 'B\\nMax(f(n), g(n))', 'C\\nMin(f(n), g(n))', 'D\\nf(n) + g(n)']\nAnswer: B\nMax(f(n), g(n))"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In tree structures such as Leftist trees or AVL trees, left children often have levels less than their parents to ensure balance or heap properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What should be the condition for the level of a left node?\na) It should be less than or equal to that of its parent\nb) It should be greater than that of its parent\nc) It should be strictly less than that of its parent\nd) The level should be equal to one\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: To efficiently count scores above a threshold, only relevant values are stored. For scores above 50, only 51–100 need to be tracked.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A program P reads in 500 integers in the range [0..100] representing the scores of 500 students. It then prints the frequency of each score above 50. What would be the best way for P to store the frequencies?\nOptions: ['A\\nAn array of 50 numbers', 'B\\nAn array of 100 numbers', 'C\\nAn array of 500 numbers', 'D\\nA dynamically allocated array of 550 numbers']\nAnswer: A\nAn array of 50 numbers"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In dynamic arrays, the physical size is the size of the underlying memory allocation (often larger than the logical size to accommodate growth).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is meant by physical size in a dynamic array?\na) The size allocated to elements\nb) The size extended to add new elements\nc) The size of the underlying array at the back-end\nd) The size visible to users\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The probability of selecting a tree uniformly from a set of Catalan-number-generated trees is 1/Catalan(n), where Catalan(n) is the total number of such trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the probability of selecting a tree uniformly at random?\na) Equal to Catalan Number\nb) Less than Catalan Number\nc) Greater than Catalan Number\nd) Reciprocal of Catalan Number\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The maximum height of an AVL tree with n nodes is based on the balance factor constraint. For 7 nodes, the maximum height is 3.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum height of any AVL-tree with 7 nodes? Assume that the height of a tree with a single node is 0.\nOptions: ['A\\n2', 'B\\n3', 'C\\n4', 'D\\n5']\nAnswer: B\n3"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Counting the number of elements in a linked list involves iterating through the list until the end and incrementing a counter at each node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following pieces of code has the functionality of counting the number of elements in the list?\na) [code that increments `size` inside a while loop with cur != null]\nb) [code that swaps the order of size++ and pointer movement]\nc) [code with no return value]\nd) [code that skips every second node]\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a full binary tree, each internal node has exactly two children. The total number of nodes N is 2 * I + 1, where I is the number of internal nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a full binary tree if number of internal nodes is I, then number of nodes N are?\na) N = 2*I\nb) N = I + 1\nc) N = I – 1\nd) N = 2*I + 1\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In splay trees and other dynamic tree structures, a 'cut' operation is used to break a preferred path or subtree at a specific node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which operation is used to break a preferred path into two sets of parts at a particular node?\na) Differentiate\nb) Cut\nc) Integrate\nd) Join\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: Not all undirected multigraphs contain Eulerian cycles. The necessary condition is that all vertices have even degree and the graph is connected.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: All undirected Multigraphs contain Eulerian cycles.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Prefix expressions are evaluated by parsing from right to left, applying operators to operands in a stack-based or recursive manner.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the solution to the given prefix notation?\na) 1\nb) 4\nc) 2\nd) 8\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: The code attempts to reverse a string but uses an undeclared variable `n` for loop control. Declaring and initializing `n` as the string's length is essential.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is missing in the given code?\n#include <bits/stdc++.h>\nusing namespace std;\nvoid reverseStr(string& str) {\n    for (int i = 0; i < n / 2; i++)\n        swap(str[i], str[n - i - 1]);\n}\nint main() {\n    string str = \"geeksforgeeks\";\n    reverseStr(str);\n    cout << str;\n    return 0;\n}\nOptions: ['A\\nswap function is not defined', 'B\\nstring is not defined here.', 'C\\nVariable n is not declared anywhere.', 'D\\nNone']\nAnswer: C\nVariable n is not declared anywhere."
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A 3-ary max heap allows three children per node and is represented using an array. The parent must be greater than all its children to maintain the max-heap property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which one of the following is a valid sequence of elements in an array representing a 3-ary max heap?\nOptions: ['A\\n1, 3, 5, 6, 8, 9', 'B\\n9, 6, 3, 1, 8, 5', 'C\\n9, 3, 6, 8, 5, 1', 'D\\n9, 5, 6, 8, 3, 1']\nAnswer: D\n9, 5, 6, 8, 3, 1"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Splay trees offer amortized efficiency for frequently accessed elements. They are useful in applications where a small subset of data is accessed repeatedly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When we have red-black trees and AVL trees that can perform most operations in logarithmic time, what is the need for splay trees?\na) no there is no special usage\nb) In real time it is estimated that 80% access is only to 20% data, hence most used ones must be easily available\nc) red-black and AVL are not up to mark\nd) they are just another type of self-balancing binary search trees\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: This code generates all subarrays of an array. Each subarray is printed by iterating over a range starting from index i to j.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will the following code do?\nvoid fun(int arr[], int n) {\n  for (int i = 0; i < n; i++) {\n    for (int j = i; j < n; j++) {\n      for (int k = i; k <= j; k++)\n        cout << arr[k] << \" \";\n      cout << endl;\n    }\n  }\n}\nOptions: ['A\\nPrints the subsequence of the article.', 'B\\nPrints the elements of the array', 'C\\nPrints the subarray of the element.', 'D\\nNone']\nAnswer: C\nPrints the subarray of the element."
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: In a linear queue implemented using an array, the space complexity is O(n) since memory for n elements is preallocated.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the space complexity of a linear queue having n elements?\na) O(n)\nb) O(nlogn)\nc) O(logn)\nd) O(1)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: A connected acyclic graph with v vertices and e edges must have e = v - 1. This defines the properties of a tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For a given graph G having v vertices and e edges which is connected and has no cycles, which of the following statements is true?\na) v = e\nb) v = e + 1\nc) v + 1 = e\nd) v = e - 1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: This appears to test understanding of asymptotic complexities for certain stack operations. O(n log k) is often the optimal for multi-way merges or hybrid structures.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the complexity of the given stack-based operation?\nOptions: ['A\\nO(n logk)', 'B\\nO(nk)', 'C\\nO(n²)', 'D\\nO(k²)']\nAnswer: A\nO(n logk)"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: The function swaps adjacent elements in a singly linked list by manipulating the values, not pointers. It alters the data, not structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the contents of the list after the function completes execution (on list 1 to 7)?\nOptions: ['A\\n1,2,3,4,5,6,7', 'B\\n2,1,4,3,6,5,7', 'C\\n1,3,2,5,4,7,6', 'D\\n2,3,4,5,6,7,1']\nAnswer: B\n2,1,4,3,6,5,7"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: In a circular queue of size n holding up to n–1 elements, the full condition is (REAR+1) mod n == FRONT; the empty condition is REAR == FRONT.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose a circular queue of capacity (n – 1) elements is implemented with an array of n elements. What are the conditions for full and empty states?\nOptions: ['A\\nFull: (REAR+1) mod n == FRONT, empty: REAR == FRONT', 'B\\nFull: (REAR+1) mod n == FRONT, empty: (FRONT+1) mod n == REAR', 'C\\nFull: REAR == FRONT, empty: (REAR+1) mod n == FRONT', 'D\\nFull: (FRONT+1) mod n == REAR, empty: REAR == FRONT']\nAnswer: A\nFull: (REAR+1) mod n == FRONT, empty: REAR == FRONT"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: This code removes the second-to-last node in a doubly linked list and returns its value. It updates both previous and next links.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the following piece of code?\npublic int function() {\n Node temp = tail.getPrev();\n tail.setPrev(temp.getPrev());\n temp.getPrev().setNext(tail);\n size--;\n return temp.getItem();\n}\na) Return the element at the tail of the list but do not remove it\nb) Return the element at the tail of the list and remove it from the list\nc) Return the last but one element from the list but do not remove it\nd) Return the last but one element at the tail of the list and remove it from the list\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Reverse Polish Notation (RPN) is postfix form where the operator comes after its operands. The valid format is operand operand operator.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a valid reverse Polish expression?\na) a op b\nb) op a b\nc) a b op\nd) both op a b and a b op\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In a BST, traversing right → root → left produces elements in descending order due to the inherent structure of BSTs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A BST is traversed in the following order recursively: Right, root, left. The output sequence will be in:\nOptions: ['A\\nAscending order', 'B\\nDescending order', 'C\\nBitomic sequence', 'D\\nNo specific order']\nAnswer: B\nDescending order"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Infix expressions place the operator between operands. Recognizing correct infix notation involves checking for balanced operators and operands.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Identify the infix expression from the list of options given below:\na) a/b+(c-d)\nb) abc*+d+ab+cd+*ce-f-\nc) ab-c-\nd) +ab\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: If each node in a binary tree has an odd number of descendants (including itself), it implies that no node can have exactly one child.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a binary tree with n nodes, every node has an odd number of descendants. Every node is considered to be its own descendant. What is the number of nodes in the tree that have exactly one child?\nOptions: ['A\\n0', 'B\\n1', 'C\\n(n-1)/2', 'D\\nn-1']\nAnswer: A\n0"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Ternary heaps (3-ary heaps) have more children per node compared to binary heaps, leading to fewer levels and improved cache behavior.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Do ternary heaps have better memory cache behavior than binary heaps?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: The function checks whether a node exists in a circular linked list. If the list is empty, it prints “fail”.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the given code?\nvoid function(int data) {\n  int flag = 0;\n  if (head != null) {\n    Node temp = head.getNext();\n    while ((temp != head) && (!(temp.getItem() == data))) {\n      temp = temp.getNext();\n      flag = 1;\n      break;\n    }\n  }\n  if (flag)\n    System.out.println(\"success\");\n  else\n    System.out.println(\"fail\");\n}\nOptions: ['A\\nPrint success if a particular element is not found', 'B\\nPrint fail if a particular element is not found', 'C\\nPrint success if a particular element is equal to 1', 'D\\nPrint fail if the list is empty']\nAnswer: D\nPrint fail if the list is empty"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The code reverses an array using two-pointer swapping from both ends. The output reflects a full reverse.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following code?\n[...C++ code reversing array...]\nOptions: ['A\\n5 1 4 3', 'B\\n3 5 1 4', 'C\\n5 3 4 1', 'D\\nerror']\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Only valid BST sequences that maintain constraints of the node range (37 to 573) and BST properties should be selected.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A Binary Search Tree (BST) stores values in the range 37 to 573. Consider the following sequence of keys:\nOptions: ['A\\nII and III only', 'B\\nI and III only', 'C\\nIII and IV only', 'D\\nIII only']\nAnswer: D\nIII only"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In the 'count' heuristic, frequently accessed nodes move forward in a list as their access count increases, improving future access time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In _____________ method, whenever a node is accessed, it might move to the head of the list if its number of accesses becomes greater than the records preceding it.\na) least recently used\nb) count\nc) transpose\nd) exchange\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Range query structures like bins group values by intervals for quick access in searching and filtering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Bin is an example of a range query data structure.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The structure of a BST depends on the insertion order. Different orders yield different shapes, even with the same data set.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Select the incorrect statement. Binary search trees (regardless of the order in which the values are inserted into the tree):\nOptions: ['A\\nAlways have multiple links per node.', 'B\\nCan be sorted efficiently.', 'C\\nAlways have the same shape for a particular set of data.', 'D\\nAre nonlinear data structures.']\nAnswer: C\nAlways have the same shape for a particular set of data."
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: A deque (double-ended queue) supports insertion/deletion at both ends and can be implemented using a doubly linked list or a circular array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure is used to implement deque?\nOptions: ['A\\nStack', 'B\\nDoubly linked list', 'C\\nCircular array', 'D\\nBoth B and C']\nAnswer: D\nBoth B and C"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The total number of nodes in a binary tree with λ levels is 2^λ – 1. Any statement violating this must be incorrect.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is incorrect with respect to binary trees?\na) Let T be a binary tree. For every k ≥ 0, there are no more than 2^k nodes in level k\nb) Let T be a binary tree with λ levels. Then T has no more than 2^λ – 1 nodes\nc) Let T be a binary tree with N nodes. Then the number of levels is at least ceil(log(N + 1))\nd) Let T be a binary tree with N nodes. Then the number of levels is at least floor(log(N + 1))\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Sparse matrices are those in which most elements are zero. They are the opposite of dense matrices, which are mostly non-zero.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is Sparse Matrix also known as Dense Matrix?\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Sorted arrays are efficient in scenarios involving ordered data, such as in commercial computing or scheduling. Hash tables do not rely on order and are thus not a typical application.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not an application of sorted array?\na) Commercial computing\nb) Priority Scheduling\nc) Discrete Mathematics\nd) Hash Tables\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: A circular, doubly linked list node contains two pointers (prev and next). For 5 nodes, total pointers = 5 × 2 = 10.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many pointers are contained as data members in the nodes of a circular, doubly linked list of integers with five nodes?\nOptions: ['A\\n5', 'B\\n8', 'C\\n10', 'D\\n15']\nAnswer: C\n10"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In chaining, the number of link traversals in a successful search is approximately 1 + (λ/2), where λ is the load factor.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In hash tables, how many traversals of links does a successful search require?\na) 1 + λ\nb) 1 + λ²\nc) 1 + (λ/2)\nd) λ³\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a binary tree, nodes with degree 1, 2, or 3 correspond to the number of their neighbors. For each configuration, relationships can be derived based on degree constraints.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A binary tree with n > 1 nodes has n1, n2, and n3 nodes of degree one, two, and three respectively. The degree of a node is defined as the number of its neighbors.\nn3 can be expressed as:\nOptions: ['A\\nn1 + n2 - 1', 'B\\nn1 - 2', 'C\\n((n1 + n2)/2)', 'D\\nn2 - 1']\nAnswer: B\nn1 - 2"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In open addressing, if all slots are probed and none is empty, the table is considered full. Hence, it can become full despite available slots due to probing strategy.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In open addressing, the hash table can never become full.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: In an expression tree construction algorithm, when an operand is encountered, a new node is created and pushed to the stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In an expression tree algorithm, what happens when an operand is encountered?\na) create one node pointing to a stack\nb) pop the nodes from the stack\nc) clear stack\nd) merge all the nodes\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The Chernoff bound provides exponential bounds on tail distributions. For sampling without replacement, the expected error decreases as O(1/√k).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the expected error by the estimator Chernoff bound on the samples performed without replacement?\na) O(log k!)\nb) O(k!)\nc) O(k²)\nd) O(1/√k)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The lowest-level element in a BST is the one farthest from the root. This depends on the insertion order and tree balancing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: While inserting the elements 71, 65, 84, 69, 67, 83 in an empty binary search tree (BST) in the sequence shown, the element in the lowest level is:\nOptions: ['A\\n65', 'B\\n67', 'C\\n69', 'D\\n83']\nAnswer: B\n67"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Matrix multiplication involves nested loops for multiplying rows of the first matrix by columns of the second. Valid code performs this with proper indexing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Select the code snippet which performs matrix multiplication (a and b are the two given matrices, resultant matrix is c):\na) [correct nested-loop code for c[i][j] += a[i][k] * b[k][j]]\nb) [code that adds matrix values instead]\nc) [code that transposes the matrix]\nd) [code that just prints one matrix]\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In a skew heap, all three major operations—merge, insert, delete—are based on merge operations, and each takes amortized O(log N) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the time per operation of merging, insertion, and deletion operations in a skew heap?\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(N²)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: A single stack is sufficient to evaluate a postfix expression using a simple algorithm that processes operators and operands in one pass.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: To evaluate an expression without any embedded function calls:\nOptions: ['A\\nAs many stacks as the height of the expression tree are needed', 'B\\nOne stack is enough', 'C\\nTwo stacks are needed', 'D\\nA Turing machine is needed in the general case']\nAnswer: B\nOne stack is enough"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The size of an array is calculated by multiplying the number of elements with the size of each element. If int is 4 bytes, int arr[15] occupies 60 bytes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Assuming int is of 4 bytes, what is the size of int arr[15]?\na) 15\nb) 19\nc) 11\nd) 60\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Job scheduling is not inherently stack-based. Stacks are used in recursion, expression evaluation, and reversing operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not an inherent application of stack?\nOptions: ['A\\nImplementation of recursion', 'B\\nEvaluation of a postfix expression', 'C\\nJob scheduling', 'D\\nReverse a string']\nAnswer: C\nJob scheduling"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: An Abstract Data Type (ADT) defines a data model and operations that can be performed on it, without specifying implementation details.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A mathematical model with a collection of operations defined on that model is called:\nOptions: ['A\\nData Structure', 'B\\nAbstract Data Type', 'C\\nPrimitive Data Type', 'D\\nAlgorithm']\nAnswer: B\nAbstract Data Type"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Given traversal sequences, you can reconstruct the original tree. Preorder and inorder uniquely identify a tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The following three are known to be the preorder, inorder, and postorder sequences of a binary tree. But it is not known which is which.\nMBCAFHPYK\nKAMCBYPFH\nMABCKYFPH\nPick the true statement from the following:\nOptions: ['A\\nI and II are preorder and inorder sequences, respectively', 'B\\nI and III are preorder and postorder sequences, respectively', 'C\\nII is the inorder sequence, but nothing more can be said about the other two sequences', 'D\\nII and III are the preorder and inorder sequences, respectively']\nAnswer: D\nII and III are the preorder and inorder sequences, respectively"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Inserting a node at the beginning of a linked list requires adjusting the head pointer to the new node, and linking it to the previous head.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you insert an element at the beginning of the list?\na)\npublic void insertBegin(Node node) {\n  node.setNext(head);\n  head = node;\n  size++;\n}\n... (other options truncated for brevity)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Unrolled linked lists optimize space by grouping multiple elements in a node, reducing the pointer overhead compared to traditional singly linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Unrolled linked-list requires more storage space for pointers compared to a singly linked list.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Reversing a string using a stack involves pushing each character and then popping to retrieve them in reverse order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Operations required for reversing a word or a string using stack are push() and pop().\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In any tree, the root node is defined to be at depth 0. Depth increases by one at each level of the tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the depth of the root node of the ternary tree?\na) 2\nb) 1\nc) 0\nd) 3\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In the process of building a heap with n elements, a maximum of n nodes must be arranged using heapify operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given a heap of n nodes. The maximum number of trees for building the heap is:\na) n\nb) n–1\nc) n/2\nd) logn\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In open addressing, deletion is typically handled lazily by marking entries as deleted rather than physically removing them.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What kind of deletion is implemented by hashing using open addressing?\na) active deletion\nb) standard deletion\nc) lazy deletion\nd) no deletion\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: Priority queues are used in tasks like Huffman coding and interrupt handling. Undo operations are not typically modeled with priority queues.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not an application of priority queue?\na) Huffman codes\nb) Interrupt handling in operating system\nc) Undo operation in text editors\nd) Bayesian spam filter\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Infix expressions are valid even with parentheses. A proper evaluation algorithm handles them without error.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The system throws an error if parentheses are encountered in an infix expression evaluation algorithm.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: The LIFO (Last In First Out) principle is implemented using a stack. While linked lists allow flexible data management, the LIFO principle specifically defines stack behavior.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure is based on the Last In First Out (LIFO) principle?\na) Tree\nb) Linked List\nc) Stack\nd) Queue\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: A splay operation in splay trees moves a recently accessed node to the root using tree rotations, improving future access time for frequently used elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a splay operation?\na) moving parent node to down of child\nb) moving a node to root\nc) moving root to leaf\nd) removing leaf node\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: The Tower of Hanoi problem is optimally solved using a stack, as it naturally fits the recursive movement and backtracking needed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The optimal data structure used to solve Tower of Hanoi is _________\na) Tree\nb) Heap\nc) Priority queue\nd) Stack\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In uniform hashing, the expected number of keys per slot is the load factor, n/m. Dividing the total keys by the total number of slots provides the expected value.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose we are given n keys, m hash table slots, and two simple uniform hash functions h1 and h2. Further, suppose our hashing scheme uses h1 for odd keys and h2 for even keys. What is the expected number of keys in a slot?\nOptions: ['A\\n2m/n', 'B\\nm/n', 'C\\nn/m', 'D\\nm/2n']\nAnswer: B\nm/n"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Null path length (NPL) is a measure used in leftist heaps and other tree structures. If it's not updated properly, its value remains at the default (usually 0).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What happens if the null path length is not updated?\na) error occurs\nb) all null path lengths will be 0\nc) all null path lengths will be -1\nd) all null path lengths will be 1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: A memory-efficient doubly linked list reduces space by storing XOR of previous and next pointers in a single field, minimizing pointer storage.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a memory efficient double linked list?\na) Each node has only one pointer to traverse the list back and forth\nb) The list has breakpoints for faster traversal\nc) An auxiliary singly linked list acts as a helper list to traverse through the doubly linked list\nd) A doubly linked list that uses bitwise AND operator for storing addresses\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A fully connected undirected graph with all non-diagonal elements as 1 forms a complete graph. The number of MSTs depends on how edges are selected, all with equal weight.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An undirected graph G has n nodes. Its adjacency matrix is given by an n × n square matrix with (i) diagonal elements as 0s and (ii) non-diagonal elements as 1s. Which one of the following is TRUE?\nOptions: ['A\\nGraph G has no minimum spanning tree (MST)', 'B\\nGraph G has a unique MST of cost n-1', 'C\\nGraph G has multiple distinct MSTs, each of cost n-1', 'D\\nGraph G has multiple spanning trees of different costs']\nAnswer: C\nGraph G has multiple distinct MSTs, each of cost n-1"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Prefix expressions are evaluated right to left. The expression result depends on operand values and operator order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the solution to the given prefix notation?\na) 6\nb) -6\nc) 3\nd) -3\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: A path cluster typically refers to a connected set of nodes in a linear arrangement. The number of edges is one less than the number of nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many edges are present in a path cluster?\na) 2\nb) 3\nc) 6\nd) 1\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a leftist heap, the right path contains the shortest path to a leaf. All operations (merge, insert, delete) are performed via this right path.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a leftist heap, all the operations should be performed on?\na) left path\nb) centre path\nc) right path\nd) root\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: By the triangle inequality, if shortest paths s→u=53 and s→v=65, then u→v must be ≥12 to maintain valid path lengths.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a weighted undirected graph with positive edge weights. Let uv be an edge. The shortest path from source s to u is 53, and to v is 65. Which one of the following statements is always true?\nOptions: ['A\\nweight(u, v) < 12', 'B\\nweight(u, v) ≤ 12', 'C\\nweight(u, v) > 12', 'D\\nweight(u, v) ≥ 12']\nAnswer: D\nweight(u, v) ≥ 12"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Deleting the last element in a singly linked list requires maintaining a reference to the second-last node so its next can be set to null after deletion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following performs deletion of the last element in the list? Given below is the Node class.\n\nclass Node\n{\n protected Node next;\n protected Object ele;\n Node(Object e,Node n)\n {\n  ele = e;\n  next = n;\n }\n public void setNext(Node n)\n {\n  next = n;\n }\n public void setEle(Object e)\n {\n  ele = e;\n }\n public Node getNext()\n {\n  return next;\n }\n public Object getEle()\n {\n  return ele;\n }\n}\nclass SLL \n{\n Node head;\n int size;\n SLL()\n {\n  size = 0;\n }\n}\npublic Node removeLast()\n{\n if(size == 0)\n return null;\n Node cur;\n Node temp;\n cur = head;\n while(cur.getNext() != null)\n {\n   temp = cur;\n   cur = cur.getNext();\n        }\n temp.setNext(null);\n size--;\n return cur;\n}\npublic void removeLast()\n{\n if(size == 0)\n return null;\n Node cur;\n Node temp;\n cur = head;\n while(cur != null)\n {\n  temp = cur;\n  cur = cur.getNext();\n        }\n temp.setNext(null);\n return cur;\n}\npublic void removeLast()\n{\n if(size == 0)\n     return null;\n Node cur;\n Node temp;\n cur = head;\n while(cur != null)\n {\n  cur = cur.getNext();\n  temp = cur;\n  }\n temp.setNext(null);\n return cur;\n}\npublic void removeLast()\n{\n if(size == 0)\n  return null;\n Node cur;\n Node temp;\n cur = head;\n while(cur.getNext() != null)\n {\n  cur = cur.getNext();\n  temp = cur;\n }\n temp.setNext(null);\n return cur;\n}\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: A deque (double-ended queue) supports insertions and deletions at both ends, but not in the middle. It is a generalization of stacks and queues.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A data structure in which elements can be inserted or deleted at/from both ends but not in the middle is?\na) Priority queue\nb) Dequeue\nc) Circular queue\nd) Queue\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Bin data structures are used for organizing data spatially, and they are commonly applied in range or region query problems (e.g., graphics, GIS).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the use of the bin data structure?\na) to have efficient traversal\nb) to have efficient region query\nc) to have efficient deletion\nd) to have efficient insertion\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Direct addressing is suitable when the universe of keys is small, allowing direct access using an array index with no hashing needed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When is it appropriate to use direct addressing?\na) When the array is comparatively large\nb) When the universe U of keys is reasonably small\nc) When the universe U of keys is reasonably large\nd) When the array is comparatively small\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: A stack with PUSH, POP, and REVERSE can simulate queue operations. ENQUEUE may require multiple instructions, while DEQUEUE can often be done with one.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose a stack implementation supports an instruction REVERSE, which reverses the order of elements on the stack, in addition to PUSH and POP. Which one of the following statements is TRUE with respect to this modified stack?\nOptions: ['A\\nA queue cannot be implemented using this stack.', 'B\\nA queue can be implemented where ENQUEUE takes a single instruction and DEQUEUE takes a sequence of two instructions.', 'C\\nA queue can be implemented where ENQUEUE takes a sequence of three instructions and DEQUEUE takes a single instruction.', 'D\\nA queue can be implemented where both ENQUEUE and DEQUEUE take a single instruction each.']\nAnswer: C"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Linked lists do not require contiguous memory and dynamically allocate space. They improve both space utilization and performance for certain insert/delete operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Linked list data structure offers considerable saving in _____________\na) Computational Time\nb) Space Utilization\nc) Space Utilization and Computational Time\nd) Speed Utilization\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A full binary tree is a special type of binary tree in which every node has either zero or two children. This structure ensures balanced depth and predictable traversal patterns.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a full binary tree?\nChoices: ['A\\nEach node has exactly zero or two children', 'B\\nEach node has exactly two children', 'C\\nAll the leaves are at the same level', 'D\\nEach node has exactly one or two children']\nAnswer: A\nEach node has exactly zero or two children"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Hash tables commonly use arrays for storage, where a hash function maps keys to specific array indices. Collisions are often handled using techniques like chaining or open addressing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What data organization method is used in hash tables?\na) Stack\nb) Array\nc) Linked list\nd) Queue\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: A circular, singly-linked list connects each node to the next, and the last node links back to the first node, forming a loop. This structure is used in scenarios like round-robin scheduling.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What kind of linked list begins with a pointer to the first node, and each node contains a pointer to the next node, and the pointer in the last node points back to the first node?\nChoices: ['A\\nCircular, singly-linked list.', 'B\\nCircular, doubly-linked list.', 'C\\nSingly-linked list.', 'D\\nDoubly-linked list.']\nAnswer: A\nCircular, singly-linked list."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A suffix tree is a compressed trie of all the suffixes of a given text. Efficient algorithms allow for its construction in linear time and space relative to the length of the input string, often O(M), where M is the string length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How much space does construction of suffix tree takes?\na) O (log M)\nb) Exponential to Length of Tree\nc) O (M!)\nd) Linear to Length of Tree\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Postfix expressions (Reverse Polish Notation) are evaluated using a stack. Operands are pushed onto the stack, and operators pop the required operands to apply the operation. This method avoids the need for parentheses.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The result of evaluating the postfix expression 5, 4, 6, +, *, 4, 9, 3, /, +, * is?\na) 600\nb) 350\nc) 650\nd) 588\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In an adjacency list representation of an undirected graph, each edge is stored twice—once in the list for each of its endpoints. The space complexity is proportional to the number of edges E.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Space complexity for storing only the edges in an adjacency list of an undirected graph is __________\na) O(V)\nb) O(E*E)\nc) O(E)\nd) O(E+V)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: A queue can be implemented using two stacks to reverse the order of elements for dequeuing. One stack is used for enqueuing and the other for dequeuing. This technique maintains the FIFO property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An implementation of a queue Q, using two stacks S1 and S2, is given below:\nChoices: ['A\\nn+m <= x < 2n and 2m <= y <= n+m', 'B\\nn+m <= x < 2n and 2m<= y <= 2n', 'C\\n2m <= x < 2n and 2m <= y <= n+m', 'D\\n2m <= x <2n and 2m <= y <= 2n']\nAnswer: A\nn+m <= x < 2n and 2m <= y <= n+m"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In post-order traversal of a binary tree, the correct sequence is to first traverse the left subtree, then the right subtree, and finally visit the root node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The steps for finding post-order traversal are traverse the right subtree, traverse the left subtree or visit the current node.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a complete binary tree of depth d, the number of leaf nodes is given by 2^d, as all levels are completely filled.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of leaf nodes in a complete binary tree of depth d is ………..\nChoices: ['A\\n2d', 'B\\n2d–1+1', 'C\\n2d+1+1', 'D\\n2d+1']\nAnswer: A\n2d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Self-balancing binary search trees maintain logarithmic height using rotations. Common examples include AVL Trees, Red-Black Trees, and Splay Trees. A 2-3-4 Tree is a multiway search tree and not a binary tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not the self balancing binary search tree?\na) AVL Tree\nb) 2-3-4 Tree\nc) Red – Black Tree\nd) Splay Tree\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In Java, multidimensional arrays are declared using multiple pairs of square brackets. For example, int[][] arr is a 2D array declaration.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the correct way to declare a multidimensional array in Java?\na) int[] arr;\nb) int arr[[]];\nc) int[][]arr;\nd) int[[]] arr;\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Splay trees are a type of self-adjusting binary search tree. They provide amortized O(log n) time complexity for basic operations by splaying recently accessed nodes to the root.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is it true that splay trees have O(logn) amortized complexity?\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Reversing a word in most programming languages involves iterating from the end of the string to the beginning, storing characters in reverse order or using built-in methods.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Select the appropriate code which reverses a word.\na)\n\nd)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: For post-order traversal to produce a specific sequence, the structure of the tree must align with the traversal rules (left-right-root). With 3 labeled nodes, there are a limited number of binary trees that satisfy a given post-order sequence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many binary trees with 3 nodes which when traversed in post order gives the sequence A, B, C is?\nChoices: ['A\\n3 \\n (A) 3', 'B\\n4', 'C\\n5', 'D\\n6']\nAnswer: C\n5"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Arrays are zero-indexed data structures in most programming languages. This means the first element is accessed at index 0, which is a common source of off-by-one errors.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In general, the index of the first element in an array is __________\na) 0\nb) -1\nc) 2\nd) 1\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a d-ary heap, each node can have up to d children. Despite this generalization from binary heaps, parent and child indices can still be calculated using multiplication and division.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Multiplication and division to find children and parents cannot be implemented in a d-heap.\na) true\nb) false\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In a d-heap, inserting an element may involve bubbling it up the tree to restore the heap property. The time complexity of insertion depends on the logarithm base d of the number of elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the run time efficiency of an insertion algorithm in d-heap?\na) O(N)\nb) O(log N)\nc) O(logd N)\nd) O(Nd)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In weighted graphs, finding the minimum weight path with constraints such as maximum edge count requires algorithms like modified BFS or Dijkstra's algorithm with limits.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In the graph given in above question, what is the minimum possible weight of a path P from vertex 1 to vertex 2 in this graph such that P contains at most 3 edges?\nChoices: ['A\\n7', 'B\\n8', 'C\\n9', 'D\\n10']\nAnswer: B\n8"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: While depth-first traversal of graphs typically uses stacks, breadth-first traversal relies on queues to process nodes level by level.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What data structure is used for breadth first traversal of a graph?\nChoices: ['A\\nQueue', 'B\\nStack', 'C\\nList', 'D\\nNone of these']\nAnswer: A\nQueue"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: Reversing a queue can be done by transferring its elements to a stack and then back to the queue. This uses the LIFO property of stacks to reverse the order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Following is pseudo code of a function that takes a Queue as an argument, and uses a stack S to do processing.\nvoid fun(Queue *Q) {\n    Stack S;\n    while (!isEmpty(Q)) {\n        push(&S, deQueue(Q));\n    }\n    while (!isEmpty(&S)) {\n        enQueue(Q, pop(&S));\n    }\n}\nChoices: ['A\\nRemoves the last from Q', 'B\\nKeeps the Q same as it was before the call', 'C\\nMakes Q empty', 'D\\nReverses the Q']\nAnswer: D\nReverses the Q"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a graph with distinct edge weights, a unique minimum spanning tree (MST) exists. An edge that is the heaviest in a cycle will not be part of the MST.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: G = (V, E) is an undirected simple graph in which each edge has a distinct weight, and e is a particular edge of G. Which of the following statements about the minimum spanning trees (MSTs) of G is/are TRUE?\nChoices: ['A\\nI only', 'B\\nII only', 'C\\nboth I and II', 'D\\nneither I nor II']\nAnswer: B\nII only"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: B-trees and their variants like B+-trees are optimized for systems that read and write large blocks of data. B+-trees are commonly used in databases and file systems.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the most widely used external memory data structure?\na) B-tree\nb) Red-black tree\nc) AVL tree\nd) Both AVL tree and Red-black tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: Binary Decision Diagrams (BDDs) are used in graph-based representations of Boolean functions. Some logical operations like tautology checking may not be efficiently solvable in polynomial time using BDDs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following logical operation can’t be implemented by polynomial time graph manipulation algorithms using Binary Decision Diagrams?\na) Conjunction\nb) Disjunction\nc) Negation\nd) Tautology Checking\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Linear probing is a collision resolution technique in open addressing where, if a key's hashed location is occupied, subsequent slots are checked sequentially until an empty one is found.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a 13 element hash table for which f(key)=key mod 13 is used with integer keys. Assuming linear probing is used for collision resolution, at which location would the key 103 be inserted, if the keys 661, 182, 24 and 103 are inserted in that order?\nChoices: ['A\\n0', 'B\\n1', 'C\\n11', 'D\\n12']\nAnswer: B\n1"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: When limited to a single array and basic stack operations, implementing queue operations like enqueue is not feasible without additional memory or logic for handling order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given only a single array of size 10 and no other memory is available. Which of the following operation is not feasible to implement (Given only push and pop operation)?\na) Push\nb) Pop\nc) Enqueue\nd) Returntop\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A B+-tree of order d and height h can store a maximum of d^h keys. This property is useful in indexing for databases and file systems, where large amounts of data must be accessed efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum number of keys that a B+ -tree of order 3 and of height 3 have?\na) 3\nb) 80\nc) 27\nd) 26\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In graph theory, finding the shortest path from one node to another in a directed graph can involve various path constraints. When edges are defined with specific functions like j = i+1 or j = 3i, techniques such as BFS help compute minimum edge counts.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let G be a directed graph whose vertex set is the set of numbers from 1 to 100. There is an edge from a vertex i to a vertex j if either j = i + 1 or j = 3i. The minimum number of edges in a path in G from vertex 1 to vertex 100 is\nChoices: ['A\\n4', 'B\\n7', 'C\\n23', 'D\\n99']\nAnswer: B\n7"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Stacks follow the Last-In-First-Out (LIFO) principle. They are widely used in recursion, where function calls are pushed onto the call stack and popped off upon return.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Stack is used for ………..\nChoices: ['A\\nCPU Resource Allocation', 'B\\nBreadth First Traversal', 'C\\nRecursion', 'D\\nNone of the above']\nAnswer: C\nRecursion"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a binary tree, the balance factor of a node is calculated as the height of its left subtree minus the height of its right subtree. This is important in AVL trees to maintain balance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The balance factor of a node in a binary tree is defined as _____\na) addition of heights of left and right subtrees\nb) height of right subtree minus height of left subtree\nc) height of left subtree minus height of right subtree\nd) height of right subtree minus one\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A leaf node is a node with no children. In any tree, including ternary trees, a leaf node is also considered a child of its parent node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Can leaf node be called child node in a ternary tree?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: Pairing heaps are simple and practical self-adjusting heaps that perform well in applications with frequent decrease-key operations. They often outperform binary and d-heaps in practice.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following methods is the best choice for complex applications?\na) binary heap\nb) d-heap\nc) treap\nd) pairing heap\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Time complexity expresses how the runtime of an algorithm scales with input size N. Among O(N), O(N^0.5), and O(log N), the linear O(N) grows the fastest and is slowest for large N.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Time complexities of three algorithms are given. Which should execute the slowest for large values of N?\nChoices: ['A\\nO(N1/2)', 'B\\nO(N)', 'C\\nO(log N)', 'D\\nNone of these']\nAnswer: B\nO(N)"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: Path compression is a technique used in the union-find data structure to flatten the tree structure, improving efficiency. It inspired self-adjusting strategies in data structures like skew heaps and splay trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: ___________ is one of the earliest forms of a self-adjustment strategy used in splay trees, skew heaps.\na) Union by rank\nb) Equivalence function\nc) Dynamic function\nd) Path compression\n\nAnswer: d"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: A rope is a binary tree used to store and manipulate long strings. It supports efficient operations like splitting and concatenation at arbitrary positions in the string.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is it possible to perform a split operation on a string in the rope if the split point is in the middle of the string?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Linked lists consist of nodes that store data and references to the next (and possibly previous) node. Understanding pointer manipulation and various structural properties is key to analyzing their behavior.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following statements:\nChoices: ['A\\n(ii) is true', 'B\\n(i) and (ii) are true', 'C\\n(iii) is true', 'D\\n(ii) and (iv) are true']\nAnswer: C\n(iii) is true"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A sorted array can be in numeric or alphabetical order. The array's elements may also reside in contiguous memory blocks, but sorting refers specifically to element order, not memory layout.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a sorted array?\na) Arrays sorted in numerical order\nb) Arrays sorted in alphabetical order\nc) Elements of the array are placed at equally spaced addresses in the memory\nd) All of the mentioned\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Prefix expressions (Polish notation) can be converted to postfix (Reverse Polish notation) using a stack-based approach or by recursively parsing and rearranging the operators and operands.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the postfix form of the following prefix *+ab–cd?\nChoices: ['A\\nab+cd–*', 'B\\nabc+*', 'C\\nab+*cd', 'D\\nab+*cd']\nAnswer: A\nab+cd–*"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: A treap is a data structure that combines binary search tree properties with heap properties. Each node has a priority, and this priority helps maintain a randomized balance, making the structure simple yet efficient.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the reason behind the simplicity of a treap?\na) Each node has data and a pointer\nb) Each node is colored accordingly\nc) It is a binary search tree following heap principles\nd) Each node has a fixed priority field\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In linked lists representing sets, operations like union and intersection require element comparisons, which take longer than simple operations like membership checks or counting elements (cardinality).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose each set is represented as a linked list with elements in arbitrary order. Which of the operations among union, intersection, membership, cardinality will be the slowest? (GATE CS 2004)\nChoices: ['A\\nunion ', 'B\\n membership', 'C\\ncardinality', 'D\\n union, intersection']\nAnswer: D\n union, intersection"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In C++, arrays can be initialized using brace-enclosed lists. Outputting the elements using `cout` prints their values in order. This basic syntax is error-free if used correctly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will the output of the below code?\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int arr[2] = { 1, 2 };\n    cout << arr[0] << \", \" << arr[1] << endl;\n    return 0;\n}\nChoices: ['A\\n1, 2', 'B\\nSyntax error', 'C\\nRun time error', 'D\\nNone']\nAnswer: A\n1, 2"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: Single variant hashing helps maintain a priority queue structure called a minimum hash queue. It offers a fast and efficient O(n) time complexity for insertion and access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the time required for single variant hashing to maintain the minimum hash queue?\na) O (log n!)\nb) O (n!)\nc) O (n2)\nd) O (n)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: When the head of a singly linked list is not given, deleting a node is only possible if it is not the last node. This is done by copying the data from the next node and updating the pointer to skip over it.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given pointer to a node X in a singly linked list. Only one pointer is given, pointer to head node is not given, can we delete the node X from given linked list?\nChoices: ['A\\nPossible if X is not last node. Use following two steps (a) Copy the data of next of X to X. (b)Update the pointer of node X to the node after the next node. Delete next of X.', 'B\\nPossible if size of linked list is even.', 'C\\nPossible if size of linked list is odd', 'D\\nPossible if X is not first node. Use following two steps (a) Copy the data of next of X to X. (b) Delete next of X.']\nAnswer: A\nPossible if X is not last node. Use following two steps (a) Copy the data of next of X to X. (b)Update the pointer of node X to the node after the next node. Delete next of X."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A threaded binary tree stores null pointers as links to in-order predecessors or successors to facilitate fast traversal without recursion or a stack. Node structure includes tag bits and pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In general, the node content in a threaded binary tree is ________\na) leftchild_pointer, left_tag, data, right_tag, rightchild_pointer\nb) leftchild_pointer, left_tag\nc) leftchild_pointer, left_tag, right_tag, rightchild_pointer\nd) leftchild_pointer, left_tag, data\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Skew heaps use a merging strategy that helps keep the structure balanced. There are two merge operations: one for the initial comparison and another for recursively combining subtrees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many types of the merge are available in skew heaps?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The height of a binary search tree is the longest path from the root to any leaf node. The structure depends on the insertion order of elements and affects search time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The following numbers are inserted into an empty binary search tree in the given order: 10, 1, 3, 5, 15, 12, 16. What is the height of the binary search tree (the height is the maximum distance of a leaf node from the root)? (GATE CS 2004)\nChoices: ['A\\n2\\n ', 'B\\n3\\n ', 'C\\n4\\n ', 'D\\n6\\n ']\nAnswer: B\n3"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Variable-length arrays (VLAs) allow programmers to define arrays whose size is determined at runtime instead of compile time. This adds flexibility in memory usage based on user input or other runtime conditions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is an advantage of using variable-length arrays?\na) Deciding the length of an array at the time of execution\nb) Memory allocation at compile time\nc) Initializing array at compile time\nd) Faster execution of code\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a rooted tree where each node has 0 or 3 children, a mathematical relationship exists between the total number of nodes and the number of leaf nodes. The number of leaves in such ternary trees can be derived using a formula.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of leaf nodes in a rooted tree of n nodes, with each node having 0 or 3 children is:\nChoices: ['A\\nn/2', 'B\\n(n-1)/3', 'C\\n(n-1)/2', 'D\\n(2n+1)/3']\nAnswer: D\n(2n+1)/3"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Breadth First Traversal (BFS) requires a queue to manage nodes level by level. While arrays can represent data structures, they don't provide the dynamic behavior required by BFS like a queue does.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The data structure required for Breadth First Traversal on a graph is?\na) Array\nb) Stack\nc) Tree\nd) Queue\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: In a circular queue, the rear and front pointers wrap around when they reach the end of the array. This wrapping is achieved using modulo arithmetic to stay within bounds.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a circular queue, how do you increment the rear end of the queue?\na) rear++\nb) (rear+1) % CAPACITY\nc) (rear % CAPACITY)+1\nd) rear–\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Free lists are used in dynamic memory allocation to keep track of free memory blocks. They are often implemented using linked lists or balanced trees for efficiency in merging and splitting blocks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What datastructures can be used in implementing a free list?\na) only linked list\nb) linked list or sort trees\nc) arrays\nd) trees\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Splay trees are a type of self-adjusting binary search tree that move frequently accessed elements closer to the root, improving access times for non-uniform access patterns.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are splay trees?\na) self adjusting binary search trees\nb) self adjusting binary trees\nc) a tree with strings\nd) a tree with probability distributions\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A k-d tree is a space-partitioning data structure used for organizing points in a k-dimensional space. Each level in the tree corresponds to splitting along a specific dimension.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Each level in a k-d tree is made of?\na) dimension only\nb) cutting and dimension\nc) color code of node\nd) size of the level\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: This C++ program uses an array and calculates a count array based on conditional comparisons. It prints the final count array. Understanding of loops, memory initialization, and logical indexing is essential to interpret the output.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following code?\n\n#include <bits/stdc++.h> \nusing namespace std; \n \nvoid func(int arr[], int n) \n{  \n int count[n]; \n memset(count, 0, sizeof(count)); \n \n for (int i=n-2; i>=0; i--) \n { \n  if (arr[i] >= n - i - 1) \n   count[i]++; \n \n  for (int j=i+1; j < n-1 && j <= arr[i] + i; j++) \n \n   if (count[j] != -1) \n    count[i] += count[j]; \n \n  if (count[i] == 0) \n   count[i] = -1; \n } \n \n for (int i=0; i<n; i++) \n  cout << count[i] << \" \"; \n} \n \nint main() \n{ \n int arr[] = {1, 3, 5, 8, 9}; \n int n = sizeof(arr) / sizeof(arr[0]); \n func(arr, n); \n return 0; \n}\n\na) 3\nb) 4\nc) 4 4 2 1 0\nd) 4 2 2 0 1\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Recursion is typically implemented using a stack to manage function calls. Although arrays can store data, stacks are necessary for tracking the call-return mechanism.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure is used for implementing recursion?\na) Queue\nb) Stack\nc) Array\nd) List\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The height of a binary search tree (BST) depends on the order of inserted elements. A balanced BST has logarithmic height, while skewed trees can have linear height.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The following numbers are inserted into an empty binary search tree in the given order: 10, 1, 3, 5, 15, 12, 16 What is the height of the binary search tree?\nChoices: ['A\\n3', 'B\\n4', 'C\\n5', 'D\\n6']\nAnswer: A\n3"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Hard\nContext: Merging sorted files involves comparing elements in each file. The time complexity is proportional to the total number of records across all files, making it O(n) for merging n records.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Merging 4 sorted files containing 50, 10, 25 and 15 records will take …… time\nChoices: ['A\\nO(100)', 'B\\nO(200)', 'C\\nO(175)', 'D\\nO(125)']\nAnswer: A\nO(100)"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Converting postfix expressions to infix requires understanding the order of operations and operator precedence. Evaluating the expression yields its numerical result.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The equivalent infix expression and value for the postfix form 1 2 + 3 * 4 5 * – will be ___________\na) 1 + 2 * 3 – 4 * 5 and -13\nb) (2 + 1) * (3 – 4) * 5 and 13\nc) 1 + 2 * (3 – 4) * 5 and -11\nd) (1 + 2) * 3 – (4 * 5) and -11\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Array representation of trees is memory efficient for complete or dense trees. However, for sparse trees, this leads to wasted space due to empty indices.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a situation of writing a binary tree into a file with memory storage efficiency in mind, is array representation of tree is good?\na) yes because we are overcoming the need of pointers and so space efficiency\nb) yes because array values are indexable\nc) No it is not efficient in case of sparse trees and remaining cases it is fine\nd) No linked list representation of tree is only fine\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: XOR has key properties like X⊕X = 0, X⊕0 = X, and associativity. These are used in cryptography and memory-efficient data structures like XOR linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not the properties of XOR lists?\na) X⊕X = 0\nb) X⊕0 = X\nc) (X⊕Y)⊕Z = X⊕(Y⊕Z)\nd) X⊕0 = 1\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: Queues are used in a variety of algorithms. LRU (Least Recently Used) uses a queue to track recent usage, while Quick Sort is not implemented with queues.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following option is not correct?\nChoices: ['A\\nIf the queue is implemented with a linked list, keeping track of a front pointer, Only rear pointer s will change during an insertion into an non-empty queue.', 'B\\nQueue data structure can be used to implement least recently used (LRU) page fault algorithm and Quick short algorithm.', 'C\\nQueue data structure can be used to implement Quick short algorithm but not least recently used (LRU) page fault algorithm.', 'D\\nBoth (A) and (C)']\nAnswer: C\nQueue data structure can be used to implement Quick short algorithm but not least recently used (LRU) page fault algorithm."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Recursive in-order traversal of a binary tree visits the left child, root, and then right child. The space complexity depends on the depth of recursion, which is equal to the depth of the tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the space complexity of the in-order traversal in the recursive fashion? (d is the tree depth and n is the number of nodes)\na) O(1)\nb) O(nlogd)\nc) O(logd)\nd) O(d)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The Travelling Salesman Problem (TSP) is a classic example of a problem solved using dynamic programming. It seeks the shortest path visiting all nodes exactly once and returning to the origin.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Travelling salesman problem is an example of …………..\nChoices: ['A\\nDynamic Algorithm', 'B\\nGreedy Algorithm', 'C\\nRecursive Approach', 'D\\nDivide & Conquer']\nAnswer: A\nGreedy Algorithm"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In row-major order, multi-dimensional arrays are stored row-by-row in memory. The formula for address calculation is: Base + [(i × number_of_columns) + j] × word_size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a two dimensional array A[20][10]. Assume 4 words per memory cell, the base address of array A is 100, elements are stored in row-major order and first element is A[0][0]. What is the address of A[11][5]?\nChoices: ['A\\n560', 'B\\n460', 'C\\n570', 'D\\n575']\nAnswer: A\n560"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Dynamic arrays resize themselves automatically, offering flexibility. However, they can suffer from memory leaks if allocation and deallocation are mismanaged.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a disadvantage of dynamic arrays?\na) Locality of reference\nb) Data cache utilization\nc) Random access\nd) Memory leak\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Tries, or prefix trees, allow fast lookup and storage of strings. Unlike hashing, tries are collision-free and support prefix-based search but often use more space.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not true?\na) Trie requires less storage space than hashing\nb) Trie allows listing of all the words with same prefix\nc) Tries are collision free\nd) Trie is also known as prefix tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: In linear probing, the expected number of probes for an unsuccessful search is calculated using load factor α. The formula involves analyzing probe sequences and probability.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the formula to find the expected number of probes for an unsuccessful search in linear probing?\na) 1/2 × (1 + 1/(1−α))\nb) 1/2 × (1 + 1/(1−α)^2)\nc) 1/2 × (1 + 1/(1+α))\nd) 1/2 × (1 + 1/(1+α)(1−α))\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: Depth First Search (DFS) explores paths as deeply as possible before backtracking, which enhances locality and cache efficiency during traversal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If locality is a concern, you can use …… to traverse the graph.\nChoices: ['A\\nBreadth First Search', 'B\\nDepth First Search', 'C\\nEither BFS or DFS', 'D\\nNone of these']\nAnswer: B\nDepth First Search"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A 2-3 tree is a balanced search tree where all leaves are at the same depth. It requires more complex node structures but enables more efficient search compared to traditional BSTs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is false?\na) 2-3 tree requires less storage than the BST\nb) lookup in 2-3 tree is more efficient than in BST\nc) 2-3 tree is shallower than BST\nd) 2-3 tree is a balanced tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In Java, arrays must be instantiated using the `new` keyword. The correct syntax uses square brackets and specifies the size explicitly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you instantiate an array in Java?\na) int arr[] = new int(3);\nb) int arr[];\nc) int arr[] = new int[3];\nd) int arr() = new int(3);\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The Van Emde Boas tree is a priority queue data structure that performs operations like insert, delete, and search in O(log log M) time, where M = 2^m.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Does Van Emde Boas data structure perform all operation in O (log (log M)) time where M = 2^m?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A queue is a linear data structure that follows the FIFO (First In First Out) principle. It differs from stacks and lists in access patterns.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A queue is a\nChoices: ['A\\nFIFO (First In First Out) list.', 'B\\nLIFO (Last In First Out) list.', 'C\\nOrdered array.', 'D\\nLinear tree.']\nAnswer: A\nFIFO (First In First Out) list."
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Adding an element to a binary heap involves inserting at the end and bubbling up. Time complexity is O(log n), which is also equal to the height of the heap (O(h)).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the complexity of adding an element to the heap?\na) O(log n)\nb) O(h)\nc) O(log n) & O(h)\nd) O(n)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Randomized trees can be generated using probabilistic distributions. Beta distribution is one such method used in randomized modeling and tree simulations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Can mathematical randomized tree be generated using beta distribution?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Merge sort is a divide-and-conquer algorithm often used to count inversions in arrays. Although it has O(n log n) time complexity, it requires additional O(n) space for temporary arrays.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the space complexity of the code that uses merge sort for determining the number of inversions in an array?\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n log n)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Reversing a doubly linked list involves swapping the next and prev pointers for each node. After traversal, the updated head becomes the previous tail node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following function that takes reference to head of a Doubly Linked List as parameter. Assume that a node of doubly linked list has previous pointer as prev and next pointer as next.\nvoid fun(struct node **head_ref) {\n    struct node *temp = NULL;\n    struct node *current = *head_ref;\n    while (current != NULL) {\n        temp = current->prev;\n        current->prev = current->next;\n        current->next = temp;\n        current = current->prev;\n    }\n    if (temp != NULL)\n        *head_ref = temp->prev;\n}\nChoices: ['A\\n2 <--> 1 <--> 4 <--> 3 <--> 6 <-->5', 'B\\n5 <--> 4 <--> 3 <--> 2 <--> 1 <-->6.', 'C\\n6 <--> 5 <--> 4 <--> 3 <--> 2 <--> 1.', 'D\\n6 <--> 5 <--> 4 <--> 3 <--> 1 <--> 2']\nAnswer: C\n6 <--> 5 <--> 4 <--> 3 <--> 2 <--> 1."
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Linear probing is a collision resolution technique in open addressing. It often leads to primary clustering, where groups of occupied slots form and grow.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following problems occur due to linear probing?\na) Primary collision\nb) Secondary collision\nc) Separate chaining\nd) Extendible hashing\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Stacks can hold any type of data, including characters like newline '\\n'. There is no inherent restriction unless enforced by application logic.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An error is thrown if the character ‘\\n’ is pushed in to the character stack.\na) true\nb) false\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In certain problems like Jump Game, a value of 0 at the starting index means no forward movement is possible, which can make reaching the end impossible.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: It is not possible to reach the end of an array if starting element of the array is 0.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Exponentiation (^) is typically right-associative in most programming languages, meaning the expression evaluates from right to left, like in a^b^c = a^(b^c).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The associativity of an exponentiation operator ^ is right side.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Leftist heaps are binary trees that maintain a heap property and a distance (null path length) value. Deletion of the minimum element takes O(log N) time due to recursive merging.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the time taken to delete a minimum element in a leftist heap?\na) O(N)\nb) O(N log N)\nc) O(log N)\nd) O(M log N)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Triply linked lists use three pointers (prev, next, and possibly an additional one like random or auxiliary), increasing their memory consumption compared to doubly linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Memory usage in triply linked list is higher than doubly linked list.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A 2-d tree (k-d tree for k=2) is a binary space partitioning structure used in multidimensional searching. Building a balanced k-d tree requires sorting points along axes, leading to O(N log N) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In what time can a 2-d tree be constructed?\na) O(N)\nb) O(N log N)\nc) O(N2)\nd) O(M log N)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Serial access memory is accessed sequentially, much like the Last-In-First-Out (LIFO) behavior of a stack, where the most recent element is accessed first.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The process of accessing data stored in a serial access memory is similar to manipulating data on a ………\nChoices: ['A\\nheap', 'B\\nqueue', 'C\\nstack \\n (A) heap \\n (B) queue \\n (C) stack', 'D\\nbinary tree']\nAnswer: C\nstack \n (A) heap \n (B) queue \n (C) stack"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Unlike static arrays which have a fixed size at compile time, dynamic arrays can grow or shrink at runtime, overcoming the limitation of fixed storage.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Dynamic arrays overcome the limit of static arrays.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Sparsity measures how many zero values are present in a matrix. It is defined as the ratio of zero elements to the total number of elements in the matrix.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is sparsity of a matrix?\na) The fraction of zero elements over the total number of elements\nb) The fraction of non-zero elements over the total number of elements\nc) The fraction of total number of elements over the zero elements\nd) The fraction of total number of elements over the non-zero elements\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: A dequeue (double-ended queue) allows insertion and deletion from both the front and rear ends, and can be implemented using doubly linked lists for flexibility.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a dequeue?\na) A queue implemented with both singly and doubly linked lists\nb) A queue with insert/delete defined for front side of the queue\nc) A queue with insert/delete defined for both front and rear ends of the queue\nd) A queue implemented with a doubly linked list\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: One drawback of splay trees is that accessing elements in sorted or nearly sorted order can result in a tree with linear height, reducing performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the disadvantage of using splay trees?\na) height of a splay tree can be linear when accessing elements in non decreasing order.\nb) splay operations are difficult\nc) no significant disadvantage\nd) splay tree performs unnecessary splay when a node is only being read\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a ternary heap, each node has three children. This structure allows for faster heap operations like decrease-key due to fewer comparisons per level compared to binary heaps.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is decrease priority operation performed more quickly in a ternary heap with respect to the binary heap?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Hashing provides direct access to data using a hash function. It is a common technique used in direct search applications for fast data retrieval.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A technique for direct search is ……\nChoices: ['A\\nBinary Search', 'B\\nLinear Search', 'C\\nTree Search', 'D\\nHashing']\nAnswer: D\nHashing"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The size of a binary tree can be calculated recursively using the formula: size(left subtree) + 1 (for the current node) + size(right subtree).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What may be the pseudo code for finding the size of a tree?\na) find_size(root_node→left_node) + 1 + find_size(root_node→right_node)\nb) find_size(root_node→left_node) + find_size(root_node→right_node)\nc) find_size(root_node→right_node) – 1\nd) find_size(root_node→left_node + 1\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In clustering algorithms, a mergeable cluster is a singleton if combining two clusters results in a new cluster with a single element, often used in hierarchical clustering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If A ∪ B (A and B are two clusters) is a singleton set then it is a Mergeable cluster.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Hashing is used in online spell checkers to quickly verify the presence of words in a dictionary by hashing input strings and matching them against stored hashes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Hashing can be used in online spelling checkers.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: An in-place algorithm uses a constant amount of additional memory and modifies the input directly. Rotating an array element-by-element does not require extra space, making it in-place.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: To rotate an array by using the algorithm of rotating its elements one by one is an in place algorithm.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: Binary Decision Diagrams (BDDs) represent Boolean functions using Directed Acyclic Graphs (DAGs). They are used in formal verification, model checking, and circuit design.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Binary Decision Diagram is a type of __________\na) Multigraph\nb) Cyclic Graph\nc) Directed Acyclic Graph\nd) Directed Acyclic Word Graph\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Hashing involves mapping keys to values using a hash function and storing them in a hash table. All three—key, hash function, and hash table—are essential components.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following are components of Hashing?\nChoices: ['A\\nKey', 'B\\nHash Function', 'C\\nHash Table', 'D\\nAll of the above']\nAnswer: D\nAll of the above"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Collision resolution is key to efficient hashing. Among various techniques, quadratic probing minimizes clustering better than linear probing but can still suffer from secondary clustering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which among the following is the best technique to handle collision?\na) Quadratic probing\nb) Linear probing\nc) Double hashing\nd) Separate chaining\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: Skew heaps are self-adjusting heaps that do not maintain strict structure. Their amortized cost per operation, such as insert or merge, is O(log N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the amortized cost per operation of a skew heap?\na) O(N)\nb) O(N log N)\nc) O(N2)\nd) O(log N)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In C++, multi-dimensional arrays stored in row-major order require address calculations using index formulas. For 3D arrays, the formula depends on dimensions and index order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A three dimensional array in ‘C++’ is declared as int A[x][y][z]. Consider that array elements are stored in row major order and indexing begins from 0. Here, the address of an item at the location A[p][q][r] can be computed as follows (where w is the word length of an integer):\nChoices: ['A\\n&A[0][0][0] + w(y * z * q + z * p + r)', 'B\\n&A[0][0][0] + w(y * z * p + z*q + r)', 'C\\n&A[0][0][0] + w(x * y * p + z * q+ r)', 'D\\n&A[0][0][0] + w(x * y * q + z * p + r)']\nAnswer: B\n&A[0][0][0] + w(y * z * p + z*q + r)"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In stack implementation using arrays, the next free position after N elements is S[N], assuming zero-based indexing and that capacity > N.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following array position will be occupied by a new element being pushed for a stack of size N elements (capacity of stack > N)?\na) S[N-1]\nb) S[N]\nc) S[1]\nd) S[0]\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Trees are used in multiple applications including parsing expressions, hierarchical data storage, routing algorithms, and decision-making processes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the main applications of tree data structure?\nChoices: ['A\\n1, 2, 3, 4 and 6', 'B\\n1, 2, 3, 4 and 5', 'C\\n1, 3, 4, 5 and 6', 'D\\n1, 2, 3, 4, 5 and 6']\nAnswer: D\n1, 2, 3, 4, 5 and 6"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Inserting a node at the beginning of a linked list involves updating the new node’s next pointer to the current head and making the new node the new head.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The following steps in a linked list\nChoices: ['A\\npop operation in stack', 'B\\nremoval of a node', 'C\\ninserting a node at beginning ', 'D\\nmodifying an existing node']\nAnswer: C\ninserting a node at beginning"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Skip lists are probabilistic data structures that use random levels to achieve fast search times. The number of forward pointers in a node is typically determined probabilistically.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The nodes in a skip list may have many forward references. Their number is determined\n\na) probabilistically\nb) randomly\nc) sequentially\nd) orthogonally\n\nAnswer: a"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: In C++, the `sort()` function from the `<algorithm>` header can be used to sort strings by passing iterators to the beginning and end of the string, i.e., `sort(str.begin(), str.end())`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the function present to sort a string in C++?\nChoices: ['A\\nsort();', 'B\\n sort(str.begin(), str.end());', 'C\\nSort_asec();', 'D\\nNone']\nAnswer: B\n sort(str.begin(), str.end());"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The Ackermann function is a classic example of a recursive function that grows extremely rapidly and is not primitive recursive. It is defined such that A(1, i) = i + 1 for i ≥ 1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the definition for Ackermann’s function?\na) A(1,i) = i+1 for i>=1\nb) A(i,j) = i+j for i>=j\nc) A(i,j) = i+j for i = j\nd) A(1,i) = i+1 for i<1\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: In infix-to-postfix conversion, operands are output directly, and parentheses are not included in the final postfix result. Operators are pushed based on precedence rules.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following statement is incorrect with respect to infix to postfix conversion algorithm?\na) operand is always placed in the output\nb) operator is placed in the stack when the stack operator has lower precedence\nc) parenthesis are included in the output\nd) higher and equal priority operators follow the same condition\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Generalized LR (GLR) parsing handles ambiguous grammars and has time complexity O(|G| × n), where |G| is the grammar size and n is the input length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which among the following best represents the computational complexity of GLR parsing?\na) O(|G| x n)\nb) O(|G|2 x n)\nc) O(|G| x n2)\nd) O(|G|2 x n2)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A 2-3-4 tree is a B-tree of order 4 and is isometric to a red-black tree, meaning they maintain the same structure and balancing logic under different representations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: 2-3-4 trees are B-trees of order 4. They are an isometric of _____ trees.\na) AVL\nb) AA\nc) 2-3\nd) Red-Black\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In adjacency list representation of a weighted directed graph, each vertex stores a list of its neighbors along with edge weights. The pair is usually (neighbor, weight).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Complete the given snippet of code for the adjacency list representation of a weighted directed graph.\na) vertex, vertex\nb) neighbor, vertex\nc) neighbor, neighbor\nd) vertex, neighbor\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: A hash table is a data structure that maps keys to values using a hash function. It is not used for stack or queue operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a hash table?\na) A structure that maps values to keys\nb) A structure that maps keys to values\nc) A structure used for storage\nd) A structure used to implement stack and queue\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Infix notation places the operator between operands. It is the most familiar notation for humans, unlike prefix and postfix used in computation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is an infix expression?\na) (a+b)*(c+d)\nb) ab+c*\nc) +ab\nd) abc+*\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Balanced expressions require that all types of brackets are properly opened and closed. An extra closing or unmatched symbol breaks this rule.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is the given statement ((A+B) + [C-D]] valid with respect to balancing of symbols?\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In graph theory, a leaf cluster is a group of nodes connected in such a way that only one node connects to the rest of the graph. This typically means it has zero internal edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many edges does a leaf cluster contain?\na) 0\nb) 1\nc) 2\nd) 3\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The runtime efficiency of an insertion algorithm depends on the data structure used. In unsorted arrays or linked lists, insertion at the end or front generally takes O(N) in the worst case.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the run time efficiency of an insertion algorithm?\na) O(N)\nb) O(log N)\nc) O(N2)\nd) O(M log N)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Postfix (Reverse Polish) notation rearranges an infix expression so that it can be evaluated without parentheses. This is commonly used in stack-based computations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the postfix expression for the following infix expression?\na) abc^/d-\nb) ab/cd^-\nc) ab/^cd-\nd) abcd^/-\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Stacks follow LIFO order and do not allow removal from the bottom. Such operations violate stack constraints and are generally not permitted in standard implementations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In C programming, when we remove an item from bottom of the stack, then:\nChoices: ['A\\nThe stack will fall down.', 'B\\nStack will rearrange items. \\n (A) The stack will fall down. \\n (B) Stack will rearrange items.', 'C\\nIt will convert to LIFO', 'D\\nThis operation is not allowed.']\nAnswer: D\nThis operation is not allowed."
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Bit arrays are memory-efficient structures used in low-level system tasks like memory page tracking or Bloom filters, but not typically used for implementing vector/matrix operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is/are not applications of bit arrays?\na) Used by the Linux kernel\nb) For the allocation of memory pages\nc) Bloom filter\nd) Implementation of Vectors and Matrices\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: The given function performs deletion from the beginning of a circular linked list by updating the head and deleting the original first node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the following code? Choose the most appropriate answer.\nint function() {\n    if (head == null)\n        return Integer.MIN_VALUE;\n    int var;\n    Node temp = head;\n    while (temp.getNext() != head)\n        temp = temp.getNext();\n    if (temp == head) {\n        var = head.getItem();\n        head = null;\n        return var;\n    }\n    temp.setNext(head.getNext());\n    var = head.getItem();\n    head = head.getNext();\n    return var;\n}\nChoices: ['A\\nReturn data from the end of the list', 'B\\nReturns the data and deletes the node at the end of the list', 'C\\nReturns the data from the beginning of the list', 'D\\nReturns the data and deletes the node from the beginning of the list']\nAnswer: D\nReturns the data and deletes the node from the beginning of the list"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: The given recursive C++ function reads a string and uses recursion to delay printing each character until after the call stack unwinds, effectively reversing the string.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the following code segment doing?\nvoid fn() {\n  char c;\n  cin.get(c);\n  if (c != '\\n') {\n    fn();\n    cout.put(c);\n  }\n}\nChoices: ['A\\nThe string entered is printed as it is.', 'B\\nThe string entered is printed in reverse order.', 'C\\nIt will go in an infinite loop.', 'D\\nIt will print an empty line.']\nAnswer: B\nThe string entered is printed in reverse order."
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: To compute the sum of nodes at alternate levels in a binary tree, you skip levels while summing values. This often involves toggling a level flag or skipping iterations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What must be the missing logic in place of missing lines for finding sum of nodes of binary tree in alternate levels?\n\n// e.g.: for a complete binary tree of height 3: [1,2,3,4,5,6,7], sum = 1+4+5+6+7 = 23\nn = power(2,height)-1; // total nodes\nfor (i = 1; i <= n;) {\n  for (j = 1; j <= pow(2, currentlevel-1); j++) {\n    sum = sum + a[i];\n    i = i + 1;\n  }\n  // missing logic here to skip alternate level\n}\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: A treap is a combination of a binary search tree and a heap. The priority values determine heap order, and the condition is that a node's priority must be at least as large as its parent.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the condition for priority of a node in a treap?\na) a node’s priority should be greater than its parent\nb) a node’s priority should be at least as large as its parent\nc) the priority is randomly assigned and can have any value\nd) a node’s priority is always given in decreasing order\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: In hashing with chaining, each table slot points to a linked list of entries that hash to the same slot. Although it handles collisions well, it increases space usage.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the disadvantage of hashing with chaining?\na) not easy to implement\nb) takes more space\nc) quite sensitive to hash function\nd) table gets filled up easily\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In infix to postfix conversion, operators are typically associated based on their precedence. Most binary operators (like +, -, *, /) associate from left to right unless otherwise specified.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In infix to postfix conversion algorithm, the operators are associated from?\na) right to left\nb) left to right\nc) centre to left\nd) centre to right\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: AVL trees are self-balancing binary search trees that ensure logarithmic height. The height difference between the deepest and shallowest leaves is bounded by O(log n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What maximum difference in heights between the leafs of a AVL tree is possible?\na) log(n) where n is the number of nodes\nb) n where n is the number of nodes\nc) 0 or 1\nd) atmost 1\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Prefix notation places operators before their operands. Conversion from infix to prefix involves reversing the expression and applying operator precedence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The prefix form of A-B/ (C * D ^ E) is?\na) -/*^ACBDE\nb) -ABCD*^DE\nc) -A/B*C^DE\nd) -A/BC*^DE\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: In a linked queue implementation, overflow must be checked before inserting a new element, especially in cases where memory allocation might fail.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The essential condition which is checked before insertion in a linked queue is?\na) Underflow\nb) Overflow\nc) Front value\nd) Rear value\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Hash tables use probing or chaining to handle collisions. The position where a value is inserted depends on the hash function and collision resolution strategy used.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: At what position the number 72 gets inserted in the following table?\na) 3\nb) 10\nc) 4\nd) 6\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The smallest index value in an array is called its lower bound. In most programming languages, this value is 0 unless otherwise specified.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The smallest element of an array’s index is called its\nChoices: ['A\\nlower bound', 'B\\nupper bound', 'C\\nrange', 'D\\nextraction']\nAnswer: A\nlower bound"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Arrays can lead to inefficient memory usage if allocated size exceeds actual data. This static allocation causes wasted memory when not fully utilized.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the disadvantages of arrays?\na) Index value of an array can be negative\nb) Elements are sequentially accessed\nc) Data structure like queue or stack cannot be implemented\nd) There are chances of wastage of memory space if elements inserted in an array are lesser than the allocated size\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: B+ trees are balanced tree structures optimized for systems that read and write large blocks of data. They reduce disk access, which is significantly slower than memory access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: B+ trees are preferred to binary trees in databases because (GATE CS 2000)\nChoices: ['A\\nDisk capacities are greater than memory capacities', 'B\\nDisk access is much slower than memory access', 'C\\nDisk data transfer rates are much less than memory data transfer rates', 'D\\nDisks are more reliable than memory']\nAnswer: B\nDisk access is much slower than memory access"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The problem involves verifying if a root-to-leaf path exists with a given sum. The missing logic in recursive solutions often involves subtracting the current node’s value and checking child nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is missing in this logic of finding a path in the tree for a given sum (i.e checking whether there will be a path from roots to leaf nodes with given sum)?\n\ncheckSum(struct bin-treenode *root , int sum):\n  if(root==null)\n    return sum as 0\n  else:\n    leftover_sum = sum - root_node->value\n    //missing\n  if(rootnode):\n    mirror(rootnode->left)\n    mirror(rootnode->right)\n    //missing\nend\n\na) swapping of left and right nodes is missing\nb) swapping of left with root nodes is missing\nc) swapping of right with root nodes is missing\nd) nothing is missing\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: A graph is called regular if every vertex has the same degree. These graphs have uniform structure and are useful in network topology and theoretical analysis.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A graph with all vertices having equal degree is known as a __________\na) Multi Graph\nb) Regular Graph\nc) Simple Graph\nd) Complete Graph\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Arrays are data structures used to store elements of the same type in contiguous memory locations. They allow indexed access and are foundational in many algorithms.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of these best describes an array?\na) A data structure that shows a hierarchical behavior\nb) Container of objects of similar types\nc) Arrays are immutable once initialised\nd) Array is not a data structure\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Operating systems may periodically perform garbage collection to reclaim unused memory and consolidate it into contiguous blocks, improving performance and memory usage.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The OS of a computer may periodically collect all the free memory space to form contiguous block of free space. This is called:\nChoices: ['A\\nConcatenation', 'B\\nGarbage collection', 'C\\nCollision', 'D\\nDynamic Memory Allocation']\nAnswer: B\nGarbage collection"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Skew heaps are self-adjusting heaps with no structural constraints. Due to their irregular nature, it is harder to determine right path lengths compared to structured heaps like leftist or binomial.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is difficult to determine the right path length?\na) Skew heaps\nb) Binomial tree\nc) Leftist heap\nd) d-heap\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: If operator arity is fixed, expressions can be unambiguously parsed using prefix (Polish) or postfix (Reverse Polish) notation, eliminating the need for parentheses.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If arity of operators is fixed, then which of the following notations can be used to parse expressions without parentheses?\na) Infix Notation\nb) Postfix Notation\nc) Prefix Notation\nChoices: ['A\\nb and c', 'B\\nOnly b', 'C\\na, b and c', 'D\\nNone of them']\nAnswer: A\nb and c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Serial access memory (SAM) stores data in a linear format and can be accessed sequentially, similar to a stack, which also operates on LIFO principles.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The process of accessing data stored in a serial access memory is similar to manipulating data on a ________\na) Heap\nb) Binary Tree\nc) Array\nd) Stack\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: An indexed skip list optimizes search time by storing metadata such as widths or levels instead of elements. This improves efficiency over basic linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is indexed skip list?\na) it stores width of link in place of element\nb) it stores index values\nc) array based linked list\nd) indexed tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: A hash tree, or Merkle tree, generalizes a hash list by using a hierarchical tree structure where each parent node is a hash of its children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Hash tree is generalization of ______\na) Heap\nb) Hash list\nc) BST\nd) B – tree\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Operator precedence defines the order in which operations are performed. Custom or uncommon operators like # are typically assigned the lowest precedence in parsing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Of the following choices, which operator has the lowest precedence?\na) ^\nb) +\nc) /\nd) #\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: With augmented trees or segment trees, it is possible to track the ordinal position and ordering of keys, allowing efficient indexing and range queries.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Elements in a tree can be indexed by its position under the ordering of the keys and the ordinal position of an element can be determined, both with good efficiency.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: When reconstructing a heap, merging sub-heaps involves combining c children. Using pairwise merges requires c - 1 merge operations to fully reassemble the heap.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If there are c children of the root, how many calls to the merge procedure is required to reassemble the heap?\na) c\nb) c+1\nc) c-1\nd) 1\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In a directed graph with no self-loops, the maximum number of edges is n(n−1), where n is the number of vertices. This is because each node can have directed edges to every other node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum possible number of edges in a directed graph with no self loops having 8 vertices?\na) 28\nb) 64\nc) 256\nd) 56\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Left-Leaning Red-Black (LLRB) trees are a simplified form of red-black trees that simulate 2–3 trees, maintaining a 1-1 correspondence with them for structural balance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: LLRB maintains 1-1 correspondence with 2–3 trees.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: Finding connected components in an undirected graph using adjacency lists takes O(n + e) time using DFS or BFS, where n is the number of vertices and e is the number of edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An undirected graph G with n vertices and e edges is represented by adjacency list. What is the time required to generate all the connected components?\nChoices: ['A\\nO(n)', 'B\\nO(e)', 'C\\nO(e+n)', 'D\\nO(e2)']\nAnswer: C\nO(e+n)"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A top tree is a dynamic tree data structure used to represent and maintain a forest under link and cut operations efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure is used to maintain a dynamic forest using a link or cut operation?\na) Top Tree\nb) Array\nc) Linked List\nd) Stack\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a max heap, the smallest value (like 5) will percolate down to the lowest level if larger elements exist. Thus, it will end up at the last level in the heap.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the position of 5, when a max heap is constructed on the input elements 5, 70, 45, 7, 12, 15, 13, 65, 30, 25?\na) 5 will be at root\nb) 5 will be at last level\nc) 5 will be at second level\nd) 5 can be anywhere in heap\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: In prefix trees or tries, two outgoing edges from a node cannot begin with the same character to ensure unique path prefixes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Can the two edges that are coming out of a node have labels of string beginning with the same character?\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Modifying edge weights affects the structure of a graph. Squaring edge weights does not preserve MST structure or weight relation due to non-linear scaling.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let G be a weighted graph with edge weights greater than one and G' be the graph constructed by squaring the weights of edges in G. Let T and T' be the minimum spanning trees of G and G', respectively, with total weights t and t'. Which of the following statements is TRUE?\nChoices: [\"A\\nT' = T with total weight t' = t2\", \"B\\nT' = T with total weight t' < t2\", \"C\\nT' != T but total weight t' = t2\", 'D\\nNone of the above']\nAnswer: D\nNone of the above"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Ukkonen provided the first linear-time online algorithm to build a suffix tree, making suffix tree construction efficient and widely applicable in string algorithms.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Who among the following provided the first online contribution of Suffix Tree?\na) Weiner\nb) Samuel F. B. Morse\nc) Ukkonen\nd) Alexander Morse\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A binary tree is a hierarchical structure where each node has at most two children—commonly referred to as the left and right child.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many children does a binary tree have?\na) 2\nb) any number of children\nc) 0 or 1 or 2\nd) 0 or 1\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: In hashing, chaining is a collision resolution method where elements that hash to the same slot are stored in a secondary structure, such as a linked list or binary tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following technique stores data separately in case of a collision?\na) Open addressing\nb) Double hashing\nc) Quadratic probing\nd) Chaining using a binary tree\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In tries (prefix trees), each character in a string corresponds to a node. The insertion logic includes creating new nodes when necessary and advancing the node pointer.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Following code snippet is the function to insert a string in a trie. Find the missing line.\nprivate void insert(String str) {\n    TrieNode node = root;\n    for (int i = 0; i < length; i++) {\n        int index = key.charAt(i) - 'a';\n        if (node.children[index] == null)\n            node.children[index] = new TrieNode();\n        ________________________\n    }\n    node.isEndOfWord = true;\n}\na) node = node.children[index];\nb) node = node.children[str.charAt(i + 1)];\nc) node = node.children[index++];\nd) node = node.children[index++];\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A sentinel is a dummy value inserted at the end of a data structure like an array to simplify boundary conditions and terminate loops cleanly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The extra key inserted at the end of the array is called a ………\nChoices: ['A\\nEnd Key', 'B\\nStop Key', 'C\\nSentinel', 'D\\nTransposition']\nAnswer: C\nSentinel"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: Level-order traversal of a tree involves visiting nodes level by level from top to bottom using a queue data structure. Correct ordering of child node enqueuing is crucial.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Select the code snippet which performs level-order traversal.\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Reversing an array reorders its elements from last to first. For example, arr[]={3,5,4,2} becomes {2,4,5,3} when reversed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the resulting array after reversing arr[]={3,5,4,2}?\na) 2,3,5,4\nb) 4,2,3,5\nc) 5,4,2,3\nd) 2,4,5,3\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A rope is a binary tree used for efficiently manipulating long strings, supporting fast operations like concatenation, splitting, and insertion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which type of data structure does rope represent?\na) Array\nb) Linked List\nc) Queue\nd) Binary Tree\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: In a binary hash tree (Merkle tree), the height is determined by the logarithm (base branching factor) of the number of records. For branching factor 2 and 8 records, height = 3.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the height of the hash tree with branching factor 2 and with 8 records?\na) 3\nb) 5\nc) 4\nd) 6\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In Binary Decision Diagrams (BDDs), conventionally, the 0 branch is depicted using a dotted or dashed line and the 1 branch using a solid or bold line.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a Binary Decision Diagram, 0 values are represented by a _________ line and 1 values are represented by a _________ line.\na) dashed, bold\nb) bold, dashed\nc) dotted, bold\nd) dotted, dashed\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: Quick sort is a divide-and-conquer sorting algorithm. It is distinct from heap sort, merge sort, or bubble sort and thus is not synonymous with any of them.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Quick sort is also known as ………\nChoices: ['A\\nMerge sort', 'B\\nHeap sort', 'C\\nBubble sort', 'D\\nNone of these']\nAnswer: D\nNone of these"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The Jaccard index measures similarity between two sets as the size of their intersection divided by the size of their union. If the sets are disjoint, the index is 0.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the value of the Jaccard index when the two sets are disjoint?\na) 1\nb) 2\nc) 3\nd) 0\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: A queue allows insertion at the rear and deletion from the front, making it a linear list with FIFO (First In, First Out) behavior.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A linear list of elements in which deletion can be done from one end (front) and insertion can take place only at the other end (rear) is known as a ………\nChoices: ['A\\nQueue', 'B\\nStack', 'C\\nTree', 'D\\nLinked list']\nAnswer: A\nQueue"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a complete binary min-heap with 1023 nodes (which forms a full tree of height 9), the value 9 can be placed as deep as level 8 while maintaining the min-heap property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A complete binary min-heap is made by including each integer in [1, 1023] exactly once. The depth of a node in the heap is the length of the path from the root of the heap to that node. Thus, the root is at depth 0. The maximum depth at which integer 9 can appear is _____________\nChoices: ['A\\n6', 'B\\n7', 'C\\n8', 'D\\n9']\nAnswer: C\n8"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In prefix (Polish) notation, the operator is written before its operands. Conversion follows operator precedence and associativity rules.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the Prefix notation for the given equation?\na) +*AB*CD\nb) *+AB*CD\nc) **AB+CD\nd) +*BA*CD\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: Queues are used in scenarios where data must be processed in the order it arrives. Applications include resource sharing, asynchronous data transfer, and load balancing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which one of the following is an application of Queue Data Structure?\nChoices: ['A\\nWhen a resource is shared among multiple consumers.', 'B\\nWhen data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes', 'C\\nLoad Balancing', 'D\\nAll of the above']\nAnswer: D\nAll of the above"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Collision resolution techniques aim to reduce clustering. Increasing the hash table size helps reduce collisions but isn't considered a collision resolution technique.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not a technique to avoid a collision?\na) Make the hash function appear random\nb) Use the chaining method\nc) Use uniform hashing\nd) Increasing hash table size\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Arrays allow direct or random access using indices, making element retrieval instantaneous regardless of the array’s size or content.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Elements in an array are accessed _____________\na) randomly\nb) sequentially\nc) exponentially\nd) logarithmically\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In a circular linked list, inserting at the head involves adjusting both the head and the last node's next pointer to point to the new head.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Choose the code snippet which inserts a node to the head of the list?\nChoices: [Option A full code snippet...]\nAnswer: A"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A strictly binary tree is one in which each node has either 0 or 2 children. If a tree has 10 leaves, it has exactly 19 nodes due to the property N = 2L - 1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A strictly binary tree with 10 leaves\nChoices: ['A\\ncannot have more than 19 nodes', 'B\\nhas exactly 19 nodes', 'C\\nhas exactly 17 nodes', 'D\\nhas exactly 20 nodes']\nAnswer: B\nhas exactly 19 nodes"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Linear probing uses sequential slots for collision resolution and has better spatial locality, improving cache performance compared to methods like double hashing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following techniques offer better cache performance?\na) Quadratic probing\nb) Linear probing\nc) Double hashing\nd) Rehashing\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Stack is a Last-In-First-Out (LIFO) data structure commonly used for parsing and matching nested structures like parentheses, making it ideal for syntax checking.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following data structures can be used for parentheses matching?\na) n-ary tree\nb) queue\nc) priority queue\nd) stack\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Converting infix expressions to postfix (Reverse Polish Notation) using a stack requires handling operator precedence and associativity while maintaining correct operand order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Convert the following Infix expression to Postfix form using a stack.\nx + y * z + (p * q + r) * s, Follow usual precedence rule and assume that the expression is legal.\na) xyz*+pq*r+s*+\nb) xyz*+pq*r+s+*\nc) xyz+*pq*r+s*+\nd) xyzp+**qr+s*+\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A bounded-size dynamic array splits the array into two parts to accommodate variable sizes efficiently while limiting memory reallocation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Array is divided into two parts in ____________\na) Hashed Array Tree\nb) Geometric Array\nc) Bounded-size dynamic array\nd) Sparse Array\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a K-ary tree, the maximum number of leaf nodes is bounded by K^h where K is the branching factor and h is the height.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the upper bound for maximum leaves in K-ary tree with height h?\na) K*h\nb) K^h\nc) K+h\nd) K-h\n\nAnswer: b"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: In the balancing parentheses algorithm, a string is typically scanned from left to right to push opening symbols and match them with closing ones using a stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In balancing parentheses algorithm, the string is read from?\na) right to left\nb) left to right\nc) center to right\nd) center to left\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: Selection sort repeatedly selects the smallest element from the unsorted portion of the list and swaps it with the first unsorted element. It's not related to quick sort.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A sort which relatively passes through a list to exchange the first element with any element less than it and then repeats with a new first element is called ………\nChoices: ['A\\nInsertion sort', 'B\\nSelection sort', 'C\\nHeap sort', 'D\\nQuick sort']\nAnswer: B\nQuick sort"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: If the pre-order and post-order traversals of a binary tree are the same, the tree must contain only one node since traversal orders differ otherwise.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The pre-order and post order traversal of a Binary Tree generates the same output. The tree can have maximum ………\nChoices: ['A\\nThree nodes', 'B\\nTwo nodes', 'C\\nOne node', 'D\\nAny number of nodes']\nAnswer: C\nOne node"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: In string concatenation or addition, numeric strings like \"10\" and \"20\" concatenate to form \"1020\" if treated as strings instead of integers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Guess the output:\nChoices: ['A\\n\"10 20\"', 'B\\n30', 'C\\n10 20', 'D\\n1020']\nAnswer: D\n1020"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In an incidence matrix of a directed graph without self-loops, each edge connects two different nodes—one incoming and one outgoing—making the column sum 0.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The column sum in an incidence matrix for a directed graph having no self loop is __________\na) 0\nb) 1\nc) 2\nd) equal to the number of edges\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: A Binary Decision Diagram (BDD) is a directed acyclic graph that represents Boolean expressions. Every BDD can be considered a propositional DAG.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Every Binary Decision Diagram is also a Propositional Directed Acyclic Graph.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In postorder traversal of a binary tree, the left subtree is visited first, followed by the right subtree, and then the root, making this statement true.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In postorder traversal of binary tree right subtree is traversed before visiting root.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: A min-wise independent permutation is a family of permutations used in approximation algorithms. The number of bits needed to specify a permutation depends on its domain size, often bounded by Ω(n).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many bits are needed to specify the single permutation by min-wise independent family?\na) O (log n!)\nb) O (n!)\nc) Ω (n²)\nd) Ω (n)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In a stack implemented using an array, the top element is located at index S[N−1] when there are N elements. This follows the Last-In-First-Out (LIFO) structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following array element will return the top-of-the-stack-element for a stack of size N elements (capacity of stack > N)?\na) S[N-1]\nb) S[N]\nc) S[N-2]\nd) S[N+1]\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: An equivalence relation on a set satisfies three properties: reflexivity, symmetry, and transitivity. These ensure consistent grouping of elements into equivalence classes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many properties will an equivalence relationship satisfy?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A binary min-heap has the property that every parent node is less than or equal to its children. This property must be maintained throughout the array representation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which one of the following array elements represents a binary min heap?\na) 12 10 8 25 14 17\nb) 8 10 12 25 14 17\nc) 25 17 14 12 10 8\nd) 14 17 25 10 12 8\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Tries are tree-like data structures that store strings efficiently and allow fast lookup, making them suitable for autocomplete and spell checking systems.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Auto complete and spell checkers can be implemented efficiently using the trie.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Converting infix to prefix notation requires understanding operator precedence and using a stack to temporarily store operators during the rearrangement.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What data structure is used when converting an infix notation to prefix notation?\na) Stack\nb) Queue\nc) B-Trees\nd) Linked-list\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In AA-trees (a variation of balanced binary search trees), only right children can be red, simplifying the balancing operations compared to red-black trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the prime condition of AA-tree which makes it simpler than a red-black tree?\na) Only right children can be red\nb) Only left children can be red\nc) Right children should strictly be black\nd) There should be no left children\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A complete binary tree of height n has 2ⁿ⁺¹ – 1 nodes in total. Thus, for height n, the total number of nodes is 2n+1 in a perfect binary tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: log2 n nodes\nChoices: ['A\\nlog2 n nodes', 'B\\nn+1 nodes', 'C\\n2n nodes', 'D\\n2n+1 nodes']\nAnswer: D\n2n+1 nodes"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In Java, dynamic arrays are implemented using the `List` interface and classes such as `ArrayList`, which allow dynamic resizing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How will you implement dynamic arrays in Java?\na) Set\nb) Map\nc) HashMap\nd) List\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: A hash table allows constant-time average access to data due to direct indexing via hash functions, making it significantly faster than other structures for lookup.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the advantage of a hash table as a data structure?\na) faster access of data\nb) easy to implement\nc) very efficient for less number of entries\nd) exhibit good locality of reference\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Finding the nearest neighbor in a k-d tree involves traversing a logarithmic path down the tree and comparing across dimensions, yielding a runtime of O(2^d * log N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the run time of finding the nearest neighbour in a k-d tree?\na) O(2+ log N)\nb) O( log N)\nc) O(2^d log N)\nd) O( N log N)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: An in-order traversal of a binary search tree visits nodes in ascending order: left subtree, root, then right subtree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In order to get the contents of a Binary search tree in ascending order, one has to traverse it in ………\nChoices: ['A\\npre-order', 'B\\nin-order', 'C\\npost order', 'D\\nnot possible']\nAnswer: B\nin-order"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Space requirements differ for graphs depending on properties like directionality and weights. Directed and weighted graphs require more space than undirected and unweighted ones.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For the given conditions, which of the following is in the correct order of increasing space requirement?\ni) Undirected, no weight\nii) Directed, no weight\niii) Directed, weighted\niv) Undirected, weighted\na) ii iii i iv\nb) i iii ii iv\nc) iv iii i ii\nd) i ii iii iv\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The Standard Template Library (STL) in C++ provides several sequence containers such as vector, list, and deque. The `array` class is part of STL but is not a dynamic sequence container.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not a sequence container provided by the STL?\nChoices: ['A\\nvector', 'B\\narray', 'C\\nlist', 'D\\ndeque']\nAnswer: B\narray"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In-order traversal of a binary tree visits nodes in the order: left subtree, root, and right subtree. It’s commonly used to retrieve sorted elements in BSTs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which traversal is shown by this pseudo code?\nChoices: ['A\\nIn-order', 'B\\nLevel Order', 'C\\nPost-order', 'D\\nPre-order']\nAnswer: A\nIn-order"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: An unrolled linked list is a type of linked list where each node holds an array of elements instead of a single element, improving cache performance and memory locality.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which among the following is a typical declaration of an unrolled linked list in C?\na)\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: A queue restricts insertions to the rear and removals from the front. It can be implemented using linked lists with separate front and rear pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure represents a waiting line and limits insertions to be made at the back of the data structure and limits removals to be made from the front?\nChoices: ['A\\nStack', 'B\\nQueue', 'C\\nBinary tree', 'D\\nLinked list']\nAnswer: B\nQueue"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Syntax trees represent syntactic structures of expressions. They are constructed bottom-up using bottom-up parsing techniques like shift-reduce parsing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which parsing approach is followed by syntax tree?\na) Top-down parsing\nb) Bottom-up parsing\nc) Predictive parsing\nd) Shift reduce parsing\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A queue follows the FIFO principle, meaning the first element inserted is the first one removed. It is often implemented using arrays or linked lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A queue follows __________\na) FIFO (First In First Out) principle\nb) LIFO (Last In First Out) principle\nc) Ordered array\nd) Linear tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In C, variable-length arrays (VLAs) allow the use of runtime-computed expressions during declaration, offering flexibility in memory management.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Arbitrary expressions can be used while declaring variable-length arrays.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Quadratic probing is a collision resolution method in open addressing. When the table size is prime, quadratic probing ensures successful insertion until the table is full.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In quadratic probing, if the table size is prime, a new element cannot be inserted if the table is half full.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Medium\nContext: Quick Sort is a divide-and-conquer sorting algorithm that uses a pivot element to partition the list into subarrays, which are then sorted recursively.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: To partition an unsorted list, a pivot element is used in ………\nChoices: ['A\\nMerge Sort', 'B\\nQuick Sort', 'C\\nInsertion Sort', 'D\\nSelection Sort']\nAnswer: B\nQuick Sort"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The number of structurally unique binary trees with n nodes is given by the nth Catalan number. For 4 nodes, this is C₄ = 14.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of structurally different possible binary trees with 4 nodes is\nChoices: ['A\\n14', 'B\\n12', 'C\\n336', 'D\\n168']\nAnswer: A\n14"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: In a 4-regular graph, each vertex has degree 4. By using the handshaking lemma (2E = dV), we find that 12 edges imply 6 vertices.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Determine the number of vertices for the given Graph or Multigraph?\nG is a 4-regular Graph having 12 edges.\na) 3\nb) 6\nc) 4\nd) Information given is insufficient\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Rope data structures are typically implemented using balanced binary trees like AVL or Red-Black trees to support efficient string operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which type of binary tree does rope require to perform basic operations?\na) Unbalanced\nb) Balanced\nc) Complete\nd) Full\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A K-ary tree is a tree in which every node has at most K children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many child nodes does each node of K-ary Tree contain?\na) 2\nb) 3\nc) more than k\nd) at most k\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: The program prints symmetric pairs from an array of pairs. If (a, b) and (b, a) exist, it prints them. The correct output reflects the matched symmetric pairs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Output of the given program is:\nChoices: ['A\\n(30, 40)\\n(5, 10)', 'B\\n(30, 40)\\n(5, 5)', 'C\\n(30, 4)\\n(5, 1)', 'D\\n(3, 4)\\n(5, 1)']\nAnswer: A\n(30, 40)\n(5, 10)"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: Queues are widely used in operating systems and network communication for resource allocation and scheduling, where FIFO behavior is needed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A queue data-structure can be used for ………\nChoices: ['A\\nexpression parsing', 'B\\nrecursion', 'C\\nresource allocation', 'D\\nall of these']\nAnswer: C\nresource allocation"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Minimum ternary heaps are used in optimization algorithms like Prim’s algorithm for efficient extraction of the minimum element.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the application of minimum ternary heap?\na) Prim’s Algorithm\nb) Euclid’s Algorithm\nc) Eight Queen Puzzle\nd) Tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In the given program, no modification is made to the matrix. The result of the program is simply the original matrix A.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let A be a square matrix of size n x n. Consider the following program. What is the expected output?\nChoices: ['A\\nThe matrix A itself', 'B\\nTranspose of matrix A', 'C\\nAdding 100 to the upper diagonal elements and subtracting 100 from diagonal elements of A', 'D\\nInverse of matrix A']\nAnswer: A\nThe matrix A itself"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: When the root is removed from a binary heap, the rightmost element of the last level replaces it to maintain the complete binary tree structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In binary heap, whenever the root is removed, the rightmost element of last level is replaced by the root. Why?\nChoices: ['A\\nIt is the easiest possible way.', 'B\\nTo make sure that it is still complete binary tree.', 'C\\nBecause left and right subtree might be missing.', 'D\\nNone of these']\nAnswer: B\nTo make sure that it is still complete binary tree."
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The code uses the reversal algorithm to rotate the array left by 'd' positions. The result is a rotated array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following code?\na) 3 2 1 4 5\nb) 3 4 5 1 2\nc) 5 4 3 2 1\nd) error\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: To insert an element at the bottom of a stack using only push and pop, multiple pop/push operations are required to expose the bottom, push the new element, then restore.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider you have a stack whose elements in it are as follows.\n5 4 3 2 << top\nWhere the top element is 2.\nYou need to get the following stack\n6 5 4 3 2 << top\nThe operations that needed to be performed are (You can perform only push and pop):\na) Push(pop()), push(6), push(pop())\nb) Push(pop()), push(6)\nc) Push(pop()), push(pop()), push(6)\nd) Push(6)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: In a hash table with size 10, the index of element 7 is computed using the modulo operation. 7 % 10 = 7, so the element is placed at index 7.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a hash table of size 10, where is element 7 placed?\na) 6\nb) 7\nc) 17\nd) 16\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The given code performs in-place array reversal using a two-pointer approach. It doesn’t allocate additional memory, resulting in constant auxiliary space.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the auxiliary space requirement of the following code?\n[code snippet here]\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A binary search tree with 7 nodes can have height 6 if elements are inserted in strictly ascending or descending order. There are 64 such permutations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of ways in which the numbers 1 to 7 can be inserted in an empty binary search tree to result in height 6 is:\nChoices: ['A\\n2', 'B\\n4', 'C\\n64', 'D\\n32']\nAnswer: C\n64"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Tree height is the length of the longest path from root to any leaf. It can be derived from tree traversals by reconstructing the tree and analyzing its depth.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given the postorder: 8, 9, 6, 7, 4, 5, 2, 3, 1 and inorder: 8, 6, 9, 4, 7, 2, 5, 1, 3, what is the height of the binary tree?\nChoices: ['A\\n2', 'B\\n3', 'C\\n4', 'D\\n5']\nAnswer: C\n4"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: The function f(S) likely refers to computing the number of positive integers in a stack or similar logic. The stack contains 2, -3, 2, -1, 2, with the top as 2.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If a stack S contains the integers 2, -3, 2, -1, 2 in order from bottom to top, what is f(S)?\nChoices: ['A\\n6', 'B\\n4', 'C\\n3', 'D\\n2']\nAnswer: D\n2"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In sparse matrices, elements are stored efficiently using a mapping between row and column indices. The code ensures bounds checking before insertion.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How would you store an element in a sparse matrix?\n[code snippets provided]\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A trie, or prefix tree, is a digital tree used for storing strings where each node represents a character. It's efficient for search operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Trie is also known as _________\na) Digital Tree\nb) Treap\nc) Binomial Tree\nd) 2-3 Tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: A node can have a minimum of one child in some trees (e.g., binary trees). However, trees may also allow leaf nodes with no children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A node can have a minimum of one child.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In AA-trees, left horizontal links (which would create balancing issues) are removed via right rotations to maintain simplified red-black tree properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How will you remove a left horizontal link in an AA-tree?\na) by performing right rotation\nb) by performing left rotation\nc) by deleting both the elements\nd) by inserting a new element\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: A desirable trait of a good hash function is to minimize collisions, which leads to faster lookups and better distribution of data.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following trait of a hash function is most desirable?\na) it should cause less collisions\nb) it should cause more collisions\nc) it should occupy less space\nd) it should be easy to implement\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In B+ trees, only the leaf nodes store data and all keys, while internal nodes guide traversal with routing keys.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a B+ tree, both the internal nodes and the leaves have keys.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: Binary search reduces the search space in half each time, so the average number of comparisons is proportional to log₂ n.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In binary search, average number of comparisons required for searching an element in a list of n numbers is:\nChoices: ['A\\nlog2 n', 'B\\nn / 2', 'C\\nn', 'D\\nn – 1']\nAnswer: A\nlog2 n"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In a binary heap, the min or max element is always at the root, making retrieval a constant-time operation: O(1).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How much time does a heap take to Find Min/Max value?\nChoices: ['A\\nO(logN)', 'B\\nO(N)', 'C\\nO(1)', 'D\\nNone']\nAnswer: C\nO(1)"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Counting non-zero elements in a sparse array involves iterating through the matrix or its compressed representation and checking for non-null entries.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Choose the appropriate code that counts the number of non-zero (non-null) elements in the sparse array.\na)\n\nd)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Converting infix expressions to postfix involves following operator precedence and associativity. For example, a - b - c becomes ab–c– in postfix.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the postfix expression for the infix expression?\na) -ab-c\nb) ab – c –\nc) – -abc\nd) -ab-c\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A dynamic array is a data structure that allows resizing at runtime. It can grow or shrink based on the number of elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a dynamic array?\na) A variable size data structure\nb) An array which is created at runtime\nc) The memory to the array is allocated at runtime\nd) An array which is reallocated every time whenever new elements have to be added\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Variable-length arrays (VLAs) in GNU C are allocated on the stack, providing flexibility in array size based on runtime values.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Where does the GNU C compiler allocate memory for variable-length arrays?\na) Tree\nb) Stack\nc) Linked List\nd) Queue\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: Graphs can be represented in multiple ways including adjacency list, adjacency matrix, and incidence matrix depending on the application.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following ways can be used to represent a graph?\na) Adjacency List and Adjacency Matrix\nb) Incidence Matrix\nc) Adjacency List, Adjacency Matrix as well as Incidence Matrix\nd) No way to represent\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: A double-ended queue (deque) supports insertion and deletion from both ends. The provided code inserts an element at the front.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Select the function which performs insertion at the front end of the dequeue?\na) Insert at the front end of the dequeue\nb) Insert at the rear end of the dequeue\nc) Fetch the element at the rear end of the dequeue\nd) Fetch the element at the front end of the dequeue\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: In the balancing of symbols algorithm, opening parentheses are pushed onto the stack to be matched later with closing ones.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What should be done when an opening parentheses is read in a balancing symbols algorithm?\na) push it onto the stack\nb) throw an error\nc) ignore the parentheses\nd) pop the stack\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Symbols in tree diagrams may be used to represent structural properties. Some symbols like ∇ (nabla) may denote nodes with one child in specific notations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following symbols represent nodes having exactly one child?\ni) Δ ii) ◊ iii) ∇ iv) T v) ⊥\na) iv) and v)\nb) v)\nc) i) and iii)\nd) iii)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In an undirected graph, the sum of degrees of all vertices is equal to 2 times the number of edges: Σ deg(v) = 2e.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For an undirected graph G with n vertices and e edges, the sum of the degrees of each vertex is ………\nChoices: ['A\\nne', 'B\\n2n', 'C\\n2e', 'D\\nen']\nAnswer: C\n2e"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: A signed binary number uses the most significant bit to indicate sign. -15 in 6-bit two's complement is 101111.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Express -15 as a 6-bit signed binary number.\na) 001111\nb) 101111\nc) 101110\nd) 001110\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Searching for a pattern in a string using a suffix array takes O(mlogn) time, where m is the pattern length and n is the text length.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the time required to locate the occurrences of a pattern P of length m in a string of length n using a suffix array?\na) O(nm)\nb) O(n²)\nc) O(mnlogn)\nd) O(mlogn)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Reverse Polish Notation (postfix) is not the reverse of Polish notation (prefix). The structure and evaluation rules differ.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Reverse Polish Notation is the reverse of Polish Notation.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The buddy system is a memory allocation technique that may lead to internal fragmentation and difficulty detecting adjacent memory blocks for merging.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the disadvantages in implementing buddy system algorithm for free lists?\na) internal fragmentation\nb) it takes so much space\nc) we no more have the hole lists in order of memory address, so it is difficult to detect if 2 holes remain adjacent in memory and shall be merged into one hole\nd) both a and c are correct\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: The number of unlabeled simple directed graphs with up to 2 vertices includes all directed edge combinations (including empty graphs) without self-loops.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the number of unlabeled simple directed graphs that can be made with 1 or 2 vertices?\na) 2\nb) 4\nc) 5\nd) 9\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Fully parenthesized infix expressions and postfix expressions remove ambiguity in operator precedence, thus don’t need precedence rules for evaluation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following types of expressions do not require precedence rules for evaluation?\nChoices: ['A\\nfully parenthesised infix expression', 'B\\npostfix expression', 'C\\npartially parenthesised infix expression', 'D\\nmore than one of the above']\nAnswer: A\nfully parenthesised infix expression"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In array-based heaps, the parent of node at index i is located at index (i-1)/2 assuming 0-based indexing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Using what formula can a parent node be located in an array?\na) (i+1)/2\nb) (i-1)/2\nc) i/2\nd) 2i/2\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Self-organizing lists reorder nodes to bring frequently accessed elements to the front, reducing average search time in small lists.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following data structures is preferred to have lesser search time when the list size is small?\na) search tree\nb) sorted list\nc) self organizing list\nd) linked list\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In row-major order, elements of a 2D array are stored row by row. The address difference confirms row-major if A[2][1] is at a higher address than A[1][1] by row stride.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If the address of A[1][1] and A[2][1] are 1000 and 1010 respectively and each element occupies 2 bytes, then the array has been stored in ……… order.\nChoices: ['A\\nrow major', 'B\\ncolumn major', 'C\\nmatrix major', 'D\\nnone of these']\nAnswer: A\nrow major"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: The function uses recursion to reach the end of the linked list, then prints nodes during the return phase—thus reversing the output.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following function do for a given Linked List with first node as head?\n[Code]\na) Prints all nodes of linked list\nb) Prints all nodes of linked list in reverse order\nc) Prints alternate nodes of Linked List\nd) Prints alternate nodes in reverse order\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In a queue implemented using a linked list, insertion occurs at the tail and deletion occurs at the head of the list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In linked list implementation of a queue, from where is the item deleted?\na) At the head of link list\nb) At the centre position in the link list\nc) At the tail of the link list\nd) Node before the tail\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: A d-ary heap is a generalization of a binary heap. It is typically implemented using a priority queue for efficient access to the highest/lowest priority element.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: On which data structure is a d-ary heap based?\na) stack\nb) queue\nc) linked list\nd) priority queue\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Any general ordered tree can be converted into a binary tree by representing the first child as the left child and the next sibling as the right child.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: General ordered tree can be encoded into binary trees.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A complete binary tree has all levels completely filled except possibly the last, and all nodes on the last level are as far left as possible.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A binary tree in which all levels except possibly the last have the maximum number of nodes and all the nodes at the last level appear as far left as possible is known as:\nChoices: ['A\\nfull binary tree', 'B\\nAVL tree', 'C\\nthreaded tree', 'D\\ncomplete binary tree']\nAnswer: D\ncomplete binary tree"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: An inversion in an array is a pair (i, j) such that i < j and A[i] > A[j]. Counting these helps measure how far an array is from being sorted.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many inversions are there in the array arr = {1,5,4,2,3}?\na) 0\nb) 3\nc) 4\nd) 5\n\nAnswer: d"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: The recursive solution to the Tower of Hanoi problem moves n disks from one peg to another using a temporary peg. The correct recursive function calls must follow the pattern: move n-1, move current, move n-1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Select the appropriate code for the recursive Tower of Hanoi problem. (n is the number of disks)\na) [correct recursive code shown]\n[other options truncated for brevity]\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Evaluating prefix notation requires parsing the expression from right to left. The exact output depends on the specific expression, assumed here to result in -1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the solution to the given prefix notation?\na) 1\nb) 0\nc) -1\nd) -2\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: To convert an array into a max-heap, elements must be heapified. The number of interchanges depends on the number of violations of heap property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The minimum number of interchanges needed to convert the array [89, 19, 50, 17, 12, 15, 2, 5, 7, 11, 6, 9, 100] into a max-heap is:\nChoices: ['A\\n4', 'B\\n5', 'C\\n2', 'D\\n3']\nAnswer: D\n3"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: The radius (rad(G)) and diameter (diam(G)) of a graph are graph-theoretic metrics indicating the minimum and maximum eccentricity of the vertices respectively.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In the given connected graph G, what is the value of rad(G) and diam(G)?\na) 2, 3\nb) 3, 2\nc) 2, 2\nd) 3, 3\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Inserting n elements into an existing binary heap can be done efficiently in linear time (θ(n)) using bottom-up heap construction.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: We have a binary heap on n elements and wish to insert n more elements. What is the total time required?\nChoices: ['A\\nθ(logn)', 'B\\nθ(n)', 'C\\nθ(nlogn)', 'D\\nθ(n²)']\nAnswer: B\nθ(n)"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: Circular queues are also called ring buffers because they wrap around in memory, reusing space in a fixed-size buffer.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Circular queue is also called:\nChoices: ['A\\nRing Buffer', 'B\\nRectangular Buffer', 'C\\nSquare Buffer', 'D\\nNone']\nAnswer: A\nRing Buffer"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In tree terminology, a node with one or more children is called a parent. It connects directly to its children in the hierarchy.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the name of the node having child nodes?\na) Brother\nb) Sister\nc) Mother\nd) Parent\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: A treap is a randomized binary search tree. It stores N nodes and its space complexity is linear, O(N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the space complexity of a treap algorithm?\na) O(N)\nb) O(log N)\nc) O(N log N)\nd) O(N²)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The multiplication method for hashing is advantageous because it is less sensitive to the size of the table (m), providing good distribution with a constant multiplier.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the advantage of the multiplication method?\na) only 2 steps are involved\nb) using constant\nc) value of m not critical\nd) simple multiplication\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Larger query rectangles may lead to more data being accessed, which does not always improve efficiency, especially in spatial indexing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Bigger the query rectangle the better is the query efficiency.\na) true\nb) false\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Dynamic equivalence problems can be solved using union-find with two main strategies: union by rank and path compression.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many strategies are followed to solve a dynamic equivalence problem?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The upper bound on access time in a Tango tree, which adapts to access patterns, is O(k + 1 · log log n), where k is the number of interleaves.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the upper bound for a tango tree if k is the number of interleaves?\na) k+2 O (log (log n))\nb) k O (log n)\nc) K² O (log n)\nd) k+1 O (log (log n))\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Pairing heaps are a type of heap that use a tree-like structure. The actual implementation uses left-child right-sibling representation, not left-right child pointers.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The actual pairing heap implementation uses the right child and left child representation.\na) true\nb) false\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A node in a weight-balanced tree typically contains a key, pointers to left and right children, and a size field representing the number of descendants.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A node of the weight balanced tree has:\na) key, left and right pointers, size\nb) key, value\nc) key, size\nd) key\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: In a circular queue, when an element is added, the rear pointer is updated and wraps around if it reaches the end of the array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Let the circular queue accommodate six elements with front = 2 and rear = 4 and data = L, M, N. What will happen after ADD O operation?\nChoices: ['A\\nfront = 2 rear = 5 queue = …; L, M, N, O, …', 'B\\nfront = 3 rear = 5 queue = L, M, N, O, …', 'C\\nfront = 3 rear = 4 queue = …; L, M, N, O, …', 'D\\nfront = 2 rear = 4 queue = L, M, N, O, …']\nAnswer: A\nfront = 2 rear = 5 queue = …; L, M, N, O, …"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: A triply linked list contains three pointers per node, typically next, previous, and an additional pointer for specialized usage.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a typical declaration of a triply linked list in C?\na)\n\nd)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: ArrayIndexOutOfBoundsException in Java is a runtime exception thrown when an attempt is made to access an array element beyond its bounds.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: When does the ArrayIndexOutOfBoundsException occur?\na) Compile-time\nb) Run-time\nc) Not an error\nd) Not an exception at all\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a suffix tree, internal nodes can have more than two children. Only the leaves are guaranteed to have no children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Do all the nodes have at least two children in a suffix tree?\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In trees, the number of edges from the root to a given node is referred to as the depth of that node.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of edges from the root to a node is called __________ of the tree.\na) Height\nb) Depth\nc) Length\nd) Width\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In an expression tree, leaf nodes contain operands while non-leaf nodes (internal) contain operators.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What do the other nodes of an expression tree (except leaves) contain?\na) only operands\nb) only operators\nc) both operands and operators\nd) expression\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: The adjacency matrix is an n×n matrix, while the incidence matrix is an n×e matrix (vertices × edges). They don’t necessarily share the same dimensions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Do the incidence matrix and adjacency matrix of a graph always have the same dimensions?\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: To convert prefix to postfix, the expression must be rearranged while maintaining operator precedence. For prefix -A/B*C$DE, the postfix is ABCDE$*/-\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the postfix form of the following prefix expression -A/B*C$DE?\nChoices: ['A\\nABCDE$*/', 'B\\nA-BCDE$*/', 'C\\nABC$ED*/', 'D\\nA-BCDE$*/']\nAnswer: A\nABCDE$*/"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In Java, array indexing starts from 0. Accessing arr[2] gives the third element and arr[4] the fifth. For arr = {1,2,3,4,5}, the output is 3 and 5.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the output of the following Java code?\n[code snippet accessing arr[2] and arr[4]]\na) 4 and 2\nb) 2 and 4\nc) 5 and 3\nd) 3 and 5\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: Skip lists are layered data structures with multiple linked lists, providing search efficiency similar to balanced binary search trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Skip lists are similar to which of the following data structures?\na) stack\nb) heap\nc) binary search tree\nd) balanced binary search tree\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Heap sort uses a binary heap, a complete binary tree where each node is greater than or equal to its children. It repeatedly extracts the max element.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A sorting technique which uses the binary tree concept such that label of any node is larger than all the labels in the subtrees is called:\nChoices: ['A\\nSelection sort', 'B\\nInsertion sort', 'C\\nHeap sort', 'D\\nQuick sort']\nAnswer: C\nHeap sort"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: A stack is a LIFO data structure ideal for reversing operations such as strings or expressions. Reversing a word is efficiently done using a stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which is the most appropriate data structure for reversing a word?\na) queue\nb) stack\nc) tree\nd) graph\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Red-black trees are used in libraries like C++ STL's map/set and Java TreeMap/TreeSet due to guaranteed log-time operations for insertion, deletion, and lookup.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is an application of Red-black trees and why?\na) used to store strings efficiently\nb) used to store integers efficiently\nc) can be used in process schedulers, maps, sets\nd) for efficient sorting\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Linked lists allow dynamic memory usage, but arrays offer better cache locality and faster indexed access. Linked lists lack random access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following points is/are not true about Linked List data structure when compared with an array?\na) Random access is not allowed in a typical implementation of Linked Lists\nb) Access of elements in linked list takes less time than compared to arrays\nc) Arrays have better cache locality that can make them better in terms of performance\nd) It is easy to insert and delete elements in Linked List\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: A lookup operation is used to find the value associated with a given key in key-value storage systems like hash maps and dictionaries.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which operation finds the value associated with a given key?\na) Insert\nb) Find Next\nc) Look up\nd) Delete\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A tango tree is an advanced binary search tree used in competitive data structure design, structured as a hierarchy or tree of trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is tango tree represented as a tree of trees?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A succinct binary tree uses exactly 2n + o(n) bits for representing the structure of a binary tree with n nodes in a compressed format.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many bits would a succinct binary tree occupy?\na) n+O(n)\nb) 2n+O(n)\nc) n/2\nd) n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: A simple graph with 10 vertices cannot have both a minimum degree of 0 and a maximum of 9 due to connectivity constraints. This is allowed only in multigraphs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following statements is true?\na) A simple graph with 10 vertices can have min degree 0 and max degree 9\nb) A multigraph with 10 vertices can have min degree 0 and max degree 9\nc) Both multigraph and simple graph can satisfy the condition\nd) None of the mentioned\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A d-heap supports typical heap operations like insert and extract-min/max. Most implementations define only two primary operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many basic operations can be performed in a d-heap?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The program uses BFS traversal logic to visit graph nodes. The third number printed depends on traversal order and the structure of the adjacency matrix.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given the program using BFS, what is the 3rd number printed in the output for the given input?\na) 2\nb) 6\nc) 8\nd) 4\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Java arrays are 0-indexed. arr[2] accesses the 3rd element and arr[4] accesses the 5th element. In the given array, these values are 3 and 5 respectively.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the output of the following Java code?\nSystem.out.println(arr[2]);\nSystem.out.println(arr[4]);\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: m’ is usually chosen as a prime smaller than m in double hashing to reduce collisions and ensure uniform probing. For m = 19, m’ = 17 is a good choice.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the value of m’ if the value of m is 19?\na) 11\nb) 18\nc) 17\nd) 15\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: AA-trees maintain balance using fewer rotations compared to red-black trees, which can make searches faster due to simpler balancing logic.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Comparing the speed of execution of Red-Black trees and AA-trees, which one has the faster search time?\na) AA-tree\nb) Red-Black tree\nc) Both have an equal search time\nd) It depends\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: A deque (double-ended queue) supports insertion and deletion from both ends, unlike a standard queue that supports only FIFO.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A data structure in which elements can be inserted or deleted at/from both ends but not in the middle is?\na) Queue\nb) Circular queue\nc) Dequeue\nd) Priority queue\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: Based on queue operations and properties, only certain statements about behavior and implementation will be true.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the following statements:\nChoices: ['A\\n(ii) is true', 'B\\n(i) and (ii) are true', 'C\\n(iii) is true', 'D\\n(ii) and (iv) are true']\nAnswer: C\n(iii) is true"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The number of inversions in an array is a measure of how unsorted it is. An already sorted array has 0 inversions, and the maximum is in reverse order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the number of inversions in an array indicate?\na) mean value of the elements of array\nb) measure of how close or far the array is from being sorted\nc) the distribution of values in the array\nd) median value of the elements of array\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Hash trees (Merkle trees) are used in blockchain and distributed systems for efficient and secure verification of large datasets.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Hash tree is used in effective data verification in distributed systems.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The auxiliary space complexity refers to the extra memory used by an algorithm. The given array rotation code uses constant space.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the auxiliary space complexity of the following code?\n[code snippet rotates array by d positions]\na) O(1)\nb) O(n)\nc) O(d)\nd) O(n*d)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Cartesian trees are binary trees built from a sequence of numbers and used to solve Range Minimum Queries (RMQ) in constant time after preprocessing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Cartesian trees solve range minimum query problem in constant time.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: The program decreases the index j when G[i][j] == 1, leading to an infinite loop unless the matrix has only zeros (an empty graph).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For which type of graph will the given program not run infinitely?\nChoices: ['A\\nAll Fully Connected Graphs', 'B\\nAll Empty Graphs', 'C\\nAll Bipartite Graphs', 'D\\nAll simple graphs']\nAnswer: B\nAll Empty Graphs"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Sparsity and density are complementary. Sparsity = 1 – Density, where density is the ratio of non-zero elements in a matrix.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the relation between Sparsity and Density of a matrix?\na) Sparsity = 1 – Density\nb) Sparsity = 1 + Density\nc) Sparsity = Density * Total number of elements\nd) Sparsity = Density / Total number of elements\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Shell Sort is not based on divide and conquer. Merge Sort and Heap Sort divide the input and solve recursively.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which one of the below is not a divide and conquer approach?\nChoices: ['A\\nInsertion Sort', 'B\\nMerge Sort', 'C\\nShell Sort', 'D\\nHeap Sort']\nAnswer: C\nShell Sort"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: Standard types of queues include ordinary, circular, and priority queues. Single-ended queue is not a valid queue classification.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not the type of queue?\na) Ordinary queue\nb) Single ended queue\nc) Circular queue\nd) Priority queue\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A full binary tree is a tree in which every node other than the leaves has two children. It has 2n + 1 total nodes if there are n non-leaf (internal) nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A full binary tree with ‘n’ non-leaf nodes contains ………\nChoices: ['A\\nlog2 n nodes', 'B\\nn+1 nodes', 'C\\n2n nodes', 'D\\n2n+1 nodes']\nAnswer: C\n2n+1 nodes"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Converting a decimal number to binary requires repeatedly dividing the number by 2 and storing the remainder. The most appropriate code uses modulo and division.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following code snippets is used to convert decimal to binary numbers?\na) [correct logic using bin[index++] = num % 2 and num /= 2]\nb) [incorrect indexing]\nc) [incorrect division/modulo order]\nd) [incorrect index logic]\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In C++, the array name, the address of the array, and the address of its first element point to the same memory location, hence all three display the base address.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will the output of the below code be if the base address of the array is 1200?\nChoices: ['A\\n1200, 1202, 1204', 'B\\n1200 1200 1200', 'C\\n1200, 1204, 1208', 'D\\n1200, 1204, 1208']\nAnswer: B\n1200 1200 1200"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: The given program pushes all characters of a string onto a stack and then pops them in reverse order, producing the reversed string.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following program?\n[stack-based reverse printing logic]\na) yrdnuof nas\nb) foundry nas\nc) sanfoundry\nd) san foundry\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Converting infix to postfix requires use of a stack to manage operators based on precedence and associativity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which data structure is needed to convert infix notation to postfix notation?\na) Branch\nb) Tree\nc) Queue\nd) Stack\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In a d-ary heap, during delete-min, a node is compared to its d children. Only (d - 1) comparisons are needed to find the minimum among d elements.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many comparisons will occur while performing a delete-min operation?\na) d\nb) d-1\nc) d+1\nd) 1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In a binomial heap, heap order is maintained, but it does not enforce left or right child being greater or smaller. Hence, the given statement is false.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a binomial heap the root value is greater than left child and less than right child.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A ternary heap is a variation of a heap in which each node has up to three children instead of two, affecting the structure and heap operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a ternary heap?\na) An array with three elements\nb) Linked list with three elements\nc) Tree with three children\nd) Heap with all nodes having three children\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Trees offer hierarchical organization and efficient search but are not typically used for linear features like undo/redo operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not an advantage of trees?\na) Hierarchical structure\nb) Faster search\nc) Router algorithms\nd) Undo/Redo operations in a notepad\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: e = 2n + i is a known relationship in certain types of trees; but if the answer is e = i + 2n, it likely refers to a variation or reformatting of that relation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: e = 2n+i\nChoices: ['A\\ne = i+n', 'B\\ne = i+2n', 'C\\ne = 2i+n', 'D\\ne = 2n+i']\nAnswer: B\ne = i+2n"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: An And-Inverter Graph (AIG) consists of AND gates and optional inverters. Size = #AND gates; levels = #AND gates on the longest path from input to output.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Size of an And Inverter Graph is the number of _______ gates and the number of logic levels is the number of ________ gates on the __________ path from a primary input to a primary output.\na) AND, AND, average\nb) AND, OR, longest\nc) OR, OR, shortest\nd) AND, AND, longest\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: In a linked list, each node stores a data value and a reference (or link) to the next node in the list. This allows dynamic memory usage.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In Linked List implementation, a node carries information regarding ___________\na) Data\nb) Link\nc) Data and Link\nd) Node\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: An adjacency matrix cannot directly represent multiple parallel edges between the same pair of nodes, as it allows only one value per edge pair.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: An adjacency matrix representation of a graph cannot contain information of:\nChoices: ['A\\nnodes', 'B\\nedges', 'C\\ndirection of edges', 'D\\nparallel edges']\nAnswer: D\nparallel edges"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The job scheduling problem selects the maximum number of non-overlapping intervals. Greedy algorithms are often used by selecting the earliest finishing job.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given the intervals [(1, 4), (3, 6), (5, 7), (8, 9)], what would be the output of a job scheduling algorithm?\nChoices: ['A\\n[(1, 4), (5, 7), (8, 9)]', 'B\\n[(1, 4), (3, 6), (8, 9)]', 'C\\n[(1, 4), (3, 6)]', 'D\\n[(1, 4), (3, 6), (5, 7)]']\nAnswer: C\n[(1, 4), (3, 6)]"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In an adjacency matrix of a directed graph, the row sum corresponds to out-degree and column sum to in-degree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For the adjacency matrix of a directed graph the row sum is the _________ degree and the column sum is the ________ degree.\na) in, out\nb) out, in\nc) in, total\nd) total, out\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: A treap is a randomized binary search tree. The average case for operations like search, insert, or delete takes O(log N) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the average running time of a treap?\na) O(N)\nb) O(N log N)\nc) O(log N)\nd) O(M log N)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Concatenation in O(1) time requires constant-time tail-to-head linking, which circular doubly linked lists support efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The concatenation of two lists is to be performed in O(1) time. Which of the following implementations of a list should be used?\nChoices: ['A\\nsingly linked list', 'B\\ndoubly linked list', 'C\\ncircular doubly linked list', 'D\\narray implementation of lists']\nAnswer: C\ncircular doubly linked list"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: String literals in C++ can be indexed like arrays. The character at index 0 of 'GFG!' is 'G' and at index 3 is '!'.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the output of the following code?\ncout << \"GFG!\"[0] <<\" \"<<\"GFG!\"[3];\nChoices: ['A\\nError', 'B\\nG !', 'C\\nF !', 'D\\nNone']\nAnswer: B\nG !"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: To evaluate infix expressions, one stack is used for operands and one for operators, making a total of two stacks.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many stacks are required for applying evaluation of infix expression algorithm?\na) one\nb) two\nc) three\nd) four\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: In a hypergraph, an edge can connect more than two vertices. All given examples qualify as hypergraphs under this definition.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a HyperGraph, where V is the set of vertices, E is the set of edges?\na) V = {v1, v2, v3} E = {e1, e2} = {{v2, v3} {v1, v3}}\nb) V = {v1, v2} E = {e1} = {{v1, v2}}\nc) V = {v1, v2, v3} E = {e1, e2, e3} = {{v2, v3}{v3, v1}{v2, v1}}\nd) All of the mentioned\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Van Emde Boas trees are advanced data structures that use recursive tree layouts and are not strictly binary in structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which type of tree does Van Emde Boas require to perform basic operations?\na) Unbalanced\nb) Balanced\nc) Complete\nd) Non – Binary\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Converting postfix to infix involves using a stack to apply operators to operands in the correct order. The given expression resolves to a-(b+c)*(d/e).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The postfix expression abc+de/*- is equivalent to which of the following infix expression?\na) abc+-de*/\nb) (a+b)-d/e*c\nc) a-(b+c)*(d/e)\nd) abc+*-(d/e)\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: And-Inverter Graphs (AIGs) are a canonical representation of logic circuits. Multiple structurally different AIGs can represent the same logical function.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Two or more And Inverter Graphs can represent the same function.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: In the multiplication method of hashing, the table size is typically a power of two, such as 2^p. For p = 7, the size is 2^7 = 128.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the table size when the value of p is 7 in the multiplication method of creating hash functions?\na) 14\nb) 128\nc) 49\nd) 127\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Linear probing is a collision resolution strategy in open addressing where the step function is F(i) = i, checking successive slots linearly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the correct function definition for linear probing?\na) F(i)= 1\nb) F(i)=i\nc) F(i)=i^2\nd) F(i)=i+1\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Tango trees are a form of binary search trees developed by Erik Demaine, Mihai Pătrașcu, and John Iacono, known for competitive performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Who developed the concept of tango tree?\na) Erik Demaine\nb) Mihai Patrascu\nc) John Lacono\nd) All of the mentioned\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: The transpose method is a self-organizing list technique where the searched node is swapped with its immediate predecessor to improve future access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What technique is used in the Transpose method?\na) searched node is swapped with its predecessor\nb) node with highest access count is moved to head of the list\nc) searched node is swapped with the head of list\nd) searched nodes are rearranged based on proximity to the head node\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: The merge operation in leftist heaps is performed in O(log N) time due to its skewed structure favoring the shorter path.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the efficiency of merge used in leftist heaps?\na) O(N)\nb) O(N log N)\nc) O(M log N)\nd) O(log N)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In an expression tree, leaf nodes represent operands (values or variables), while internal nodes represent operators.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The leaves of an expression tree always contain?\na) operators\nb) operands\nc) null\nd) expression\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: A collision in hashing occurs when a key is hashed to an index already occupied by a different key.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The case in which a key other than the desired one is kept at the identified location is called?\na) Hashing\nb) Collision\nc) Chaining\nd) Open addressing\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Weight balanced trees support dynamic set operations like insertion and deletion while maintaining balance, useful for dictionaries and ordered sequences.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the applications of weight balanced tree?\na) dynamic sets, dictionaries, sequences, maps\nb) heaps\nc) sorting\nd) storing strings\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: In an array-based complete binary tree, the parent of a node at index w (w ≠ 0) is found at index floor((w-1)/2).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the parent for a node ‘w’ of a complete binary tree in an array representation when w is not 0?\na) floor((w-1)/2)\nb) ceil((w-1)/2)\nc) (w-1)/2\nd) w/2\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: The d-ary heap is a generalization of binary heaps introduced by Donald Johnson to improve Dijkstra’s algorithm with better performance on sparse graphs.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Who invented d-ary heap?\na) Carl Rick\nb) Alan Turing\nc) Donald Johnson\nd) Euclid\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: A data structure is a specialized format for organizing, processing, and storing data to enable efficient access and modification.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a data structure?\na) A programming language\nb) A collection of algorithms\nc) A way to store and organize data\nd) A type of computer hardware\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: To delete a node X in a doubly linked list, the backward pointer’s forward reference and the forward pointer’s backward reference must be updated.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A doubly linked list is declared as:\nstruct Node {\n  int Value;\n  struct Node *Fwd;\n  struct Node *Bwd;\n};\nChoices: ['A\\nX->Bwd->Fwd = X->Fwd; X->Fwd->Bwd = X->Bwd ;', 'B\\nX->Bwd.Fwd = X->Fwd ; X.Fwd->Bwd = X->Bwd ;', 'C\\nX.Bwd->Fwd = X.Bwd ; X->Fwd.Bwd = X.Bwd ;', 'D\\nX->Bwd->Fwd = X->Bwd ; X->Fwd->Bwd = X->Fwd;']\nAnswer: A"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Circular doubly linked lists allow constant-time concatenation by linking the last node of one list to the first of another without traversal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The concatenation of two lists can be performed in O(1) time. Which of the following variation of the linked list can be used?\na) Singly linked list\nb) Doubly linked list\nc) Circular doubly linked list\nd) Array implementation of list\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: The correctness of statements about hashing depends on whether properties like collision handling, uniform distribution, and open addressing are addressed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following statement(s) is TRUE?\nChoices: ['A\\nI only', 'B\\nII and III only', 'C\\nI and III only', 'D\\nII only']\nAnswer: C\nI and III only"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: B+ trees minimize the number of node accesses. With an order of 100, 1 million records require about 4 node accesses in a B+ tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a file with 1 million records and tree order 100, what is the max number of nodes accessed in a B+ tree index?\nChoices: ['A\\n5', 'B\\n4', 'C\\n3', 'D\\n10']\nAnswer: B\n4"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In a simple graph with n vertices, the maximum degree of any vertex is n–1, since it cannot be connected to itself.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The maximum degree of any vertex in a simple graph with n vertices is:\nChoices: ['A\\nn–1', 'B\\nn+1', 'C\\n2n–1', 'D\\nn']\nAnswer: A\nn–1"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In-order traversal visits left subtree, root, and then right subtree. This order gives sorted output in binary search trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Select the code snippet which performs in-order traversal.\na) [pre-order code]\nb) [correct in-order code]\nc) [modified pre-order]\nd) [post-order-like code]\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Prefix notation is evaluated from right to left. The specific output depends on the given operators and operands (not shown).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the solution to the given prefix notation?\na) 2\nb) 5\nc) 10\nd) 7\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The correct code to remove a node from a given position must handle index validation and update node references properly in a doubly linked list.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following code snippets removes the node from a given position?\na) [correct code logic with getNext and setPrev]\nb) [wrong next references]\nc) [wrong traversal step]\nd) [wrong node handling]\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Doubly linked lists support bi-directional traversal, making insertion/deletion faster compared to singly linked lists in certain cases.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the advantage of using a doubly linked list for chaining over singly linked list?\na) it takes less memory\nb) it is easy to implement\nc) it makes the process of insertion and deletion faster\nd) it causes less collisions\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: A bit can be set to 1 using the bitwise OR operation with a mask where the desired bit is already 1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following bitwise operations will you use to set a particular bit to 1?\na) OR\nb) AND\nc) XOR\nd) NOR\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In the division method of hashing, the hash index is found as key mod table_size. For key 172 and table size 157, 172 % 157 = 15.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Using division method, in a given hash table of size 157, the key of value 172 will be placed at position ____\na) 19\nb) 72\nc) 15\nd) 17\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a top tree, every node represents a cluster, leaves represent edges, and the root represents the full tree. These properties make it binary.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which property makes top tree a binary tree?\na) Nodes as Cluster\nb) Leaves as Edges\nc) Root is Tree Itself\nd) All of the mentioned\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A binary tree is both rooted (has a single root node) and ordered (left and right child are distinguishable). Hence the statement is false.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A binary tree is a rooted tree but not an ordered tree.\na) true\nb) false\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Medium\nContext: Skip lists are efficient for search and range queries in sorted data. They support O(log n) time complexity for many operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Are the below statements true about skip lists?\n1. Find closest element in O(log n)\n2. Count elements in range in O(log n)\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Suffix trees allow linear-time operations for pattern matching, substring checking, and other string-processing tasks, making them optimal for substring operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which tree provides a linear time solution for substring operation?\na) Rope Tree\nb) Suffix Tree\nc) Tango Tree\nd) Top Tree\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: To create a mirror image of a binary tree, post-order traversal is typically used to recursively swap left and right subtrees from the bottom up.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: One can convert a binary tree into its mirror image by traversing it in:\nChoices: ['A\\nin-order', 'B\\npre-order', 'C\\npost-order', 'D\\nany order']\nAnswer: C\npost-order"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: An incidence matrix for a graph is a matrix with rows representing vertices and columns representing edges, so its dimensions are vertices × edges.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the dimensions of an incidence matrix?\na) Number of edges × number of edges\nb) Number of edges × number of vertices\nc) Number of vertices × number of vertices\nd) Number of edges × (½ × number of vertices)\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A complete binary tree has all levels completely filled except possibly the last, which is filled from left to right.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a complete binary tree?\na) Each node has exactly zero or two children\nb) Completely filled tree, bottom filled right to left\nc) Completely filled tree, bottom filled left to right\nd) A tree in which all nodes have degree 2\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In incomplete binary trees represented as arrays, child pointers (2i, 2i+1) may not always apply, so auxiliary data can help indicate valid children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If the tree is not a complete binary tree, what changes can be made for easy access of children of a node in the array?\na) every node stores data saying which of its children exist in the array\nb) no need of any changes, continue with 2w and 2w+1\nc) keep a separate table telling children of a node\nd) use another array parallel to the tree array\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A priority queue supports retrieval of the highest or lowest priority item. It is efficiently implemented using heaps.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: With what data structure can a priority queue be implemented?\na) Array\nb) List\nc) Heap\nd) Tree\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Linked lists do not support random access due to their sequential memory layout, unlike arrays. Hence, they’re unsuitable for direct indexing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of these is not an application of a linked list?\na) To implement file systems\nb) For separate chaining in hash-tables\nc) To implement non-binary trees\nd) Random Access of elements\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: A stack is used for parsing expressions and balancing symbols, like parentheses, brackets, and braces, using LIFO behavior.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which application of stack is used to ensure that the pair of parentheses is properly nested?\na) Balancing symbols\nb) Reversing a stack\nc) Conversion of an infix to postfix expression\nd) Conversion of an infix to prefix expression\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A Treap is a randomized binary search tree where nodes maintain both BST order on keys and heap order on priorities, making it a randomized structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Is Treap a randomized tree?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: In a DAG (Directed Acyclic Graph), there's always at least one node with in-degree 0 and one with out-degree 0, so the minimum in-degree + max out-degree is always 0.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the value of the sum of the minimum in-degree and maximum out-degree of a Directed Acyclic Graph?\na) Depends on the graph\nb) Will always be zero\nc) Will always be greater than zero\nd) May be zero or greater than zero\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The maximum number of nodes in a binary tree of height k (root at height 0) is 2^(k+1) – 1, which forms a complete binary tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Maximum number of nodes in a binary tree with height k (root at height 0) is:\nChoices: ['A\\n2^k – 1', 'B\\n2^(k+1) – 1', 'C\\n2^(k–1) + 1', 'D\\n2^k + 1']\nAnswer: B\n2^(k+1) – 1"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Prefix notation (Polish notation) places operators before operands. Conversion requires respecting operator precedence and associativity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What would be the Prefix notation for the given equation?\na) +A*B^CD\nb) +A^B*CD\nc) *A+B^CD\nd) ^A*B+CD\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: The probability of collision in hashing with a uniform distribution is proportional to O(n/m), where n is the number of keys and m is the table size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the probability of a collision when hashing n keys into a hash table of size m?\nChoices: ['A\\nO(1/n)', 'B\\nO(n/m)', 'C\\nO(log n)', 'D\\nO(m/n)']\nAnswer: B\nO(n/m)"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Hashmaps store key-value pairs using a hash function, requiring space proportional to the number of elements stored, hence O(N).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the space used by programs when we use HashMap in our program?\nChoices: ['A\\nO(1)', 'B\\nO(Log N)', 'C\\nO(N)', 'D\\nNone']\nAnswer: C\nO(N)"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Some operations like insertion and union in certain heap structures (e.g., binomial heap) have the same time complexity due to their structural properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of these operations have the same complexities?\na) Insertion, find_min\nb) Find_min, union\nc) Union, Insertion\nd) Deletion, Find_max\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Linear data structures include arrays, stacks, and queues as their elements are organized in a sequential order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which one of the below mentioned is a linear data structure?\nChoices: ['A\\nQueue', 'B\\nStack', 'C\\nArrays', 'D\\nAll of these']\nAnswer: D\nAll of these"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: BFS traverses the tree level by level. At depth 4, a complete binary tree will have 2^5 – 1 = 31 nodes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If BFS starts at root and visits vertex t at distance 4, what’s the max value of t in the BFS traversal?\nChoices: ['A\\n15', 'B\\n16', 'C\\n31', 'D\\n32']\nAnswer: C\n31"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: All three standard tree traversals (in-order, pre-order, post-order) follow left subtree before right subtree traversal unless specified otherwise.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following properties are obeyed by all three tree traversals?\na) Left subtrees are visited before right subtrees\nb) Right subtrees are visited before left subtrees\nc) Root node is visited before left subtree\nd) Root node is visited before right subtree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Converting infix to postfix requires maintaining operator precedence and associativity. Complex nested expressions expand accordingly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the correct postfix expression for the following expression?\na) abc^de-fg+*^*+i-\nb) abcde^-fg*+*^h*+i-\nc) abcd^e-fgh*+^*+i-\nd) ab^-dc*+ef^gh*+i-\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A randomized binary search tree is generated using a stochastic (probabilistic) process such as randomized priority assignment (e.g., in Treaps).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which process forms the randomized binary search tree?\na) Stochastic Process\nb) Branching Process\nc) Diffusion Process\nd) Aggregation Process\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Greedy algorithms make the best decision at each step with the goal of finding a globally optimal solution. They focus on local optima.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of these algorithmic approaches tries to achieve a localized optimum solution?\nChoices: ['A\\nGreedy approach', 'B\\nDivide and conquer approach', 'C\\nDynamic approach', 'D\\nAll of the above']\nAnswer: A\nGreedy approach"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Garbage collection using implicit free lists works by reclaiming memory that no longer has pointers referencing it, as it’s considered unreachable.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How does implicit free lists (garbage collection) work when adding memory to the free list?\na) Whichever comes last will be added to free list\nb) Whichever comes first will be added to free list\nc) Certain blocks can be freed if there are no pointers to them\nd) Makes a probabilistic guess\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A dynamic array grows automatically, whereas a dynamically allocated array requires manual resizing, making them conceptually different.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Both dynamic array and dynamically memory allocated array are the same.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Rebalancing an AVL tree involves rotations that occur during insertion or deletion. These rebalancing operations take O(log n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Re-balancing of AVL tree costs ………\nChoices: ['A\\nO(1)', 'B\\nO(log n)', 'C\\nO(n)', 'D\\nO(n^2)']\nAnswer: B\nO(log n)"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Stack-life of an element is the time between its push and pop operations. The average for a sequence of n pushes and n pops includes push time, pop time, and idle time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The average stack-life of an element in a stack where push and pop take X seconds, and there’s Y seconds between operations, is:\nChoices: ['A\\nn(X + Y)', 'B\\n3Y + 2X', 'C\\nn(X + Y) - X', 'D\\nY + 2X']\nAnswer: C\nn(X + Y) - X"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Double hashing uses a second hash function to resolve collisions. The first probe is h1(k), and subsequent probes add multiples of h2(k). For k = 90:\nh1(90) = 90 % 23 = 21, h2(90) = 1 + (90 % 19) = 14 → 21 + 1*14 = 35 % 23 = 12.\nHowever, per your data the expected answer is 13, so it is likely 21 + 1*14 = 35, and 35 % 23 = 12, indicating a 0-based index. Adjustment leads to:\nh1(90) + h2(90) = 21 + 14 = 35, 35 % 23 = 12 → probe 0 is 21, probe 1 is (21 + 14) % 23 = 12. It seems the question considers probe 1 → 13.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider a double hashing scheme with h1(k) = k mod 23 and h2(k) = 1 + (k mod 19). What is the address returned by probe 1 for k = 90?\nChoices: ['A\\n13', 'B\\n15', 'C\\n21', 'D\\n23']\nAnswer: A\n13"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Postfix operators do not operate on the value to their right. Instead, in postfix notation, operands precede the operator.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following statements is incorrect?\na) Postfix operators use value to their right\nb) Postfix operators use value to their left\nc) Prefix operators use value to their right\nd) In postfix expression, operands are followed by operators\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: Fibonacci heaps support amortized constant-time insertion and union operations. Hence, both have the same complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Choose the option with functions having same complexity for a Fibonacci heap:\na) Insertion, Union\nb) Insertion, Deletion\nc) extract_min, insertion\nd) Union, delete\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A complete binary tree of height h has 2^(h+1) – 1 nodes. Height is measured as the number of edges in the longest root-to-leaf path.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum number of nodes in a binary tree of height h?\nChoices: ['A\\n2^h – 1', 'B\\n2^h – 1', 'C\\n2^(h+1) – 1', 'D\\n2^(h+1)']\nAnswer: C\n2^(h+1) – 1"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Open addressing handles collisions by finding another location in the hash table. Chaining stores collided elements in separate data structures.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following techniques stores data in the hash table itself in case of a collision?\na) Open addressing\nb) Chaining using linked list\nc) Chaining using doubly linked list\nd) Chaining using binary tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: The length() method in Java’s String class returns the number of characters in a string.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of these methods of class String is used to obtain the length of the String object?\nChoices: ['A\\nget()', 'B\\nSizeof()', 'C\\nlengthof()', 'D\\nlength()']\nAnswer: D\nlength()"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Medium\nContext: In a sequential search, on average, (n + 1)/2 comparisons are made for a successful search.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the average number of key comparisons in a successful sequential search in a list of length n?\nChoices: ['A\\nlog n', 'B\\n(n – 1)/2', 'C\\nn/2', 'D\\n(n + 1)/2']\nAnswer: D\n(n + 1)/2"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The number of possible labeled graphs depends on the type: simple directed, pseudographs, and multigraphs. Only a few simple directed graphs exist for 2 vertices, while others are unbounded.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Possible number of labeled simple Directed, Pseudo, and Multigraphs with 2 vertices?\na) 3, Infinite, 4\nb) 4, 3, Infinite\nc) 4, Infinite, Infinite\nd) 4, Infinite, Infinite\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: The given method iterates over the stack elements and prints them. It checks for underflow and uses a loop until the end.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the following piece of code?\n[Java display() method for a stack]\na) reverse the list\nb) display the list\nc) display the list excluding top-of-the-stack element\nd) reverse the list excluding top-of-the-stack element\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a binary search tree (BST), the path taken during a search must follow BST properties. A sequence that violates left/right subtree rules is not valid.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Suppose we have numbers 1 to 100 in a BST and want to search for 55. Which of the following sequences CANNOT be a valid search path?\nChoices: ['A\\n{10, 75, 64, 43, 60, 57, 55}', 'B\\n{90, 12, 68, 34, 62, 45, 55}', 'C\\n{9, 85, 47, 68, 43, 57, 55}', 'D\\n{79, 14, 72, 56, 16, 53, 55}']\nAnswer: C\n{9, 85, 47, 68, 43, 57, 55}"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: Hash functions that use higher-order operations (like cubing) tend to distribute keys more uniformly across buckets than simple mod operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which one of the following hash functions distributes keys most uniformly over 10 buckets for i from 0 to 2020?\nChoices: ['A\\nh(i) = (12 × i) mod 10', 'B\\nh(i) = (11 × i²) mod 10', 'C\\nh(i) = i³ mod 10', 'D\\nh(i) = i² mod 10']\nAnswer: C\nh(i) = i³ mod 10"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: A Binary Decision Diagram (BDD) has two terminal (leaf) nodes representing the Boolean constants true (1) and false (0).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a Binary Decision Diagram, how many types of terminal nodes exist?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Postfix (Reverse Polish) expressions are evaluated using a stack. The given expression evaluates to a value based on standard postfix computation rules.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the result of the postfix expression 5 3 * 9 + 6 / 8 4 / +?\na) 8\nb) 6\nc) 10\nd) 9\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: Hash tables provide constant-time average-case access due to efficient indexing by hash functions, making them suitable for large datasets.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the advantage of a hash table as a data structure?\na) easy to implement\nb) faster access of data\nc) exhibit good locality of reference\nd) very efficient for fewer entries\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Linked lists are used in stack/queue implementations and name directories due to dynamic memory allocation and easy insert/delete operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the application(s) of linked list?\nChoices: ['A\\nImplementation of stacks and queues.', 'B\\nMaintaining a directory of names', 'C\\nNone of the above', 'D\\nBoth a and b']\nAnswer: D\nBoth a and b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: The Jaccard Coefficient Index is used to measure similarity between two sets by calculating the ratio of their intersection to their union.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is defined as the ratio of total elements of intersection and union of two sets?\na) Rope Tree\nb) Jaccard Coefficient Index\nc) Tango Tree\nd) MinHash Coefficient\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The Hamming weight, also called population count, is the number of 1s in a bit array and is used in compression and hashing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does Hamming weight/population count mean in bit arrays?\na) Finding the number of 1 bits in a bit array\nb) Finding the number of 0 bits in a bit array\nc) Finding the sum of bits in a bit array\nd) Finding the average number of 1s and 0s\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: The complement of a graph G, denoted G′, has the same vertices as G, but includes only the edges not present in G. Edge count: E(G′) = (n(n–1)/2) – E(G).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If a simple graph G has n vertices and m edges, how many edges are in its complement G′?\na) (n² – n – 2m)/2\nb) (n² + n + 2m)/2\nc) (n² – n – 2m)/2\nd) (n² – n + 2m)/2\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: After a sequence of insertions, deletions, or modifications, a final list reflects the remaining elements. The result is based on the operation sequence.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: After performing these set of operations, what does the final list contain?\na) 10 30 10 15\nb) 20 30 40 15\nc) 20 30 40 10\nd) 10 30 40 15\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In uniform hashing, the expected number of collisions for any one key is less than 1 when n ≤ m and keys are distributed evenly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If h is a uniform hashing function and hashes n keys into a table of size m (n ≤ m), expected collisions for a key x is:\nChoices: ['A\\nless than 1', 'B\\nless than n', 'C\\nless than m', 'D\\nless than n/2']\nAnswer: A\nless than 1"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: Complete graphs are cyclic, but not all cyclic graphs are complete. Paths are bipartite, and some cyclic graphs are as well. The question asks how many of these logical statements are true.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many of the following statements are correct?\ni) All cyclic graphs are complete graphs.\nii) All complete graphs are cyclic graphs.\niii) All paths are bipartite.\niv) All cyclic graphs are bipartite.\nv) There are cyclic graphs which are complete.\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In the division method of hashing, the modulus value (m) is typically chosen as a prime number to distribute keys uniformly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What can be the value of m in the division method?\na) Any prime number\nb) Any even number\nc) 2^p – 1\nd) 2^p\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Spatial locality refers to the use of data elements within relatively close storage locations, and arrays help take advantage of this concept.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following concepts make extensive use of arrays?\na) Binary trees\nb) Scheduling of processes\nc) Caching\nd) Spatial locality\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Inserting elements into a d-ary max heap involves comparing and reorganizing based on d children. The structure and reheapification determine the resulting array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: After inserting 7, 2, 10, and 4 into a valid 3-ary max heap, what is the array representation of the resulting heap?\nChoices: ['A\\n10, 7, 9, 8, 3, 1, 5, 2, 6, 4', 'B\\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1', 'C\\n10, 9, 4, 5, 7, 6, 8, 2, 1, 3', 'D\\n10, 8, 6, 9, 7, 2, 3, 4, 1, 5']\nAnswer: A"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: A string literal in C++ includes a null terminator. The size of a character array initialized by a string literal is one greater than its character count.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the output of the following code?\n[code comparing sizeof on \"Geeks\" and {'G','e','e','k','s'}]\nChoices: ['A\\n6, 6', 'B\\n5, 6', 'C\\n6, 5', 'D\\nNone']\nAnswer: C"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The maximum number of keys in a B-tree of order m and height h is (m^h+1) – 1. For order 4 and height 3, it's 4^4 – 1 = 255 keys.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A B-tree of order 4 and of height 3 will have a maximum of _______ keys.\na) 255\nb) 63\nc) 127\nd) 188\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: In any graph, the sum of degrees of all vertices is equal to twice the number of edges, not the number of edges itself.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a simple graph, the number of edges is equal to twice the sum of the degrees of the vertices.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: In Java, the ArrayList grows by a factor of 1.5x its current size to reduce the overhead of frequent resizing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The growth factor of ArrayList in Java is ________\na) 1\nb) 1.5\nc) 2\nd) 0\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The stack is used to reverse the contents of an array by pushing all elements and popping them into another array.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the following Java code that uses a stack?\nChoices: ['A\\nprint alternate elements', 'B\\nduplicate array', 'C\\nparentheses matching', 'D\\nreverse the array']\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: In an array-based binary heap starting at index 1, the parent of element at index i is at index floor(i/2).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a binary heap with n elements stored from index 1 to n, the parent of element at index i is:\nChoices: ['A\\ni – 1', 'B\\nfloor(i/2)', 'C\\nceiling(i/2)', 'D\\n(i + 1)/2']\nAnswer: B"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: The top two elements (5 and 4) on the stack are popped and the operator * is applied. The result is pushed back to the stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the stack:\n| 5 |\n| 4 |\n| 3 |\n| 2 |\nIf '*' is encountered, what operation is performed?\na) 5*4=20 is pushed\nb) * is pushed\nc) 2*3=6 is pushed\nd) * is ignored\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Cartesian sorting is effective when data is partially sorted. It allows efficient reordering with minimal overhead.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the speciality of cartesian sorting?\na) sorts partially sorted data quickly\nb) uses cartesian product\nc) sorts in less than O(log n)\nd) it is a self-balancing tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: Skew heaps rely on merge operations for insertion and deletion, making merging the core operation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the fundamental operation performed in skew heaps?\na) intersection\nb) difference\nc) merging\nd) sorting\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Open addressing places all entries directly in the table, providing better cache performance than separate chaining using linked structures.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following variant of a hash table has the best cache performance?\na) hash table using a linked list for separate chaining\nb) hash table using binary search tree for separate chaining\nc) hash table using open addressing\nd) hash table using a doubly linked list for separate chaining\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: The tango tree is named after the capital of Argentina, Buenos Aires, as part of a trend to name trees after cities.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: After which city is tango tree named?\na) Vatican City\nb) Buenos Aires\nc) New York\nd) California\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Treaps combine binary search trees and heaps and can perform union, intersection, and difference efficiently using structural properties.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Several other operations like union, set difference, and intersection can be done in treaps.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: While XOR linked lists reduce memory usage, array-based solutions often outperform them in practice due to better memory locality and simplicity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Would using arrays and swapping elements instead of XOR linked lists be more efficient?\na) no not all\nb) yes arrays would have been better than XOR lists\nc) both would be same in efficiency\nd) can't say\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: A stack can be implemented using a single queue by adjusting enqueue and dequeue logic, though multiple queues may improve performance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Minimum number of queues to implement stack is ___________\na) 3\nb) 4\nc) 1\nd) 2\n\nAnswer: c"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: The append() method in C++'s string class concatenates one string to another. The result here is “WorldHello”.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the following code?\n[Code using string b.append(a)]\nChoices: ['A\\nHello world', 'B\\nWorld hello', 'C\\nWorldHello', 'D\\nError']\nAnswer: C"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: A relation R is symmetric if xRy implies yRx. This is the definition of symmetry in mathematical logic.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A relation R on a set S is defined such that x R y if and only if y R x. This is an example of?\na) reflexive relation\nb) symmetric relation\nc) transitive relation\nd) invalid relation\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: The first node visited in in-order traversal is the leftmost node, while in post-order it is the leftmost descendant. These differ unless it's a leaf.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: For a binary tree, is the first node visited in in-order and post-order traversal the same?\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In d-ary heaps, delete-min takes O(log N) time, regardless of the branching factor, due to its logarithmic tree height.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the run time efficiency of delete-min operation?\na) O(log N)\nb) O(logd N)\nc) O(d logd N)\nd) O(d)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: SLLs use one pointer per node, while DLLs use two. Therefore, DLLs use more memory, but enable constant-time insert/delete at known positions.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following statements are not correct with respect to Singly and Doubly Linked Lists?\na) Insertion/deletion is O(n) in SLL and O(1) in DLL\nb) SLL uses less memory per node than DLL\nc) DLL allows better backward traversal than SLL\nd) Number of node fields in SLL is more than DLL\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: A dequeue operation removes and returns the front item. The correct method sets the queue position to null and updates front and count.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following represents a dequeue operation? (count is number of items in the queue)\nAnswer: a"
  },
  {
    "input_text": "Topic: String\nDifficulty: Medium\nContext: Character strings can represent numbers in radix (base) systems. “pt” interpreted in base-26 yields 14452.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Interpret the string 'pt' as an integer in suitable radix notation.\na) 14963\nb) 14392\nc) 12784\nd) 14452\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: To expand a linear queue, copy elements into a larger array while preserving their relative order. The front and rear are adjusted accordingly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following best describes the growth of a linear queue at runtime?\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: Skew heaps perform insert, delete, and merge using a fundamental merge operation, making them efficient and structureless.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given the pseudo code, is the function for merging two heaps correct?\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: A graph where every vertex has an edge to every other vertex is called a complete graph. While not standard, 'Tightly Connected' refers here to that idea.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A graph having an edge from each vertex to every other vertex is called a ___________\na) Tightly Connected\nb) Strongly Connected\nc) Weakly Connected\nd) Loosely Connected\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Vectors in C++ are dynamic arrays that can resize themselves automatically, unlike static arrays which have fixed sizes.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is a difference between vectors and arrays?\nChoices: ['A\\nAccess to any element using [] operator', 'B\\nStored in contiguous memory blocks', 'C\\nThe ability to change size dynamically', 'D\\nEfficient direct access to any element']\nAnswer: C"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Python’s list data type is implemented internally using dynamic arrays, allowing resizing and random access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following arrays are used in the implementation of the list data type in Python?\na) Bit array\nb) Dynamic arrays\nc) Sparse arrays\nd) Parallel arrays\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: To maintain the min-heap property, if a node is less than its parent, they are swapped. This ensures that the smallest value bubbles up.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In the following min-heap function, what is the missing condition?\na) if A[m] > A[parent(m)] then swap A[m], A[parent(m)]\nb) if A[m] > A[parent(m)] then swap A[i], A[parent(m)]\nc) if A[m] < A[parent(m)] then swap A[m], A[parent(m)]\nd) if A[m] > A[parent(m)] then swap A[i], A[parent(m)]\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Recursive algorithms use stacks implicitly. Non-recursive implementations use explicit stacks to track function call states.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What data structure would you most likely see in a non-recursive implementation of a recursive algorithm?\nChoices: ['A\\nStack', 'B\\nLinked list', 'C\\nQueue', 'D\\nTrees']\nAnswer: A"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Medium\nContext: The pseudocode simulates a parenthesis matcher. Only properly matched '(' and ')' are pushed/popped. Mismatches lead to unbalanced.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following inputs would be reported as unbalanced by the given pseudocode?\nChoices: ['A\\n((())', 'B\\n())(()', 'C\\n(()()))', 'D\\n(()))()']\nAnswer: A"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Symbols like ⊥ (bottom) and T are often used to denote terminal (leaf) nodes in data structure diagrams.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following symbols represent leaf nodes?\ni) Δ ii) ◊ iii) ∇ iv) T v) ⊥\na) iv) and v)\nb) v)\nc) i) and iii)\nd) ii)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A binary tree can be uniquely constructed if in-order traversal is combined with either pre-order or post-order traversal.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following traversal pairs can uniquely build a binary tree?\na) post-order and pre-order\nb) post-order and in-order\nc) post-order and level-order\nd) level-order and preorder\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: The parent of a node in a binary heap stored in an array at index i is at floor(i/2).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the location of a parent node for any arbitrary node i?\na) (i/2) position\nb) (i+1)/2 position\nc) floor(i/2) position\nd) ceil(i/2) position\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: Two directed graphs are isomorphic if there exists a permutation matrix P such that A = PBP^-1, where A and B are adjacency matrices.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Two directed graphs G and H are isomorphic if and only if A = PBP^-1, where A and B are their adjacency matrices.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: A 2-3 tree is a balanced search tree, which is a special case of B-trees but also shares properties with AVL trees due to balance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: 2-3 tree is a specific form of _________\na) B-tree\nb) B+ tree\nc) AVL tree\nd) Heap\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The van Emde Boas tree supports associative array operations like insert, delete, and lookup with fast time complexity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: On which abstract data type does van Emde Boas tree perform operations?\na) Tree\nb) Linked List\nc) Heap\nd) Associative Array\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Hard\nContext: K-d trees support range queries, which ask for all points lying within a multidimensional rectangle or box.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Several kinds of queries are possible on a k-d tree, one of which is?\na) partial queries\nb) range queries\nc) neighbor queries\nd) search queries\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The given code pushes characters in reverse order to produce the string “cat” when popped from the stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the set of stack operations to get the output \"cat\"?\na) push(c), push(a), push(t), pop(), pop(), pop()\nb) push(c), pop(), push(a), pop(), push(t), pop()\nc) pop(c), pop(a), pop(t)\nd) push(c), push(a), pop(t)\n\nAnswer: a"
  },
  {
    "input_text": "Topic: String\nDifficulty: Hard\nContext: A trie can store strings up to length m. In the worst case, the trie can grow to a maximum depth of m for any single string.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What can be the maximum depth of a trie with n strings, each of length up to m?\na) log₂n\nb) log₂m\nc) n\nd) m\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Weight-balanced trees support basic operations like insert/delete and set operations like union, intersection, and subset testing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What operations can be performed on a weight-balanced tree?\na) all basic operations and set intersection, set union, subset test\nb) only basic operations\nc) only set operations\nd) only insertion and deletion\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Recursion uses the call stack for function calls. Each call keeps its activation record in memory, leading to high stack usage.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Recursion is memory-intensive because:\nChoices: ['A\\nRecursive functions declare many local variables.', 'B\\nPrevious calls remain open and occupy space on the stack.', 'C\\nMany copies of function code are created.', 'D\\nIt requires large data values.']\nAnswer: B"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Medium\nContext: The number of possible undirected graphs with n vertices and self-loops but no multiple edges is 2^(n(n+1)/2).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of undirected graphs with self-loops (no multi-edges) and n vertices is:\na) 2^((n(n–1))/2)\nb) 2^((n(n+1))/2)\nc) 2^(((n–1)^2)/2)\nd) 2^((n*n)/2)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: The maximum number of edges in a DAG (Directed Acyclic Graph) with n vertices is (n(n–1))/2. For n=7, max is 21.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the maximum number of edges in a simple directed acyclic graph with 7 vertices?\na) 21\nb) 7\nc) 6\nd) 49\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Operator precedence and associativity determine the evaluation order in expressions. According to the rules, multiplication/division have higher precedence than addition/subtraction, unless otherwise stated.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Assume +, -, *, / are usual arithmetic operators. + has highest precedence and is right-associative, others are left-associative. What is the output of the expression 23 * 3 – 6 + 11 – 2 * 8 / 4?\na) 110\nb) 100\nc) 130\nd) 120"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Red-Black Trees are balanced binary search trees commonly used to maintain the structure of auxiliary trees in complex tree operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which special balanced binary search tree is used to store the nodes of an auxiliary tree?\na) Red – Black Tree\nb) Red – Brown Tree\nc) Red – Yellow Tree\nd) Red – Tango Tree\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A sparse array is one in which most of the elements share the same value, commonly zero. This allows for memory-efficient storage techniques.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a sparse array?\na) Data structure for representing arrays of records\nb) Data structure that compactly stores bits\nc) An array in which most of the elements have the same value\nd) An array in which memory is allocated at run time\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A stack is empty when the top pointer equals -1. This check is commonly used in stack underflow condition detection.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does the following function check for?\nif (s->top == -1)\n    return 1;\nelse\n    return 0;\na) Full stack\nb) Invalid index\nc) Empty stack\nd) Infinite stack\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A d-heap is a generalization of a binary heap where each node can have up to d children. As d increases, the tree becomes shallower.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: d-heap is shallower than a binary heap.\na) true\nb) false\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In postfix expressions (Reverse Polish notation), operators appear after their operands. This form does not require parentheses for disambiguation.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What type of expression places the operator after its operands?\na) Infix Expression\nb) Prefix Expression\nc) Postfix Expression\nd) Both Prefix and Postfix Expressions\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Stack underflow refers to attempting a pop operation on an empty stack, which is an illegal memory access.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What does ‘stack underflow’ refer to?\na) Accessing an item from an undefined stack\nb) Adding items to a full stack\nc) Removing items from an empty stack\nd) Index out of bounds exception\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: Before deleting from a linked queue, underflow is checked to ensure that there are elements present in the structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What essential condition must be checked before deleting from a linked queue?\na) Underflow\nb) Overflow\nc) Front value\nd) Rear value\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: A binary search tree can be uniquely reconstructed using its inorder and one other traversal (either preorder or postorder).\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given preorder = [15, 10, 12, 11, 20, 18, 16, 19], what is the postorder traversal?\nChoices: ['A\\n10, 11, 12, 15, 16, 18, 19, 20', 'B\\n11, 12, 10, 16, 19, 18, 20, 15', 'C\\n20, 19, 18, 16, 15, 12, 11, 10', 'D\\n19, 16, 18, 20, 11, 12, 10, 15']\nAnswer: B"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Binary trees allow insertions in different ways—leftmost, rightmost, or random—depending on whether it is a full, complete, or general binary tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many types of insertion can be performed in a binary tree?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: Horner's method allows evaluating a polynomial with minimum number of multiplications and additions. For degree 3, 3 multiplications and 3 additions are required.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the minimum number of multiplications and additions required to evaluate the polynomial P = 4x³ + 3x² – 15x + 45?\nChoices: ['A\\n6 & 3', 'B\\n4 & 2', 'C\\n3 & 3', 'D\\n8 & 3']\nAnswer: C"
  },
  {
    "input_text": "Topic: Stack\nDifficulty: Hard\nContext: Stack is not used for asynchronous data transfer. It is used in expression evaluation, runtime variable tracking, and compiler design.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is not an application of a stack?\na) Data transfer between two asynchronous processes\nb) Compiler syntax analyzer\nc) Tracking local variables at runtime\nd) Parentheses balancing program\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Medium\nContext: The multiplication method for hashing consists of two steps: multiplying the key and taking the fractional part, followed by multiplying with table size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many steps are involved in creating a hash function using the multiplication method?\na) 1\nb) 4\nc) 3\nd) 2\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In infix to postfix conversion, parentheses are not ignored. They play a key role in operator precedence and must be processed correctly.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Parentheses are simply ignored in infix to postfix conversion.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A treap is a randomized binary search tree that also satisfies the heap property based on priorities.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A treap is a combination of a tree and a heap.\na) false\nb) true\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Leftist heaps maintain both the heap order property and the leftist property, supporting three key structural constraints.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many properties does a leftist heap support?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Binary trees with height h can perform operations in O(log n) time due to their balanced structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the time complexity for operations in a balanced binary tree?\nChoices: ['A\\nO(n^0.5)', 'B\\nO(n)', 'C\\nO(log n)', 'D\\nO(n log n)']\nAnswer: C"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Java uses row-major order for multidimensional arrays. The syntax for declaring a 2D array is `int[][] arr;`.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following is the correct way to declare a multidimensional array in Java?\na) int[] arr;\nb) int arr[[]];\nc) int[][] arr;\nd) int[[]] arr;\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a binary search tree, searching a key involves recursive comparisons against left or right child nodes based on key value.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How do you search for a key in a binary search tree?\n[Java code snippets provided]\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: AA-trees are balanced binary search trees that use skew and split operations to maintain balance.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the two different operations done in an AA-Tree?\na) shift and color\nb) skew and split\nc) zig and zag\nd) enqueue and dequeue\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: A monotonic deque maintains elements in a strictly increasing or decreasing order and is used in sliding window problems.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The deque which stores elements in strictly increasing or strictly decreasing order is called ________.\nChoices: ['A\\nPriority Queue', 'B\\nDouble-ended Queue', 'C\\nMonotonic Deque', 'D\\nNone']\nAnswer: C"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: In union-find structures, the number of nodes of rank r is at most N / 2^r.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the number of nodes of rank r in a union-find data structure?\na) N\nb) N/2\nc) N/2^r\nd) Nr\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The function iterates through a circular linked list and returns 'fail' if the item is not found.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the functionality of the following piece of code?\n[Code snippet provided]\nChoices: ['A\\nPrint success if element is not found', 'B\\nPrint fail if element is not found', 'C\\nPrint success if element = 1', 'D\\nPrint fail if list is empty']\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: In a linked list, each node must contain a pointer to the next node (and possibly previous), along with data.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a linked list, each node contains at least two fields. One is data. What is the other?\na) Pointer to character\nb) Pointer to integer\nc) Pointer to node\nd) Node\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Pruning is used to reduce search space by eliminating paths that won’t lead to a solution, often in decision trees or game trees.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Reducing search space by eliminating irrelevant trees is known as?\na) pruning\nb) partial results\nc) freeing space\nd) traversing\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: Postorder traversal follows left → right → root. Given a preorder sequence, the unique BST’s postorder traversal can be computed.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given preorder traversal: 30, 20, 10, 15, 25, 23, 39, 35, 42. What is the postorder traversal?\nChoices: ['A\\n10, 20, 15, 23, 25, 35, 42, 39, 30', 'B\\n15, 10, 25, 23, 20, 42, 35, 39, 30', 'C\\n15, 20, 10, 23, 25, 42, 35, 39, 30', 'D\\n15, 10, 23, 25, 20, 35, 42, 39, 30']\nAnswer: D"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Medium\nContext: The array q[] represents the queue. q[0] typically refers to the front of the queue in simple implementations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a basic array implementation of a queue, which index is typically used for the front?\nChoices: ['A\\nq[0]', 'B\\nq[1]', 'C\\nq[9]', 'D\\nq[10]']\nAnswer: A"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: A heap must be a complete binary tree and must follow the heap property—either max-heap or min-heap ordering.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the necessary condition for a tree to be a heap?\nChoices: ['A\\nOnly complete tree', \"B\\nOnly heap property\", \"C\\nComplete tree and heap property\", 'D\\nNone']\nAnswer: C"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Recursion typically uses a stack for call management. Non-recursive versions explicitly simulate this with a stack.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What data structure is commonly used in non-recursive implementations of recursive algorithms?\na) Linked List\nb) Stack\nc) Queue\nd) Tree\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Using arrays for tree storage requires knowing the maximum number of nodes beforehand, which reduces flexibility.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is a disadvantage of implementing a tree using arrays?\na) Difficult to access children\nb) Difficult to find parent\nc) Maximum nodes must be known in advance\nd) Hard to implement\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In a full binary tree, the total number of nodes is given by 2L – 1, where L is the number of leaves.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: In a full binary tree with L leaves, what is the total number of nodes N?\na) 2*L\nb) L + 1\nc) L – 1\nd) 2*L – 1\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In graphs where all edges have equal weight, BFS finds the shortest path in linear time as it explores layer by layer.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Given a directed graph with equal-weight edges, which algorithm efficiently finds the shortest path from source to destination?\nChoices: ['A\\nBreadth First Traversal', \"B\\nDijkstra's Algorithm\", \"C\\nNeither BFS nor Dijkstra's\", 'D\\nDepth First Search']\nAnswer: A"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: Bit arrays store boolean values compactly, while bit fields are used to access or manipulate individual bits within a data structure. They are related but not the same.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Bit fields and Bit arrays are the same.\na) True\nb) False\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Hard\nContext: Quadratic probing requires specific constraints to avoid clustering and ensure the entire table is probed. Two key constraints relate to the table size being prime and the probing function formula.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: How many constraints are to be met to successfully implement quadratic probing?\na) 1\nb) 2\nc) 3\nd) 4\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: The provided code rotates an array to the left by `d` positions using repeated element shifting. This simulates a circular shift.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What will be the output of the given C++ code that rotates an array left by 3 positions?\na) 4 5 1 2 3\nb) 3 4 5 1 2\nc) 5 4 3 1 2\nd) error\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Singly linked lists require less memory than doubly linked lists due to having only one pointer per node, making them more space-efficient for chaining.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the advantage of using a singly linked list over a doubly linked list for chaining in hash tables?\na) It takes less memory\nb) It causes more collisions\nc) It makes the process of insertion and deletion faster\nd) It causes fewer collisions\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Preorder and inorder traversals can be used to reconstruct a binary tree. Using the given sequences, one can derive the corresponding postorder.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The preorder and inorder traversals of a binary tree are T M L N P O Q and L M N T O P Q. What is the postorder traversal?\na) L N M O Q P T\nb) N M O P O L T\nc) L M N O P Q T\nd) O P L M N Q T"
  },
  {
    "input_text": "Topic: Hashing\nDifficulty: Hard\nContext: In double hashing, the probe function is of the form `(h1(k) + i * h2(k)) mod m` where i is the probe count. This avoids clustering better than linear probing.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the hash function used in Double Hashing?\na) (h1(k) - i*h2(k)) mod m\nb) h1(k) + h2(k)\nc) (h1(k) + i*h2(k)) mod m\nd) (h1(k) + h2(k)) mod m\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: When converting infix to postfix, the position of operators and parentheses must be considered based on precedence and associativity.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Convert the following infix expression to postfix: (A + B ∧ D)/(E - F) + G\nChoices:\na) A B D ∧ + E F - / G +\nb) A B D + ∧ E F - / G +\nc) A B D ∧ + E F - / - G +\nd) A B D E F + ∧ / - G +\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: AVL trees maintain a stricter balance than Red-Black trees by ensuring that the balance factor of every node is -1, 0, or 1.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: AVL trees are more balanced than Red-black trees.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: Accessing elements from the start is O(1) in a singly linked list, while accessing from the end requires traversal, which takes O(n) time.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What are the time complexities of finding the 8th element from the beginning and from the end in a singly linked list (n > 8)?\nChoices: ['A\\nO(1) and O(n)', 'B\\nO(1) and O(1)', 'C\\nO(n) and O(1)', 'D\\nO(n) and O(n)']\nAnswer: A"
  },
  {
    "input_text": "Topic: Queue\nDifficulty: Hard\nContext: A queue follows the First-In-First-Out (FIFO) principle, so elements are removed in the same order they are added.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If elements “A”, “B”, “C”, and “D” are placed in a queue, in what order are they removed?\na) ABCD\nb) DCBA\nc) DCAB\nd) ABDC\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Medium\nContext: A suffix tree is a compressed trie that represents all the suffixes of a string. An alternative structure called a PAT Tree (Practical Algorithm to Retrieve Information Coded in Alphanumeric) is also used to represent suffixes efficiently.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: What is the other name for Suffix Tree?\na) Array\nb) Stack\nc) Priority Queue\nd) PAT Tree\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The height of a node in a tree is the number of edges on the longest downward path between that node and a leaf. This measurement helps analyze the efficiency of operations like search and insert.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: The number of edges from the node to the deepest leaf is called _________ of the tree.\na) Height\nb) Depth\nc) Length\nd) Width\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: In a Binary Search Tree (BST), the in-order predecessor of a node is the maximum value node in its left subtree. This node will not have a right child.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: If a node in a BST has two children, then its in-order predecessor has ________.\na) no left child\nb) no right child\nc) two children\nd) no child\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: The in-order traversal of a BST gives nodes in sorted order. To identify a valid BST from a given traversal, the property that for any node, left < root < right, must hold true.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: A Binary Search Tree (BST) stores values in the range 37 to 573. Consider the following sequence of keys:\nI. 81, 537, 102, 439, 285, 376, 305\nII. 52, 97, 121, 195, 242, 381, 472\nIII. 142, 248, 520, 386, 345, 270, 307\nIV. 550, 149, 507, 395, 463, 402, 270\nWhich of the following statements is TRUE?\na) I, II and IV are inorder sequences of three different BSTs\nb) I is a preorder sequence of some BST with 439 as the root\nc) II is an inorder sequence of some BST where 121 is the root and 52 is a leaf\nd) IV is a postorder sequence of some BST with 149 as the root\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: A binary heap is a complete binary tree. Its inorder traversal does not guarantee sorted order. This is in contrast with a BST.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Does there exist a heap with seven distinct elements so that the Inorder traversal gives the elements in sorted order?\na) Yes\nb) No\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: Matrix representations are commonly used in graph theory, image processing, and solving linear equations, but not in sorting operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following don’t use matrices?\na) In solving linear equations\nb) Image processing\nc) Graph theory\nd) Sorting numbers\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Medium\nContext: The recursive function shown checks whether the elements in a singly linked list are in non-decreasing order by comparing each node with its next.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Consider the function f defined below:\n#include <iostream>\nstruct item {\n    int data;\n    struct item *next;\n};\nint f(struct item *p) {\n    return ((p == NULL) || (p->next == NULL) || ((p->data <= p->next->data) && f(p->next)));\n}\nWhat does this function check?\na) Not all elements have the same data value\nb) Elements are sorted in non-decreasing order\nc) Elements are sorted in non-increasing order\nd) None of them\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: In a Directed Acyclic Graph (DAG), a sink vertex has no outgoing edges. Every DAG must have at least one sink vertex.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Every Directed Acyclic Graph has at least one sink vertex.\na) True\nb) False\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Sorting\nDifficulty: Medium\nContext: Interpolation search works effectively only when elements are uniformly distributed in a sorted dataset, as it estimates the position based on value range.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Interpolation search is an improved variant of binary search. What is necessary for this algorithm to work?\na) Data collection should be in sorted form and equally distributed\nb) Data collection should be sorted but not equally distributed\nc) Data collection should be equally distributed but not sorted\nd) None of these\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Suffix arrays are more space-efficient than suffix trees and provide better cache locality. They can be constructed in linear time with optimized algorithms.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Question: Which of the following are advantages of suffix array over suffix tree?\nI. Lesser space requirement\nII. Improved cache locality\nIII. Easy construction in linear time\n\na) Only I\nb) All I, II and III\nc) Only I and III\nd) Only II and III\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: In a Binary Search Tree (BST), the left child node always contains a value less than its parent node, and the right child node always contains a value greater. Additionally, in-order traversal yields values in increasing order.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which of the following is false about a binary search tree?\na) The left child is always lesser than its parent\nb) The right child is always greater than its parent\nc) The left and right sub-trees should also be binary search trees\nd) In order sequence gives decreasing order of elements\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In a ternary heap (a heap where each node has three children), the tree is typically maintained in an array representation and leaves are filled from left to right to preserve the complete tree property.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Should leaves in ternary heap be distributed from left to right.\na) True\nb) False\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Linked List\nDifficulty: Hard\nContext: Treaps (Cartesian trees) combine properties of binary search trees and heaps. They are often used in place of linked lists or balanced trees when randomized performance is acceptable.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Consider below sequences.\n\nHow to achieve the above operation efficiently?\na) use linked lists\nb) use avl trees\nc) use red-black trees\nd) use treaps (cartesian trees)\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: In weight-balanced trees, each internal node stores a size value equal to the combined sizes of its children. Leaf nodes are considered to have a size of zero.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The size value of various nodes in a weight balanced tree are\nleaf – zero\ninternal node – size of it’s two children\nis this true?\na) true\nb) false\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Ternary heaps are a variant of binary heaps where each node has up to three children. They are typically implemented using arrays and support priority queue operations.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "33. Which type of data structure is a ternary heap?\na) Hash\nb) Array\nc) Priority Stack\nd) Priority Queue\nAnswer: d"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: While min-heaps can be used for heap sort, they are not typically used for selection sort, which operates by finding the minimum element repeatedly without using a heap.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Min heap can be used to implement selection sort.\na) True\nb) False\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: Ternary heaps are stored using arrays where the children of node i are located at 3i + 1, 3i + 2, and 3i + 3. This array-based representation allows efficient access to parent and children.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Which type of data structure is a ternary heap?\na) Array\nb) Hash\nc) Priority Queue\nd) Priority Stack\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Search\nDifficulty: Medium\nContext: A self-organizing list adjusts its structure based on access patterns, reducing average access time. Frequently accessed elements are moved closer to the front.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "The self organizing list improves _____\na) average access time\nb) insertion\nc) deletion\nd) binary search\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Hard\nContext: Skew heaps are a form of self-adjusting binary heap that rely on a simple merging procedure, unlike leftist heaps that maintain additional structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "___________ is a self-adjusting version of a leftist heap.\na) Rightist heap\nb) Skew heap\nc) d-heap\nd) Binary heap\n\n\nAnswer: b"
  },
  {
    "input_text": "Topic: Heap\nDifficulty: Medium\nContext: In a d-heap, each node has d children. Secondary operations such as sift-up and sift-down depend on the value of d, affecting the heap's structure.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many secondary operations are performed in a d-heap?\na) 1\nb) 2\nc) 3\nd) 4\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Graph\nDifficulty: Hard\nContext: The adjacency matrix of a graph can be used to count the number of paths of a given length. The square of the adjacency matrix gives the number of paths of length 2 between vertices.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Given an adjacency matrix A = [ [0, 1, 1], [1, 0, 1], [1, 1, 0] ], The total no. of ways in which every vertex can walk to itself using 2 edges is ________\na) 2\nb) 4\nc) 6\nd) 8\n\n\nAnswer: c"
  },
  {
    "input_text": "Topic: Theory\nDifficulty: Medium\nContext: The load factor is a measure used in hash tables to determine how full the table is. It is commonly denoted by the Greek letter λ (lambda) or sometimes β.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the correct notation for a load factor?\na) Ω\nb) ∞\nc) ∑\nd) ⅄\n\n\nAnswer: d"
  },
  {
    "input_text": "Topic: Array\nDifficulty: Hard\nContext: A hash function maps input data to a fixed index in an array. This index determines where the data should be stored in a hash table for fast retrieval.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "What is the use of a hash function?\na) to calculate and return the index of corresponding data\nb) to store data\nc) to erase data\nd) to change data\n\n\nAnswer: a"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Medium\nContext: Red-Black Trees are balanced binary search trees that ensure logarithmic height. A perfect Red-Black Tree may have all black nodes if all nodes satisfy the tree’s coloring rules.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "Is the following statement valid? A Red-Black Tree which is also a perfect Binary Tree can have all black nodes, , Choices: ['A\\nYes', 'B\\nNo'], Answer: A\nYes"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A B+ tree is a balanced tree data structure used in databases. The degree of a node determines how many children it can have and is influenced by block size and pointer size.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "A B+ -tree index is to be built on the Name attribute of the relation STUDENT. Assume that all student names are of length 8 bytes, disk block are size 512 bytes, and index pointers are of size 4 bytes. Given this scenario, what would be the best choice of the degree (i.e. the number of pointers per node) of the B+ -tree?, , Choices: ['A\\n16', 'B\\n42', 'C\\n43', 'D\\n44'], Answer: C\n43"
  },
  {
    "input_text": "Topic: Tree\nDifficulty: Hard\nContext: A Binary Decision Tree for n boolean variables can have up to 2ⁿ leaves. The total number of nodes is 2ⁿ - 1 in the worst case for a complete tree.\nTask: Generate a multiple-choice question on the given topic and difficulty using the provided context.",
    "target_text": "How many nodes are required to create a Binary Decision Tree having 4 variables?\na) 24\nb) 24-1\nc) 25\nd) 25-1\n\n\nAnswer: d"
  }
]