   [
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: In array indexing, the first element is accessed using index 0, making arrays zero-indexed in most programming languages.",
    "target_text": "Question: What is the index of the first element in a zero-indexed array?\nChoices:\na) 1\nb) 0\nc) -1\nd) NULL\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: The time complexity for accessing an element at a given index in an array is O(1) because arrays provide direct memory access.",
    "target_text": "Question: What is the time complexity for accessing an element at index i in an array?\nChoices:\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: In a static array of size n, inserting an element at the beginning requires shifting all existing elements one position to the right.",
    "target_text": "Question: What is the worst-case time complexity for inserting an element at the beginning of an array of size n?\nChoices:\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Dynamic arrays automatically resize when they reach capacity, typically doubling in size to maintain amortized O(1) insertion time.",
    "target_text": "Question: In dynamic arrays, what is the typical growth factor when resizing:\nChoices:\na) 1.5x\nb) 2x\nc) 3x\nd) n+1\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: A subarray is a contiguous sequence of elements within an array, while a subsequence can have non-contiguous elements.",
    "target_text": "Question: Which statement about subarrays is correct?\nChoices:\na) Elements must be contiguous\nb) Elements can be non-contiguous\nc) Only includes the first and last elements\nd) Must include all elements\nAnswer: a"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: The maximum number of elements that can be stored in an array is limited by the available memory and the data type size.",
    "target_text": "Question: What determines the maximum size of an array:\nChoices:\na) Only the data type\nb) Only available memory\nc) Both memory and data type size\nd) The compiler version\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: In row-major order, elements of a 2D array are stored row by row in memory, which is the default in languages like C and Java.",
    "target_text": "Question: In row-major order storage of a 2D array, how are elements stored in memory?\nChoices:\na) Column by column\nb) Row by row\nc) Diagonally\nd) Randomly\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Binary search requires the array to be sorted and has a time complexity of O(log n) by repeatedly dividing the search space in half.",
    "target_text": "Question: What is the prerequisite for performing binary search on an array?\nChoices:\na) Array must be unsorted\nb) Array must be sorted\nc) Array must have even number of elements\nd) Array must contain unique elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: The space complexity of most in-place array algorithms is O(1) as they don't require additional space proportional to input size.",
    "target_text": "Question: What is the space complexity of an in-place array sorting algorithm?\nChoices:\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Kadane's algorithm finds the maximum sum subarray in O(n) time using dynamic programming principles.",
    "target_text": "Question: Kadane's algorithm is used to find:\nChoices:\na) Maximum element in array\nb) Maximum sum subarray\nc) Longest increasing subsequence\nd) Most frequent element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Two pointers technique is commonly used in sorted arrays to find pairs or triplets that satisfy certain conditions in O(n) time.",
    "target_text": "Question: The two pointers technique is most effective on:\nChoices:\na) Unsorted arrays\nb) Sorted arrays\nc) Circular arrays\nd) Jagged arrays\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Prefix sum arrays allow calculation of range sums in O(1) time after O(n) preprocessing.",
    "target_text": "Question: After building a prefix sum array, what is the time complexity to find sum of elements from index i to j?\nChoices:\na) O(j-i)\nb) O(n)\nc) O(log n)\nd) O(1)\nAnswer: d"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Sliding window technique optimizes problems involving contiguous subarrays by maintaining a window of fixed or variable size.",
    "target_text": "Question: Sliding window technique is primarily used for problems involving:\nChoices:\na) Non-contiguous elements\nb) Contiguous subarrays\nc) Binary operations\nd) Recursive structures\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Dutch National Flag algorithm partitions an array into three sections in O(n) time using three pointers.",
    "target_text": "Question: How many pointers does the Dutch National Flag algorithm use?\nChoices:\na) 2\nb) 3\nc) 4\nd) n\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Merge sort has a time complexity of O(n log n) and requires O(n) additional space for merging.",
    "target_text": "Question: What is the space complexity of merge sort when applied to arrays:\nChoices:\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Quick sort's average time complexity is O(n log n), but worst-case is O(n²) when pivot is always the smallest or largest element.",
    "target_text": "Question: What is the worst-case time complexity of quicksort on arrays?\nChoices:\na) O(n log n)\nb) O(n²)\nc) O(n³)\nd) O(2ⁿ)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Bubble sort compares adjacent elements and swaps them if they're in wrong order, with O(n²) time complexity.",
    "target_text": "Question: In bubble sort, which elements are compared in each iteration:\nChoices:\na) First and last\nb) Adjacent elements\nc) Random elements\nd) Middle elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Selection sort finds the minimum element and places it at the beginning, repeating for remaining elements with O(n²) complexity.",
    "target_text": "Question: Selection sort works by:\nChoices:\na) Selecting maximum element repeatedly\nb) Selecting minimum element repeatedly\nc) Selecting middle element repeatedly\nd) Selecting random element repeatedly\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Insertion sort builds the sorted array one element at a time by inserting each element into its correct position.",
    "target_text": "Question: Insertion sort builds a sorted array by:\nChoices:\na) Dividing array into halves\nb) Selecting minimum elements\nc) Inserting elements one by one in correct position\nd) Swapping adjacent elements\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Heap sort uses a binary heap data structure and has O(n log n) time complexity with O(1) space complexity.",
    "target_text": "Question: What data structure does heap sort utilize?\nChoices:\na) Binary tree\nb) Binary heap\nc) Hash table\nd) Linked list\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Counting sort is a non-comparison based sorting algorithm that works well when the range of input values is small.",
    "target_text": "Question: Counting sort is most efficient when:\nChoices:\na) Array is already sorted\nb) Range of values is small\nc) Array contains duplicates\nd) Array is very large\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Radix sort processes digits from least significant to most significant, achieving O(d×n) time complexity where d is number of digits.",
    "target_text": "Question: Radix sort processes digits in which order?\nChoices:\na) Most significant to least significant\nb) Least significant to most significant\nc) Random order\nd) Middle to ends\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Linear search examines each element sequentially until the target is found or the array ends, with O(n) time complexity.",
    "target_text": "Question: What is the time complexity of linear search in the worst case:\nChoices:\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Binary search tree property states that left subtree contains smaller values and right subtree contains larger values than the root.",
    "target_text": "Question: In binary search on a sorted array, if target is smaller than middle element, which half is searched?\nChoices:\na) Right half\nb) Left half\nc) Both halves\nd) Neither half\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Interpolation search estimates the position of the target element based on the value distribution, working best on uniformly distributed data.",
    "target_text": "Question: Interpolation search works best when data is:\nChoices:\na) Randomly distributed\nb) Uniformly distributed\nc) Sorted in descending order\nd) Contains many duplicates\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Exponential search first finds a range where the element might exist, then performs binary search within that range.",
    "target_text": "Question: Exponential search combines which two search techniques?\nChoices:\na) Linear and binary search\nb) Range finding and binary search\nc) Hash search and linear search\nd) Interpolation and linear search\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Jump search divides the array into blocks of size √n and jumps through blocks to find the target element.",
    "target_text": "Question: What is the optimal block size for jump search in an array of size n:\nChoices:\na) n/2\nb) log n\nc) √n\nd) n\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Ternary search divides the array into three parts and eliminates two-thirds of the array in each iteration.",
    "target_text": "Question: How many parts does ternary search divide the array into in each iteration?\nChoices:\na) 2\nb) 3\nc) 4\nd) n/3\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: In array rotation, elements are shifted circularly either to the left or right by a specified number of positions.",
    "target_text": "Question: In left rotation of an array by k positions, where does the element at index 0 move to?\nChoices:\na) Index k\nb) Index n-k\nc) Index n-1\nd) Remains at index 0\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Reversal algorithm for array rotation uses three array reversals to achieve rotation in O(n) time and O(1) space.",
    "target_text": "Question: How many array reversals does the reversal algorithm use for rotation:\nChoices:\na) 1\nb) 2\nc) 3\nd) k\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Cyclic replacement method for array rotation moves elements directly to their final positions using GCD approach.",
    "target_text": "Question: Cyclic replacement method for array rotation is based on:\nChoices:\na) LCM calculation\nb) GCD calculation\nc) Prime factorization\nd) Modular arithmetic only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Block swap algorithm for array rotation recursively swaps blocks of elements to achieve the desired rotation.",
    "target_text": "Question: Block swap algorithm for array rotation uses which approach?\nChoices:\na) Iterative only\nb) Recursive approach\nc) Dynamic programming\nd) Greedy method\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Matrix multiplication of two n×n matrices requires O(n³) time using the standard algorithm.",
    "target_text": "Question: What is the time complexity of standard matrix multiplication for two n×n matrices?\nChoices:\na) O(n²)\nb) O(n³)\nc) O(n⁴)\nd) O(2ⁿ)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Strassen's algorithm reduces matrix multiplication complexity to approximately O(n^2.807) using divide and conquer.",
    "target_text": "Question: Strassen's algorithm for matrix multiplication uses which technique:\nChoices:\na) Dynamic programming\nb) Greedy approach\nc) Divide and conquer\nd) Backtracking\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Transpose of a matrix can be computed in-place for square matrices, swapping elements across the main diagonal.",
    "target_text": "Question: For in-place matrix transpose of a square matrix, elements are swapped across:\nChoices:\na) First row\nb) Last column\nc) Main diagonal\nd) Anti-diagonal\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Spiral matrix traversal visits elements in a spiral pattern from outside to inside, requiring careful boundary management.",
    "target_text": "Question: In spiral matrix traversal, the pattern moves:\nChoices:\na) Inside to outside\nb) Outside to inside\nc) Top to bottom only\nd) Left to right only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Matrix rotation by 90 degrees can be achieved by first transposing the matrix, then reversing each row.",
    "target_text": "Question: To rotate a matrix 90 degrees clockwise, which operations are performed:\nChoices:\na) Transpose then reverse each column\nb) Transpose then reverse each row\nc) Reverse each row then transpose\nd) Reverse each column then transpose\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Diagonal traversal of a matrix processes elements along diagonals, either from top-left to bottom-right or vice versa.",
    "target_text": "Question: In diagonal matrix traversal, elements are processed along:\nChoices:\na) Rows only\nb) Columns only\nc) Diagonal lines\nd) Spiral pattern\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Wave array arrangement places elements such that arr[0] >= arr[1] <= arr[2] >= arr[3] and so on.",
    "target_text": "Question: In a wave array, the relationship between consecutive elements follows:\nChoices:\na) Strictly increasing\nb) Strictly decreasing\nc) Alternating greater-less pattern\nd) Random pattern\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Zigzag array arrangement alternates between increasing and decreasing subsequences within the array.",
    "target_text": "Question: Zigzag array arrangement is characterized by:\nChoices:\na) All elements in ascending order\nb) All elements in descending order\nc) Alternating ascending and descending subsequences\nd) Random element placement\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Leaders in an array are elements that are greater than all elements to their right.",
    "target_text": "Question: An element is considered a leader in an array if it is:\nChoices:\na) Greater than all elements to its left\nb) Greater than all elements to its right\nc) The maximum element\nd) The minimum element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Next greater element for each element in an array can be found efficiently using a stack data structure.",
    "target_text": "Question: Which data structure is most efficient for finding next greater elements?\nChoices:\na) Queue\nb) Stack\nc) Priority queue\nd) Hash table\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Stock span problem calculates the span of consecutive days where stock price was less than or equal to current day's price.",
    "target_text": "Question: Stock span problem calculates:\nChoices:\na) Maximum profit possible\nb) Consecutive days with price <= current price\nc) Average stock price\nd) Minimum price in range\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Largest rectangle in histogram problem finds the maximum rectangular area that can be formed using histogram bars.",
    "target_text": "Question: The largest rectangle in histogram problem finds:\nChoices:\na) Tallest bar in histogram\nb) Maximum rectangular area possible\nc) Average height of bars\nd) Total area under histogram\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Rain water trapping problem calculates the total amount of water that can be trapped between histogram bars.",
    "target_text": "Question: Rain water trapping problem calculates:\nChoices:\na) Maximum water level\nb) Total water that can be trapped\nc) Height of tallest bar\nd) Average bar height\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Maximum sum path in a matrix can be found using dynamic programming, considering all possible paths from top to bottom.",
    "target_text": "Question: Maximum sum path in matrix is typically solved using:\nChoices:\na) Greedy algorithm\nb) Dynamic programming\nc) Backtracking\nd) Divide and conquer\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Minimum path sum in a grid calculates the path from top-left to bottom-right with minimum sum of elements.",
    "target_text": "Question: In minimum path sum problem, the goal is to find path from:\nChoices:\na) Top-right to bottom-left\nb) Top-left to bottom-right\nc) Any corner to center\nd) Center to any corner\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Unique paths in a grid counts the number of possible paths from top-left to bottom-right moving only right or down.",
    "target_text": "Question: In unique paths problem, movement is restricted to:\nChoices:\na) Any direction\nb) Only right and down\nc) Only left and up\nd) Diagonal movements only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Edit distance between two arrays can be calculated using dynamic programming to find minimum operations needed.",
    "target_text": "Question: Edit distance between arrays is calculated using:\nChoices:\na) Greedy algorithm\nb) Dynamic programming\nc) Binary search\nd) Sorting\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Longest common subsequence between two arrays finds the longest sequence that appears in both arrays in same order.",
    "target_text": "Question: Longest common subsequence requires elements to appear in:\nChoices:\na) Same positions\nb) Same relative order\nc) Reverse order\nd) Any order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Longest increasing subsequence finds the longest subsequence where elements are in strictly increasing order.",
    "target_text": "Question: In longest increasing subsequence, elements must be:\nChoices:\na) Contiguous and increasing\nb) Non-contiguous but increasing\nc) Contiguous and decreasing\nd) Adjacent elements only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Maximum subarray product finds the contiguous subarray with the largest product, handling both positive and negative numbers.",
    "target_text": "Question: Maximum subarray product problem considers:\nChoices:\na) Only positive numbers\nb) Only negative numbers\nc) Both positive and negative numbers\nd) Only zero values\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Minimum window substring finds the smallest substring that contains all characters of another string.",
    "target_text": "Question: Minimum window substring finds the smallest substring that:\nChoices:\na) Contains any character from target\nb) Contains all characters from target\nc) Is lexicographically smallest\nd) Has minimum ASCII sum\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Sliding window maximum finds the maximum element in every window of size k as the window slides through the array.",
    "target_text": "Question: Sliding window maximum problem finds maximum in:\nChoices:\na) Entire array\nb) Every window of fixed size\nc) Only the first window\nd) Only the last window\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: First negative number in every window of size k can be found efficiently using queue data structure.",
    "target_text": "Question: For finding first negative number in sliding windows, which data structure is most efficient?\nChoices:\na) Stack\nb) Queue\nc) Priority queue\nd) Hash table\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Count of smaller elements to the right can be computed using various approaches including merge sort modification.",
    "target_text": "Question: Count of smaller elements to the right can be efficiently computed using modified:\nChoices:\na) Quick sort\nb) Merge sort\nc) Bubble sort\nd) Selection sort\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Inversion count in an array counts pairs where a larger element appears before a smaller element.",
    "target_text": "Question: Inversion count measures pairs where:\nChoices:\na) Smaller element comes before larger\nb) Larger element comes before smaller\nc) Elements are equal\nd) Elements are adjacent\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Majority element appears more than n/2 times in an array and can be found using Boyer-Moore voting algorithm.",
    "target_text": "Question: Majority element appears more than:\nChoices:\na) n/3 times\nb) n/2 times\nc) n/4 times\nd) n times\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Boyer-Moore voting algorithm finds the majority element in O(n) time and O(1) space complexity.",
    "target_text": "Question: Boyer-Moore voting algorithm has space complexity of:\nChoices:\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Moore's voting algorithm can be extended to find elements that appear more than n/3 times in the array.",
    "target_text": "Question: Extended Moore's voting algorithm finds elements appearing more than:\nChoices:\na) n/2 times\nb) n/3 times\nc) n/4 times\nd) n/5 times\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Missing number in an array containing n-1 distinct numbers from 1 to n can be found using XOR operation.",
    "target_text": "Question: XOR-based approach for finding missing number works because:\nChoices:\na) XOR is commutative\nb) XOR of same numbers is 0\nc) XOR with 0 gives original number\nd) All of the above\nAnswer: d"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Duplicate number in array can be detected using Floyd's cycle detection algorithm treating array as a linked list.",
    "target_text": "Question: Floyd's cycle detection for duplicate finding treats array as:\nChoices:\na) Binary tree\nb) Linked list\nc) Hash table\nd) Stack\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Set mismatch problem finds a number that appears twice and a number that is missing from the sequence.",
    "target_text": "Question: Set mismatch problem involves finding:\nChoices:\na) Only duplicate number\nb) Only missing number\nc) Both duplicate and missing numbers\nd) All unique numbers\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: First missing positive finds the smallest positive integer not present in the array.",
    "target_text": "Question: First missing positive problem finds the smallest:\nChoices:\na) Missing number\nb) Positive missing number\nc) Negative missing number\nd) Even missing number\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Pancake sorting sorts an array using only flip operations, where a flip reverses elements from start to a given position.",
    "target_text": "Question: Pancake sorting uses which primary operation:\nChoices:\na) Swap\nb) Rotation\nc) Flip (reverse)\nd) Insertion\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Bitonic array first increases then decreases, having exactly one peak element.",
    "target_text": "Question: A bitonic array has how many peak elements?\nChoices:\na) 0\nb) 1\nc) 2\nd) Multiple\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Peak element in an array is greater than its neighbors, and every array has at least one peak.",
    "target_text": "Question: Every array is guaranteed to have at least:\nChoices:\na) One valley\nb) One peak\nc) Two peaks\nd) No peaks\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Valley element in an array is smaller than its neighbors, opposite of a peak element.",
    "target_text": "Question: Valley element is characterized by being:\nChoices:\na) Greater than neighbors\nb) Smaller than neighbors\nc) Equal to neighbors\nd) Maximum in array\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Local minimum in an array is an element that is smaller than or equal to its neighbors.",
    "target_text": "Question: Local minimum is an element that is:\nChoices:\na) Globally minimum\nb) Smaller than or equal to neighbors\nc) Greater than neighbors\nd) Average of neighbors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Global minimum is the smallest element in the entire array, while local minimum only considers neighbors.",
    "target_text": "Question: The difference between global and local minimum is:\nChoices:\na) No difference\nb) Global considers entire array, local considers neighbors\nc) Local considers entire array, global considers neighbors\nd) Both are always equal\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Equilibrium index is a position where sum of elements before it equals sum of elements after it.",
    "target_text": "Question: At equilibrium index, the sum of elements before it:\nChoices:\na) Is greater than sum after it\nb) Is less than sum after it\nc) Equals sum after it\nd) Is always zero\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Pivot index is similar to equilibrium index, where left sum equals right sum at that position.",
    "target_text": "Question: Pivot index and equilibrium index are:\nChoices:\na) Completely different concepts\nb) Similar concepts with same definition\nc) Opposite concepts\nd) Unrelated to array sums\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Triplet sum problem finds three numbers in array that sum to a target value, often solved using two pointers.",
    "target_text": "Question: Triplet sum problem typically uses which technique after sorting:\nChoices:\na) Binary search\nb) Two pointers\nc) Hash table\nd) Dynamic programming\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Four sum problem extends triplet sum to find four numbers that sum to target, using nested two pointers approach.",
    "target_text": "Question: Four sum problem is typically solved using:\nChoices:\na) Single pointer\nb) Two pointers\nc) Nested two pointers\nd) Three pointers\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Container with most water finds two lines that can contain maximum water, using two pointers from array ends.",
    "target_text": "Question: Container with most water problem starts two pointers from:\nChoices:\na) Array beginning\nb) Array middle\nc) Array ends\nd) Random positions\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Trapping rainwater between buildings uses the concept of finding water level based on minimum of left and right maximum heights.",
    "target_text": "Question: Water level at any position in rainwater trapping is determined by:\nChoices:\na) Maximum of left and right heights\nb) Minimum of left and right maximum heights\nc) Average of surrounding heights\nd) Current position height\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Product of array except self creates an array where each element is the product of all elements except the current one.",
    "target_text": "Question: In product of array except self, each output element contains:\nChoices:\na) Product of all elements\nb) Product excluding current element\nc) Sum excluding current element\nd) Current element only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Gas station problem determines if there's a starting point to complete a circular journey with given gas and cost arrays.",
    "target_text": "Question: Gas station problem involves completing a:\nChoices:\na) Linear journey\nb) Circular journey\nc) Random path\nd) Shortest path\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Jump game determines if it's possible to reach the last index starting from first index with given jump lengths.",
    "target_text": "Question: Jump game problem aims to reach:\nChoices:\na) Any index\nb) Middle index\nc) Last index\nd) Maximum value index\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Jump game II finds the minimum number of jumps needed to reach the last index from the first index.",
    "target_text": "Question: Jump game II optimizes for:\nChoices:\na) Maximum jumps\nb) Minimum jumps\nc) Average jumps\nd) Total distance\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Candy distribution problem ensures each child gets at least one candy with higher-rated children getting more than neighbors.",
    "target_text": "Question: In candy distribution, higher-rated children must get:\nChoices:\na) Same candies as neighbors\nb) More candies than lower-rated neighbors\nc) Exactly one candy\nd) Maximum possible candies\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Best time to buy and sell stock finds maximum profit from one buy and one sell transaction.",
    "target_text": "Question: Best time to buy and sell stock allows:\nChoices:\na) Multiple transactions\nb) Only one buy-sell transaction\nc) Only buying\nd) Only selling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Best time to buy and sell stock II allows multiple transactions to maximize profit with no limit on transactions.",
    "target_text": "Question: Stock problem II differs from I by allowing:\nChoices:\na) Only one transaction\nb) Multiple transactions\nc) No transactions\nd) Negative profits\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Maximum difference between two elements finds the largest difference where larger element comes after smaller element.",
    "target_text": "Question: In maximum difference problem, the larger element must:\nChoices:\na) Come before smaller element\nb) Come after smaller element\nc) Be adjacent to smaller element\nd) Be at array end\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Smallest subarray with sum greater than given value finds the minimum length subarray whose sum exceeds the target.",
    "target_text": "Question: Smallest subarray with sum greater than X finds subarray with:\nChoices:\na) Exactly sum X\nb) Sum less than X\nc) Sum greater than X\nd) Maximum possible sum\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Subarray with given sum finds a contiguous subarray that sums to the target value.",
    "target_text": "Question: Subarray with given sum problem looks for:\nChoices:\na) Any subsequence\nb) Contiguous subarray\nc) Non-contiguous elements\nd) Single element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Count subarrays with sum equal to k can be solved efficiently using prefix sums and hash map.",
    "target_text": "Question: Count subarrays with sum k is efficiently solved using:\nChoices:\na) Nested loops only\nb) Prefix sums and hash map\nc) Sorting\nd) Binary search\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Maximum length subarray with equal 0s and 1s treats 0s as -1 and finds subarray with sum 0.",
    "target_text": "Question: To find equal 0s and 1s subarray, 0s are treated as:\nChoices:\na) 0\nb) 1\nc) -1\nd) 2\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Longest subarray with equal number of 0s and 1s uses the technique of converting 0s to -1s.",
    "target_text": "Question: After converting 0s to -1s, equal 0s and 1s subarray has sum:\nChoices:\na) 1\nb) -1\nc) 0\nd) n\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Maximum sum of non-adjacent elements ensures that no two selected elements are adjacent in the array.",
    "target_text": "Question: In maximum sum of non-adjacent elements, selected elements:\nChoices:\na) Must be adjacent\nb) Cannot be adjacent\nc) Must be at ends\nd) Must be in middle\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: House robber problem is equivalent to finding maximum sum of non-adjacent elements in an array.",
    "target_text": "Question: House robber problem is equivalent to:\nChoices:\na) Maximum subarray sum\nb) Maximum sum of adjacent elements\nc) Maximum sum of non-adjacent elements\nd) Minimum subarray sum\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Circular array house robber extends the linear version where first and last houses are adjacent.",
    "target_text": "Question: In circular house robber, first and last houses are:\nChoices:\na) Independent\nb) Adjacent\nc) Same house\nd) Not robbable\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Delete and earn problem assigns points for deleting numbers, but deleting x also deletes all x-1 and x+1.",
    "target_text": "Question: In delete and earn, deleting number x also deletes:\nChoices:\na) Only x+1\nb) Only x-1\nc) Both x-1 and x+1\nd) All numbers\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Range sum query with immutable array preprocesses prefix sums to answer range queries in O(1) time.",
    "target_text": "Question: Range sum queries with preprocessing can be answered in:\nChoices:\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Range sum query with mutable array uses segment trees or Fenwick trees for efficient updates and queries.",
    "target_text": "Question: For mutable arrays, range sum queries efficiently use:\nChoices:\na) Simple prefix sums\nb) Segment trees or Fenwick trees\nc) Hash tables\nd) Linked lists\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Segment tree for range queries has O(log n) time complexity for both update and query operations.",
    "target_text": "Question: Segment tree operations have time complexity of:\nChoices:\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n log n)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Fenwick tree (Binary Indexed Tree) provides efficient range sum queries and updates in O(log n) time.",
    "target_text": "Question: Fenwick tree is also known as:\nChoices:\na) Segment tree\nb) Binary Indexed Tree\nc) AVL tree\nd) Red-Black tree\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Sparse table preprocessing allows O(1) range minimum queries on immutable arrays using dynamic programming.",
    "target_text": "Question: Sparse table allows range minimum queries in:\nChoices:\na) O(log n)\nb) O(n)\nc) O(1)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Square root decomposition divides array into √n blocks, balancing update and query time complexities.",
    "target_text": "Question: Square root decomposition divides array into how many blocks:\nChoices:\na) n blocks\nb) log n blocks\nc) √n blocks\nd) n² blocks\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Mo's algorithm efficiently processes offline range queries by reordering them based on block structure.",
    "target_text": "Question: Mo's algorithm works on:\nChoices:\na) Online queries only\nb) Offline queries only\nc) Both online and offline queries\nd) Update queries only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Heavy-Light decomposition decomposes trees into heavy and light edges for efficient path queries.",
    "target_text": "Question: Heavy-Light decomposition is primarily used for:\nChoices:\na) Array queries\nb) Tree path queries\nc) Graph shortest paths\nd) Matrix operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Coordinate compression maps large coordinate values to smaller indices, useful for range queries on large domains.",
    "target_text": "Question: Coordinate compression is used to:\nChoices:\na) Compress file sizes\nb) Map large coordinates to smaller indices\nc) Sort coordinates\nd) Find coordinate distances\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Offline processing allows seeing all queries beforehand, enabling optimizations not possible in online processing.",
    "target_text": "Question: Offline processing advantage is:\nChoices:\na) Faster individual query response\nb) Seeing all queries beforehand\nc) Less memory usage\nd) Simpler implementation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Online processing must handle queries as they arrive without knowing future queries, limiting optimization possibilities.",
    "target_text": "Question: Online processing constraint is:\nChoices:\na) Limited memory\nb) Must handle queries as they arrive\nc) Slower preprocessing\nd) Complex data structures\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Lazy propagation in segment trees defers updates until necessary, improving performance for range updates.",
    "target_text": "Question: Lazy propagation technique:\nChoices:\na) Processes updates immediately\nb) Defers updates until necessary\nc) Ignores some updates\nd) Processes updates in batches\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Difference array technique efficiently handles multiple range updates by storing differences between consecutive elements.",
    "target_text": "Question: Difference array stores:\nChoices:\na) Original array elements\nb) Cumulative sums\nc) Differences between consecutive elements\nd) Maximum values\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Range update with point query can be efficiently handled using difference arrays and prefix sums.",
    "target_text": "Question: Range updates with point queries efficiently use:\nChoices:\na) Segment trees only\nb) Difference arrays and prefix sums\nc) Hash tables\nd) Binary search trees\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Point update with range query is the classic use case for segment trees and Fenwick trees.",
    "target_text": "Question: Point updates with range queries are classically handled by:\nChoices:\na) Arrays only\nb) Linked lists\nc) Segment trees and Fenwick trees\nd) Hash tables\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: 2D range sum queries can be efficiently answered using 2D prefix sums or 2D Fenwick trees.",
    "target_text": "Question: 2D range sum queries efficiently use:\nChoices:\na) 1D prefix sums only\nb) 2D prefix sums or 2D Fenwick trees\nc) Simple nested loops\nd) Hash tables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Matrix exponentiation can solve linear recurrence relations in O(log n) time using matrix multiplication.",
    "target_text": "Question: Matrix exponentiation solves recurrences in:\nChoices:\na) O(n)\nb) O(n²)\nc) O(log n)\nd) O(n³)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Fast exponentiation reduces the time complexity of computing a^n from O(n) to O(log n).",
    "target_text": "Question: Fast exponentiation computes a^n in:\nChoices:\na) O(n)\nb) O(n²)\nc) O(log n)\nd) O(√n)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Modular arithmetic is often used in competitive programming to prevent integer overflow in large computations.",
    "target_text": "Question: Modular arithmetic in programming primarily prevents:\nChoices:\na) Division by zero\nb) Negative numbers\nc) Integer overflow\nd) Floating point errors\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Fermat's little theorem states that if p is prime and a is not divisible by p, then a^(p-1) ≡ 1 (mod p).",
    "target_text": "Question: Fermat's little theorem applies when p is:\nChoices:\na) Any integer\nb) Even number\nc) Prime number\nd) Composite number\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Extended Euclidean algorithm finds integers x and y such that ax + by = gcd(a,b).",
    "target_text": "Question: Extended Euclidean algorithm finds coefficients for:\nChoices:\na) ax + by = lcm(a,b)\nb) ax + by = gcd(a,b)\nc) ax - by = a+b\nd) ax * by = a*b\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Modular inverse of a modulo m exists if and only if gcd(a,m) = 1.",
    "target_text": "Question: Modular inverse exists when gcd(a,m) equals:\nChoices:\na) 0\nb) 1\nc) m\nd) a\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Chinese Remainder Theorem solves systems of linear congruences with pairwise coprime moduli.",
    "target_text": "Question: Chinese Remainder Theorem requires moduli to be:\nChoices:\na) Equal\nb) Prime\nc) Pairwise coprime\nd) Powers of 2\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Combinatorics often involves computing binomial coefficients C(n,k) = n!/(k!(n-k)!) efficiently.",
    "target_text": "Question: Binomial coefficient C(n,k) equals:\nChoices:\na) n!/(k!)\nb) n!/(n-k)!\nc) n!/(k!(n-k)!)\nd) n!/((n-k)!)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Pascal's triangle property states that C(n,k) = C(n-1,k-1) + C(n-1,k).",
    "target_text": "Question: Pascal's triangle relationship is:\nChoices:\na) C(n,k) = C(n-1,k) + C(n,k-1)\nb) C(n,k) = C(n-1,k-1) + C(n-1,k)\nc) C(n,k) = C(n-1,k-1) - C(n-1,k)\nd) C(n,k) = C(n-1,k-1) * C(n-1,k)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Inclusion-exclusion principle calculates the size of union of sets by adding individual sizes and subtracting intersections.",
    "target_text": "Question: Inclusion-exclusion principle involves:\nChoices:\na) Only additions\nb) Only subtractions\nc) Adding individual sizes, subtracting intersections\nd) Multiplying set sizes\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Pigeonhole principle states that if n items are put into m containers with n > m, at least one container must contain multiple items.",
    "target_text": "Question: Pigeonhole principle applies when:\nChoices:\na) n < m\nb) n = m\nc) n > m\nd) n and m are coprime\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Derangement counts permutations where no element appears in its original position, given by !n = n! * Σ((-1)^k/k!).",
    "target_text": "Question: Derangement counts permutations where:\nChoices:\na) All elements are in original positions\nb) No element is in original position\nc) Exactly one element is in original position\nd) At least half elements are in original positions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Catalan numbers count various combinatorial structures like balanced parentheses, binary trees, and path counting problems.",
    "target_text": "Question: Catalan numbers count structures like:\nChoices:\na) All permutations\nb) Balanced parentheses and binary trees\nc) Prime numbers\nd) Fibonacci sequences\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Stirling numbers of the second kind count the number of ways to partition n objects into k non-empty subsets.",
    "target_text": "Question: Stirling numbers of second kind count:\nChoices:\na) Permutations of n objects\nb) Ways to arrange n objects in k groups\nc) Ways to partition n objects into k non-empty subsets\nd) Binary trees with n nodes\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Bell numbers count the total number of ways to partition a set of n objects into non-empty subsets.",
    "target_text": "Question: Bell numbers count total ways to:\nChoices:\na) Arrange n objects\nb) Choose k objects from n\nc) Partition n objects into non-empty subsets\nd) Color n objects with k colors\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Burnside's lemma counts distinct objects under group actions by averaging fixed points over all group elements.",
    "target_text": "Question: Burnside's lemma counts objects under:\nChoices:\na) No constraints\nb) Group actions\nc) Ordering constraints\nd) Size constraints\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Generating functions provide a powerful method to solve recurrence relations and counting problems.",
    "target_text": "Question: Generating functions are primarily used for:\nChoices:\na) Sorting algorithms\nb) Graph traversals\nc) Solving recurrences and counting\nd) String matching\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Probability and expected value calculations often appear in array problems involving random processes.",
    "target_text": "Question: Expected value in probability represents:\nChoices:\na) Maximum possible value\nb) Most likely value\nc) Average value over all outcomes\nd) Minimum possible value\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Linearity of expectation states that E[X + Y] = E[X] + E[Y] regardless of whether X and Y are independent.",
    "target_text": "Question: Linearity of expectation holds:\nChoices:\na) Only for independent variables\nb) Only for dependent variables\nc) Regardless of independence\nd) Only for discrete variables\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Reservoir sampling selects k items from a stream of n items where n is unknown, giving each item equal probability 1/n.",
    "target_text": "Question: Reservoir sampling gives each item probability:\nChoices:\na) 1/k\nb) k/n\nc) 1/n\nd) n/k\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Fisher-Yates shuffle algorithm generates random permutations in O(n) time with perfect uniformity.",
    "target_text": "Question: Fisher-Yates shuffle generates:\nChoices:\na) Sorted arrays\nb) Random permutations\nc) Binary sequences\nd) Hash codes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Monte Carlo methods use random sampling to solve computational problems, often providing approximate solutions.",
    "target_text": "Question: Monte Carlo methods use:\nChoices:\na) Deterministic algorithms\nb) Random sampling\nc) Greedy approaches\nd) Dynamic programming\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Las Vegas algorithms always produce correct results but have randomized running time.",
    "target_text": "Question: Las Vegas algorithms have:\nChoices:\na) Random correctness, fixed time\nb) Fixed correctness, random time\nc) Both random correctness and time\nd) Neither random correctness nor time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Randomized quicksort chooses pivot randomly, making worst-case O(n²) behavior highly unlikely.",
    "target_text": "Question: Randomized quicksort chooses pivot:\nChoices:\na) Always first element\nb) Always middle element\nc) Always last element\nd) Randomly\nAnswer: d"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Skip list is a probabilistic data structure that uses multiple levels of linked lists for efficient search.",
    "target_text": "Question: Skip list uses multiple levels of:\nChoices:\na) Arrays\nb) Trees\nc) Linked lists\nd) Hash tables\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Bloom filter is a space-efficient probabilistic data structure for testing set membership with possible false positives.",
    "target_text": "Question: Bloom filter can have:\nChoices:\na) False positives only\nb) False negatives only\nc) Both false positives and negatives\nd) Neither false positives nor negatives\nAnswer: a"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Count-Min sketch provides approximate frequency counting for data streams using multiple hash functions.",
    "target_text": "Question: Count-Min sketch provides:\nChoices:\na) Exact frequency counts\nb) Approximate frequency counts\nc) Set membership testing\nd) Sorting capabilities\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: HyperLogLog algorithm estimates cardinality (number of distinct elements) in large datasets using very little memory.",
    "target_text": "Question: HyperLogLog estimates:\nChoices:\na) Total number of elements\nb) Average element value\nc) Number of distinct elements\nd) Maximum element value\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Consistent hashing distributes keys across multiple servers while minimizing redistribution when servers are added or removed.",
    "target_text": "Question: Consistent hashing minimizes:\nChoices:\na) Hash collisions\nb) Key redistribution when servers change\nc) Memory usage\nd) Computation time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Load balancing distributes workload across multiple computing resources to optimize resource utilization and response time.",
    "target_text": "Question: Load balancing optimizes:\nChoices:\na) Code complexity only\nb) Memory usage only\nc) Resource utilization and response time\nd) Storage space only\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Cache-friendly algorithms consider memory hierarchy and data locality to improve performance through better cache utilization.",
    "target_text": "Question: Cache-friendly algorithms focus on:\nChoices:\na) Reducing time complexity only\nb) Data locality and cache utilization\nc) Reducing space complexity only\nd) Code readability\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Parallel algorithms divide work among multiple processors, requiring careful consideration of synchronization and communication costs.",
    "target_text": "Question: Parallel algorithms require consideration of:\nChoices:\na) Only computation time\nb) Only memory usage\nc) Synchronization and communication costs\nd) Only code complexity\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: SIMD (Single Instruction, Multiple Data) operations can process multiple array elements simultaneously using vector instructions.",
    "target_text": "Question: SIMD operations process:\nChoices:\na) Single data with multiple instructions\nb) Multiple data with single instruction\nc) Single data with single instruction\nd) Multiple data with multiple instructions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Bit manipulation techniques can solve many array problems efficiently using bitwise operations like XOR, AND, and OR.",
    "target_text": "Question: Bit manipulation uses operations like:\nChoices:\na) Addition and subtraction only\nb) Multiplication and division only\nc) XOR, AND, and OR\nd) Sorting and searching only\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Bit masking represents subsets using binary numbers, where each bit indicates whether an element is included.",
    "target_text": "Question: In bit masking, each bit represents:\nChoices:\na) Element value\nb) Element position\nc) Whether element is included in subset\nd) Element frequency\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Gray code sequences ensure that consecutive numbers differ by exactly one bit, useful in various optimization problems.",
    "target_text": "Question: In Gray code, consecutive numbers differ by:\nChoices:\na) Exactly one bit\nb) At most one bit\nc) At least two bits\nd) All bits\nAnswer: a"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Hamming distance between two binary strings counts the number of positions where the corresponding bits differ.",
    "target_text": "Question: Hamming distance counts positions where bits:\nChoices:\na) Are the same\nb) Differ\nc) Are both 1\nd) Are both 0\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Popcount operation counts the number of set bits (1s) in a binary representation of a number.",
    "target_text": "Question: Popcount operation counts:\nChoices:\na) Total number of bits\nb) Number of zero bits\nc) Number of set bits (1s)\nd) Number of bit positions\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Bit shifting operations multiply or divide by powers of 2, with left shift multiplying and right shift dividing.",
    "target_text": "Question: Left bit shift operation:\nChoices:\na) Divides by 2\nb) Multiplies by 2\nc) Adds 1\nd) Subtracts 1\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Two's complement representation allows efficient arithmetic operations on both positive and negative integers.",
    "target_text": "Question: Two's complement representation is used for:\nChoices:\na) Positive integers only\nb) Negative integers only\nc) Both positive and negative integers\nd) Floating point numbers only\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Overflow detection in integer arithmetic is crucial for preventing incorrect results in array computations.",
    "target_text": "Question: Integer overflow detection prevents:\nChoices:\na) Slow computations\nb) Incorrect results\nc) Memory leaks\nd) Compilation errors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Saturated arithmetic clamps results to maximum or minimum representable values instead of wrapping around on overflow.",
    "target_text": "Question: Saturated arithmetic handles overflow by:\nChoices:\na) Wrapping around\nb) Throwing exceptions\nc) Clamping to min/max values\nd) Ignoring the operation\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array declaration in most programming languages requires specifying the data type and size of the array.",
    "target_text": "Question: What must be specified when declaring an array?\nChoices:\na) Only the data type\nb) Only the size\nc) Both data type and size\nd) Neither data type nor size\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array elements are stored in contiguous memory locations, allowing efficient access through indexing.",
    "target_text": "Question: How are array elements stored in memory:\nChoices:\na) In random locations\nb) In contiguous locations\nc) In separate memory blocks\nd) Only in cache memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Arrays have a fixed size that cannot be changed after declaration in static arrays.",
    "target_text": "Question: What is true about static array size?\nChoices:\na) Can be changed anytime\nb) Cannot be changed after declaration\nc) Changes automatically\nd) Is always unlimited\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array indexing allows direct access to any element using its position number.",
    "target_text": "Question: Array indexing provides:\nChoices:\na) Sequential access only\nb) Random access only\nc) Direct access to any element\nd) No access to elements\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Most programming languages use zero-based indexing where the first element is at index 0.",
    "target_text": "Question: In zero-based indexing, the first element is at index:\nChoices:\na) 1\nb) 0\nc) -1\nd) First\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array bounds checking prevents accessing elements outside the valid index range.",
    "target_text": "Question: Array bounds checking prevents:\nChoices:\na) Slow access\nb) Memory waste\nc) Accessing invalid indices\nd) Data corruption only\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: The length of an array refers to the total number of elements it can hold.",
    "target_text": "Question: Array length refers to:\nChoices:\na) Memory size in bytes\nb) Number of elements it can hold\nc) Index of last element\nd) Data type size\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Arrays can store elements of the same data type, ensuring uniform memory allocation.",
    "target_text": "Question: Arrays store elements of:\nChoices:\na) Different data types\nb) Same data type only\nc) Any data type randomly\nd) No specific type\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Accessing an array element by index takes constant time regardless of array size.",
    "target_text": "Question: Time to access array element by index is:\nChoices:\na) Depends on array size\nb) Always constant\nc) Depends on element value\nd) Always linear\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array initialization assigns initial values to array elements when the array is created.",
    "target_text": "Question: Array initialization involves:\nChoices:\na) Declaring array size\nb) Assigning initial values\nc) Accessing elements\nd) Deleting elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Multi-dimensional arrays store data in rows and columns, like a table or matrix.",
    "target_text": "Question: Multi-dimensional arrays store data in:\nChoices:\na) Single line only\nb) Rows and columns\nc) Random positions\nd) Circular format\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Two-dimensional arrays can be visualized as a grid with rows and columns.",
    "target_text": "Question: A 2D array can be visualized as:\nChoices:\na) A single line\nb) A circle\nc) A grid with rows and columns\nd) A tree structure\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: To access a 2D array element, you need both row and column indices.",
    "target_text": "Question: To access a 2D array element, you need:\nChoices:\na) Only row index\nb) Only column index\nc) Both row and column indices\nd) No indices\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Arrays are homogeneous data structures, meaning all elements are of the same type.",
    "target_text": "Question: Arrays are called homogeneous because:\nChoices:\na) They have the same size\nb) All elements are of same type\nc) They are stored together\nd) They have same values\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array traversal means visiting each element of the array exactly once.",
    "target_text": "Question: Array traversal means:\nChoices:\na) Visiting some elements\nb) Visiting each element exactly once\nc) Visiting elements multiple times\nd) Not visiting any elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Linear search checks each element sequentially until the target is found.",
    "target_text": "Question: Linear search checks elements:\nChoices:\na) Randomly\nb) Sequentially\nc) In reverse only\nd) In pairs\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Finding the maximum element in an array requires checking all elements.",
    "target_text": "Question: To find maximum element in unsorted array, you must:\nChoices:\na) Check only first element\nb) Check only last element\nc) Check all elements\nd) Check middle element\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array insertion at the end is faster than insertion at the beginning.",
    "target_text": "Question: Which insertion is faster in arrays?\nChoices:\na) At the beginning\nb) At the end\nc) In the middle\nd) All are same speed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Deleting an element from an array may require shifting remaining elements.",
    "target_text": "Question: Deleting from array middle requires:\nChoices:\na) No additional operations\nb) Shifting remaining elements\nc) Recreating the array\nd) Sorting the array\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array size is usually fixed at compile time in static arrays.",
    "target_text": "Question: Static array size is determined:\nChoices:\na) At runtime\nb) At compile time\nc) When first accessed\nd) Never determined\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Dynamic arrays can change size during program execution.",
    "target_text": "Question: Dynamic arrays can:\nChoices:\na) Never change size\nb) Change size during execution\nc) Only increase in size\nd) Only decrease in size\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array elements can be modified by assigning new values to specific indices.",
    "target_text": "Question: How can array elements be modified?\nChoices:\na) Cannot be modified\nb) Only by recreation\nc) By assigning new values to indices\nd) Only by sorting\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array copying creates a duplicate array with the same elements.",
    "target_text": "Question: Array copying creates:\nChoices:\na) An empty array\nb) A larger array\nc) A duplicate array with same elements\nd) A sorted version\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Bubble sort compares adjacent elements and swaps them if they are in wrong order.",
    "target_text": "Question: Bubble sort works by comparing:\nChoices:\na) First and last elements\nb) Adjacent elements\nc) Random elements\nd) Middle elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Selection sort finds the minimum element and places it at the beginning.",
    "target_text": "Question: Selection sort repeatedly finds:\nChoices:\na) Maximum element\nb) Minimum element\nc) Middle element\nd) Random element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Insertion sort builds the sorted array one element at a time.",
    "target_text": "Question: Insertion sort builds sorted array:\nChoices:\na) All at once\nb) One element at a time\nc) In reverse order\nd) By halving\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Binary search works only on sorted arrays by repeatedly dividing the search space.",
    "target_text": "Question: Binary search requires array to be:\nChoices:\na) Unsorted\nb) Sorted\nc) Partially sorted\nd) Reverse sorted\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array reversal changes the order of elements from first-to-last to last-to-first.",
    "target_text": "Question: Array reversal changes order to:\nChoices:\na) Random order\nb) Sorted order\nc) Last-to-first order\nd) No change\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Finding duplicates in an array requires comparing elements with each other.",
    "target_text": "Question: To find duplicates in array, you need to:\nChoices:\na) Sort first\nb) Compare elements\nc) Use only loops\nd) Count elements only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array concatenation joins two or more arrays into a single array.",
    "target_text": "Question: Array concatenation means:\nChoices:\na) Sorting arrays\nb) Joining arrays into one\nc) Splitting array\nd) Reversing array\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array slicing extracts a portion of an array into a new array.",
    "target_text": "Question: Array slicing involves:\nChoices:\na) Sorting portion of array\nb) Extracting portion into new array\nc) Deleting elements\nd) Adding elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array frequency counting determines how many times each element appears.",
    "target_text": "Question: Frequency counting determines:\nChoices:\na) Element positions\nb) How many times each element appears\nc) Largest element\nd) Array size\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array rotation shifts elements circularly by a specified number of positions.",
    "target_text": "Question: Array rotation involves:\nChoices:\na) Sorting elements\nb) Shifting elements circularly\nc) Reversing elements\nd) Removing elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array comparison checks if two arrays have the same elements in the same order.",
    "target_text": "Question: Array comparison checks if arrays have:\nChoices:\na) Same size only\nb) Same elements in same order\nc) Same data type only\nd) Same memory location\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array sum calculates the total of all numeric elements in the array.",
    "target_text": "Question: Array sum calculates:\nChoices:\na) Average of elements\nb) Total of all elements\nc) Maximum element\nd) Number of elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array average is calculated by dividing the sum by the number of elements.",
    "target_text": "Question: Array average is calculated by:\nChoices:\na) Sum divided by maximum\nb) Sum divided by number of elements\nc) Sum multiplied by size\nd) Sum minus minimum\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array minimum finds the smallest element present in the array.",
    "target_text": "Question: Array minimum operation finds:\nChoices:\na) First element\nb) Last element\nc) Smallest element\nd) Middle element\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array maximum finds the largest element present in the array.",
    "target_text": "Question: Array maximum operation finds:\nChoices:\na) First element\nb) Largest element\nc) Last element\nd) Average element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array contains operation checks if a specific element exists in the array.",
    "target_text": "Question: Array contains operation:\nChoices:\na) Adds element to array\nb) Removes element from array\nc) Checks if element exists\nd) Counts element occurrences\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array clear operation removes all elements from the array.",
    "target_text": "Question: Array clear operation:\nChoices:\na) Sorts all elements\nb) Removes all elements\nc) Adds elements\nd) Reverses elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array isEmpty checks if the array has no elements.",
    "target_text": "Question: Array isEmpty checks if array:\nChoices:\na) Has maximum elements\nb) Has no elements\nc) Is sorted\nd) Has duplicates\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array resize changes the capacity of dynamic arrays to accommodate more or fewer elements.",
    "target_text": "Question: Array resize changes:\nChoices:\na) Element values\nb) Element order\nc) Array capacity\nd) Element types\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array capacity refers to the maximum number of elements an array can hold.",
    "target_text": "Question: Array capacity refers to:\nChoices:\na) Current number of elements\nb) Maximum elements it can hold\nc) Memory size in bytes\nd) Number of operations performed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array bounds refer to the valid range of indices that can be used to access elements.",
    "target_text": "Question: Array bounds refer to:\nChoices:\na) Element values range\nb) Valid index range\nc) Memory address range\nd) Data type range\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Out of bounds access occurs when trying to access an index outside the valid range.",
    "target_text": "Question: Out of bounds access occurs when accessing:\nChoices:\na) First element\nb) Last element\nc) Index outside valid range\nd) Middle element\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array iteration processes each element in sequence using loops.",
    "target_text": "Question: Array iteration involves:\nChoices:\na) Processing elements randomly\nb) Processing elements in sequence\nc) Processing only first element\nd) Processing only last element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: For loop is commonly used to iterate through array elements using index.",
    "target_text": "Question: For loop in arrays commonly uses:\nChoices:\na) Element values\nb) Array index\nc) Memory addresses\nd) Data types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: While loop can be used for array iteration with proper index management.",
    "target_text": "Question: When using while loop for arrays, you must manage:\nChoices:\na) Element values\nb) Array index\nc) Memory allocation\nd) Data types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Enhanced for loop (for-each) iterates through elements without explicit index management.",
    "target_text": "Question: Enhanced for loop (for-each) eliminates need for:\nChoices:\na) Array declaration\nb) Element access\nc) Explicit index management\nd) Loop termination\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Array indexing starts from 0 in most programming languages like C, Java, and Python.",
    "target_text": "Question: In languages like C, Java, Python, array indexing starts from:\nChoices:\na) 1\nb) 0\nc) -1\nd) 10\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Array | Context: Last element in array of size n is accessed using index n-1 in zero-based indexing.",
    "target_text": "Question: In zero-based indexing, last element of array size n is at index:\nChoices:\na) n\nb) n-1\nc) n+1\nd) 0\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A linked list is a linear data structure where elements are stored in nodes, and each node contains data and a reference to the next node.",
    "target_text": "Question: What does each node in a linked list contain?\nChoices:\na) Only data\nb) Only reference to next node\nc) Data and reference to next node\nd) Index and data\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Unlike arrays, linked list elements are not stored in contiguous memory locations.",
    "target_text": "Question: How are linked list elements stored in memory:\nChoices:\na) In contiguous locations\nb) In non-contiguous locations\nc) Only in cache memory\nd) In sorted order by address\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: The first node in a linked list is called the head node.",
    "target_text": "Question: What is the first node in a linked list called?\nChoices:\na) Start node\nb) Root node\nc) Head node\nd) Front node\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: The last node in a linked list points to NULL, indicating the end of the list.",
    "target_text": "Question: What does the last node in a linked list point to:\nChoices:\na) First node\nb) Previous node\nc) NULL\nd) Itself\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Linked lists allow dynamic memory allocation, meaning nodes can be created and destroyed during runtime.",
    "target_text": "Question: Linked lists support:\nChoices:\na) Static memory allocation only\nb) Dynamic memory allocation\nc) No memory allocation\nd) Fixed size allocation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: To access an element in a linked list, you must traverse from the head node to the desired position.",
    "target_text": "Question: To access an element in a linked list, you must:\nChoices:\na) Use direct indexing\nb) Traverse from head to desired position\nc) Start from the end\nd) Use binary search\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Linked lists do not provide random access to elements like arrays do.",
    "target_text": "Question: Linked lists provide:\nChoices:\na) Random access to elements\nb) Direct access to elements\nc) Sequential access only\nd) No access to elements\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: The size of a linked list can change during program execution by adding or removing nodes.",
    "target_text": "Question: The size of a linked list:\nChoices:\na) Is always fixed\nb) Can change during execution\nc) Cannot be determined\nd) Is set at compile time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Inserting an element at the beginning of a linked list takes constant time O(1).",
    "target_text": "Question: Time complexity of inserting at the beginning of a linked list is:\nChoices:\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A node in a singly linked list contains data and a pointer to the next node.",
    "target_text": "Question: In a singly linked list, each node has:\nChoices:\na) Only data\nb) Data and pointer to next node\nc) Data and pointer to previous node\nd) Data and pointers to both next and previous nodes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A doubly linked list has nodes with pointers to both next and previous nodes.",
    "target_text": "Question: A doubly linked list node contains:\nChoices:\na) Only data\nb) Data and next pointer\nc) Data and previous pointer\nd) Data, next pointer, and previous pointer\nAnswer: d"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In a circular linked list, the last node points back to the first node instead of NULL.",
    "target_text": "Question: In a circular linked list, the last node points to:\nChoices:\na) NULL\nb) Previous node\nc) First node\nd) Middle node\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Creating a new node requires allocating memory and setting the data and pointer fields.",
    "target_text": "Question: Creating a new node involves:\nChoices:\na) Only setting data\nb) Only allocating memory\nc) Allocating memory and setting data/pointer fields\nd) Just declaring a variable\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: An empty linked list is represented by a head pointer that points to NULL.",
    "target_text": "Question: An empty linked list has head pointer pointing to:\nChoices:\na) First node\nb) NULL\nc) Last node\nd) Itself\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Traversing a linked list means visiting each node from head to tail sequentially.",
    "target_text": "Question: Traversing a linked list means:\nChoices:\na) Visiting nodes randomly\nb) Visiting each node from head to tail\nc) Visiting only the first node\nd) Visiting only the last node\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: To insert at the beginning, create a new node and make it point to the current head.",
    "target_text": "Question: To insert at the beginning of a linked list:\nChoices:\na) Add to the end and shift\nb) Create new node and make it point to current head\nc) Replace the head node\nd) Insert in the middle\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Deleting a node requires updating the previous node's pointer to skip the deleted node.",
    "target_text": "Question: When deleting a node, you must:\nChoices:\na) Only free the memory\nb) Update previous node's pointer to skip deleted node\nc) Move all other nodes\nd) Recreate the entire list\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory for linked list nodes is allocated dynamically using malloc() or new operator.",
    "target_text": "Question: Linked list node memory is allocated using:\nChoices:\na) Static allocation\nb) Automatic allocation\nc) Dynamic allocation (malloc/new)\nd) No allocation needed\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: After deleting a node, its memory should be freed to prevent memory leaks.",
    "target_text": "Question: After deleting a node, you should:\nChoices:\na) Leave the memory as is\nb) Free the node's memory\nc) Set data to zero\nd) Move the node elsewhere\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: The advantage of linked lists over arrays is efficient insertion and deletion at any position.",
    "target_text": "Question: Main advantage of linked lists over arrays:\nChoices:\na) Faster access time\nb) Less memory usage\nc) Efficient insertion and deletion\nd) Better cache performance\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: The disadvantage of linked lists is that they don't support random access to elements.",
    "target_text": "Question: Main disadvantage of linked lists:\nChoices:\na) Fixed size\nb) No random access\nc) Cannot store different data types\nd) Require more CPU\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Searching for an element in a linked list requires traversing from the head until found.",
    "target_text": "Question: To search in a linked list, you must:\nChoices:\na) Use binary search\nb) Traverse from head until found\nc) Start from the middle\nd) Use hash table\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: The time complexity of searching in a linked list is O(n) in the worst case.",
    "target_text": "Question: Worst-case time complexity of searching in linked list:\nChoices:\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Finding the length of a linked list requires counting all nodes from head to tail.",
    "target_text": "Question: To find linked list length, you must:\nChoices:\na) Check a size variable\nb) Count all nodes from head to tail\nc) Use built-in function\nd) Check memory allocation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A pointer or reference is used to connect one node to another in a linked list.",
    "target_text": "Question: Nodes in a linked list are connected using:\nChoices:\na) Array indices\nb) Memory addresses directly\nc) Pointers or references\nd) Variable names\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In most implementations, the head pointer stores the address of the first node.",
    "target_text": "Question: The head pointer stores:\nChoices:\na) Data of first node\nb) Address of first node\nc) Size of the list\nd) Address of last node\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: NULL pointer indicates the end of a singly linked list.",
    "target_text": "Question: NULL pointer in linked lists indicates:\nChoices:\na) Beginning of list\nb) End of list\nc) Empty data\nd) Error condition\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: To insert at the end, traverse to the last node and update its next pointer.",
    "target_text": "Question: To insert at the end of a linked list:\nChoices:\na) Replace the head\nb) Insert at beginning and shift\nc) Traverse to last node and update its next pointer\nd) Use array indexing\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Time complexity of inserting at the end of a linked list is O(n) if no tail pointer is maintained.",
    "target_text": "Question: Time complexity of inserting at end (without tail pointer):\nChoices:\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A tail pointer can be maintained to make insertion at the end O(1).",
    "target_text": "Question: Maintaining a tail pointer makes end insertion:\nChoices:\na) O(n)\nb) O(1)\nc) O(log n)\nd) Impossible\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Deleting the first node requires updating the head pointer to point to the second node.",
    "target_text": "Question: When deleting the first node, head pointer should:\nChoices:\na) Point to NULL\nb) Point to the second node\nc) Remain unchanged\nd) Point to the last node\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory overhead in linked lists comes from storing pointers in addition to data.",
    "target_text": "Question: Memory overhead in linked lists is due to:\nChoices:\na) Large data elements\nb) Storing pointers in addition to data\nc) Operating system requirements\nd) Compiler optimizations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Linked lists have poor cache locality compared to arrays due to non-contiguous memory allocation.",
    "target_text": "Question: Linked lists have poor cache locality because:\nChoices:\na) They use pointers\nb) Memory allocation is non-contiguous\nc) They are dynamic\nd) They don't support indexing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Reversing a linked list changes the direction of all next pointers.",
    "target_text": "Question: Reversing a linked list involves:\nChoices:\na) Swapping data values\nb) Changing direction of next pointers\nc) Sorting the elements\nd) Creating a new list\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: When reversing a linked list, you need to keep track of previous, current, and next nodes.",
    "target_text": "Question: For linked list reversal, you typically track:\nChoices:\na) Only current node\nb) Current and next nodes\nc) Previous, current, and next nodes\nd) Only head and tail\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A node typically contains data field and next pointer field.",
    "target_text": "Question: A basic linked list node structure contains:\nChoices:\na) Only data field\nb) Data field and next pointer field\nc) Only pointer field\nd) Data, next, and index fields\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Self-referential structure means a structure contains a pointer to the same structure type.",
    "target_text": "Question: Self-referential structure means:\nChoices:\na) Structure refers to itself by name\nb) Structure contains pointer to same structure type\nc) Structure contains its own data\nd) Structure has no pointers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Dynamic data structure means the size can change during program execution.",
    "target_text": "Question: Dynamic data structure means:\nChoices:\na) Structure changes its type\nb) Size can change during execution\nc) Structure moves in memory\nd) Structure has dynamic typing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Linear data structure means elements are arranged in a sequence where each element is connected to its next element.",
    "target_text": "Question: Linear data structure means elements are:\nChoices:\na) Stored randomly\nb) Arranged in a sequence\nc) Stored in a tree format\nd) Stored in circular format only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: To check if a linked list is empty, verify if the head pointer is NULL.",
    "target_text": "Question: A linked list is empty when:\nChoices:\na) Head points to first node\nb) Head points to NULL\nc) List has one node\nd) Tail points to head\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: The data part of a node can store any data type like integer, string, or custom objects.",
    "target_text": "Question: The data part of a node can store:\nChoices:\na) Only integers\nb) Only strings\nc) Any data type\nd) Only primitive types\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Pointer arithmetic is generally not meaningful in linked lists since nodes are not contiguous.",
    "target_text": "Question: Pointer arithmetic in linked lists is:\nChoices:\na) Very useful\nb) Always required\nc) Generally not meaningful\nd) Only for advanced operations\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory allocation for nodes happens at runtime using dynamic memory allocation functions.",
    "target_text": "Question: Node memory allocation happens:\nChoices:\na) At compile time\nb) At link time\nc) At runtime\nd) Never\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Dangling pointer occurs when a pointer points to memory that has been deallocated.",
    "target_text": "Question: Dangling pointer occurs when pointer points to:\nChoices:\na) Valid memory\nb) NULL\nc) Deallocated memory\nd) Wrong data type\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory leak occurs when allocated memory is not freed after use.",
    "target_text": "Question: Memory leak occurs when:\nChoices:\na) Too much memory is allocated\nb) Allocated memory is not freed\nc) Wrong data type is used\nd) Pointer is set to NULL\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In C language, malloc() is used to allocate memory for new nodes.",
    "target_text": "Question: In C, which function allocates memory for new nodes:\nChoices:\na) calloc()\nb) malloc()\nc) free()\nd) realloc()\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In C language, free() is used to deallocate memory of deleted nodes.",
    "target_text": "Question: In C, which function deallocates node memory:\nChoices:\na) malloc()\nb) calloc()\nc) free()\nd) delete()\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In C++, new operator is used to allocate memory for nodes.",
    "target_text": "Question: In C++, which operator allocates memory for nodes:\nChoices:\na) malloc\nb) new\nc) create\nd) alloc\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In C++, delete operator is used to deallocate memory of nodes.",
    "target_text": "Question: In C++, which operator deallocates node memory:\nChoices:\na) free\nb) remove\nc) delete\nd) destroy\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Segmentation fault can occur when accessing NULL pointers in linked lists.",
    "target_text": "Question: Segmentation fault in linked lists often occurs due to:\nChoices:\na) Too many nodes\nb) Accessing NULL pointers\nc) Wrong data types\nd) Large data values\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Before accessing a node, it's good practice to check if the pointer is not NULL.",
    "target_text": "Question: Before accessing a node, you should check if:\nChoices:\na) Data is valid\nb) Pointer is not NULL\nc) Node is first or last\nd) Memory is available\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Linked list traversal typically uses a temporary pointer that moves from node to node.",
    "target_text": "Question: Linked list traversal typically uses:\nChoices:\na) Index variable\nb) Temporary pointer that moves node to node\nc) Array access\nd) Direct memory addressing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: While loop is commonly used for linked list traversal with condition checking for NULL.",
    "target_text": "Question: For linked list traversal, while loop condition typically checks:\nChoices:\na) Array bounds\nb) Counter variable\nc) Pointer for NULL\nd) Data values\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Inserting at a specific position requires traversing to that position first.",
    "target_text": "Question: To insert at position n in a linked list:\nChoices:\na) Use direct indexing\nb) Traverse to position n first\nc) Start from the end\nd) Use binary search\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: When inserting in the middle, you need to update both previous and new node pointers.",
    "target_text": "Question: When inserting in middle of linked list, you update:\nChoices:\na) Only new node pointer\nb) Only previous node pointer\nc) Both previous and new node pointers\nd) All node pointers\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Deleting the last node requires finding the second-to-last node and setting its next to NULL.",
    "target_text": "Question: To delete the last node, you must:\nChoices:\na) Set head to NULL\nb) Find second-to-last node and set its next to NULL\nc) Delete all nodes\nd) Move last node to beginning\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Finding the middle element can be done efficiently using two pointers (slow and fast).",
    "target_text": "Question: To find middle element efficiently, use:\nChoices:\na) Count nodes then traverse half\nb) Two pointers (slow and fast)\nc) Binary search\nd) Random access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Two pointer technique uses one slow pointer moving one step and one fast pointer moving two steps.",
    "target_text": "Question: In two pointer technique, fast pointer moves:\nChoices:\na) One step at a time\nb) Two steps at a time\nc) Three steps at a time\nd) To the end immediately\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: When fast pointer reaches the end, slow pointer will be at the middle of the list.",
    "target_text": "Question: When fast pointer reaches end, slow pointer is at:\nChoices:\na) Beginning\nb) End\nc) Middle\nd) Random position\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Cycle detection in linked lists can be done using Floyd's cycle detection algorithm.",
    "target_text": "Question: Floyd's cycle detection algorithm is used for:\nChoices:\na) Finding middle element\nb) Detecting cycles in linked lists\nc) Sorting linked lists\nd) Reversing linked lists\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In Floyd's algorithm, if there's a cycle, fast and slow pointers will eventually meet.",
    "target_text": "Question: In Floyd's algorithm, if there's a cycle:\nChoices:\na) Pointers will never meet\nb) Fast and slow pointers will eventually meet\nc) Only slow pointer moves\nd) Both pointers stop\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Comparing two linked lists requires checking both length and element values.",
    "target_text": "Question: To compare two linked lists, check:\nChoices:\na) Only length\nb) Only element values\nc) Both length and element values\nd) Only first element\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Copying a linked list creates a new list with same data but different memory locations.",
    "target_text": "Question: Copying a linked list creates:\nChoices:\na) Same list with same memory\nb) New list with same data but different memory\nc) Empty list\nd) Reversed list\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Merging two sorted linked lists combines them into one sorted list.",
    "target_text": "Question: Merging two sorted linked lists results in:\nChoices:\na) Unsorted combined list\nb) Two separate lists\nc) One sorted combined list\nd) Empty list\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Splitting a linked list divides it into two or more separate lists.",
    "target_text": "Question: Splitting a linked list creates:\nChoices:\na) Same list\nb) Sorted list\nc) Two or more separate lists\nd) Empty list\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Stack operations can be efficiently implemented using linked lists.",
    "target_text": "Question: Stack operations using linked lists are:\nChoices:\na) Inefficient\nb) Impossible\nc) Efficient\nd) Only for push operation\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In stack implementation using linked list, push operation adds element at the head.",
    "target_text": "Question: In linked list stack, push operation adds element at:\nChoices:\na) Tail\nb) Head\nc) Middle\nd) Random position\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In stack implementation using linked list, pop operation removes element from the head.",
    "target_text": "Question: In linked list stack, pop operation removes element from:\nChoices:\na) Tail\nb) Head\nc) Middle\nd) All positions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Queue operations can also be implemented using linked lists with head and tail pointers.",
    "target_text": "Question: For queue implementation, linked list typically uses:\nChoices:\na) Only head pointer\nb) Only tail pointer\nc) Both head and tail pointers\nd) No pointers\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In queue implementation, enqueue adds element at the tail and dequeue removes from head.",
    "target_text": "Question: In linked list queue, enqueue adds at tail and dequeue removes from:\nChoices:\na) Tail\nb) Head\nc) Middle\nd) Both ends\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Linked lists can grow and shrink during runtime without declaring maximum size.",
    "target_text": "Question: Linked lists can grow and shrink:\nChoices:\na) Only at compile time\nb) During runtime without size limit\nc) Only once after creation\nd) Never\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Unlike arrays, linked lists don't waste memory on unused allocated space.",
    "target_text": "Question: Compared to arrays, linked lists:\nChoices:\na) Waste more memory\nb) Don't waste memory on unused space\nc) Use same amount of memory\nd) Cannot store data\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Node creation involves allocating memory and initializing data and pointer fields.",
    "target_text": "Question: Node creation involves:\nChoices:\na) Only memory allocation\nb) Only data initialization\nc) Allocating memory and initializing fields\nd) No special operations\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Proper initialization sets data field to desired value and next pointer to NULL.",
    "target_text": "Question: Proper node initialization sets next pointer to:\nChoices:\na) Head\nb) Previous node\nc) NULL\nd) Random address\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Linked list implementation requires understanding of pointers and dynamic memory management.",
    "target_text": "Question: Linked list implementation requires understanding of:\nChoices:\na) Only loops\nb) Only conditions\nc) Pointers and dynamic memory management\nd) Only arithmetic operations\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Common errors include dereferencing NULL pointers and memory leaks.",
    "target_text": "Question: Common linked list errors include:\nChoices:\na) Only syntax errors\nb) Dereferencing NULL pointers and memory leaks\nc) Only compilation errors\nd) No specific errors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Debugging linked lists often requires tracing pointer values and memory addresses.",
    "target_text": "Question: Debugging linked lists often requires tracing:\nChoices:\na) Only data values\nb) Pointer values and memory addresses\nc) Only loop counters\nd) Only function calls\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Good practice includes checking for NULL before dereferencing and freeing memory after deletion.",
    "target_text": "Question: Good linked list practice includes:\nChoices:\na) Never checking pointers\nb) Checking for NULL and freeing memory\nc) Only allocating memory\nd) Avoiding pointers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Linked list applications include implementing other data structures like stacks and queues.",
    "target_text": "Question: Linked lists are used to implement:\nChoices:\na) Only arrays\nb) Stacks and queues\nc) Only numbers\nd) Only strings\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Real-world applications include music playlists, undo operations, and browser history.",
    "target_text": "Question: Real-world applications of linked lists include:\nChoices:\na) Only mathematical calculations\nb) Music playlists, undo operations, browser history\nc) Only file storage\nd) Only network protocols\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Simple linked list operations are fundamental building blocks for more complex data structures.",
    "target_text": "Question: Simple linked list operations serve as:\nChoices:\na) Complete solutions only\nb) Building blocks for complex data structures\nc) Temporary fixes\nd) Unnecessary complications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Understanding linked lists is essential for learning trees, graphs, and hash tables.",
    "target_text": "Question: Understanding linked lists is essential for learning:\nChoices:\na) Only arrays\nb) Trees, graphs, and hash tables\nc) Only mathematical concepts\nd) Only programming syntax\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A struct or class is typically used to define the node structure in most programming languages.",
    "target_text": "Question: Node structure is typically defined using:\nChoices:\na) Only variables\nb) Arrays only\nc) Struct or class\nd) Functions only\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: The next field in a node stores the address of the next node in the sequence.",
    "target_text": "Question: The next field in a node stores:\nChoices:\na) Data of next node\nb) Address of next node\nc) Index of next node\nd) Size of next node\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Linked lists are preferred when frequent insertions and deletions are required.",
    "target_text": "Question: Linked lists are preferred when you need:\nChoices:\na) Fast random access\nb) Frequent insertions and deletions\nc) Constant memory usage\nd) Cache-friendly access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Arrays are preferred when random access to elements is frequently needed.",
    "target_text": "Question: Arrays are preferred over linked lists when you need:\nChoices:\na) Dynamic size\nb) Frequent random access\nc) Memory efficiency\nd) Pointer operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Time complexity of deletion at beginning is O(1) for linked lists but O(n) for arrays.",
    "target_text": "Question: Deletion at beginning has time complexity:\nChoices:\na) O(1) for both arrays and linked lists\nb) O(n) for both arrays and linked lists\nc) O(1) for linked lists, O(n) for arrays\nd) O(n) for linked lists, O(1) for arrays\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Space complexity of linked lists includes extra memory for storing pointers.",
    "target_text": "Question: Space complexity of linked lists includes extra memory for:\nChoices:\na) Data duplication\nb) Storing pointers\nc) Index calculations\nd) Sorting operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Each node in a doubly linked list has three fields: data, next, and previous.",
    "target_text": "Question: Each node in doubly linked list has how many fields:\nChoices:\na) 1 (data only)\nb) 2 (data and next)\nc) 3 (data, next, and previous)\nd) 4 (data, next, previous, and index)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Doubly linked lists allow traversal in both forward and backward directions.",
    "target_text": "Question: Doubly linked lists allow traversal in:\nChoices:\na) Forward direction only\nb) Backward direction only\nc) Both forward and backward directions\nd) No traversal possible\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In doubly linked lists, insertion and deletion operations are more complex due to maintaining two pointers.",
    "target_text": "Question: Operations in doubly linked lists are more complex because:\nChoices:\na) Data is larger\nb) Need to maintain two pointers\nc) Memory is limited\nd) Traversal is slower\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Circular linked lists have no NULL pointers as the last node points to the first node.",
    "target_text": "Question: Circular linked lists have:\nChoices:\na) Many NULL pointers\nb) No NULL pointers\nc) Only one NULL pointer\nd) Random NULL pointers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Traversing a circular linked list requires special care to avoid infinite loops.",
    "target_text": "Question: When traversing circular linked lists, you must avoid:\nChoices:\na) Accessing data\nb) Infinite loops\nc) Memory allocation\nd) Pointer arithmetic\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A common way to detect end of traversal in circular lists is to check if current pointer equals head.",
    "target_text": "Question: In circular lists, traversal end is detected when:\nChoices:\na) Pointer becomes NULL\nb) Current pointer equals head\nc) Data becomes zero\nd) Memory is full\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Josephus problem is a classic application of circular linked lists.",
    "target_text": "Question: Josephus problem is typically solved using:\nChoices:\na) Arrays\nb) Stacks\nc) Circular linked lists\nd) Trees\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Header node is an extra node at the beginning that simplifies insertion and deletion operations.",
    "target_text": "Question: Header node is used to:\nChoices:\na) Store extra data\nb) Simplify insertion and deletion operations\nc) Increase memory usage\nd) Slow down operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Sentinel node eliminates special cases when dealing with empty lists or boundary conditions.",
    "target_text": "Question: Sentinel node helps eliminate:\nChoices:\na) Memory usage\nb) Special cases and boundary conditions\nc) Data storage\nd) Pointer operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Recursive algorithms can be naturally applied to linked list operations.",
    "target_text": "Question: Recursive algorithms work naturally with linked lists because:\nChoices:\na) Lists are always sorted\nb) Lists have recursive structure\nc) Memory is unlimited\nd) Operations are always fast\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Base case in recursive linked list operations typically involves NULL pointer or single node.",
    "target_text": "Question: Base case in recursive linked list operations typically involves:\nChoices:\na) Large lists only\nb) NULL pointer or single node\nc) Multiple nodes\nd) Infinite recursion\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Iterative solutions often use loops with pointer manipulation for linked list operations.",
    "target_text": "Question: Iterative linked list solutions typically use:\nChoices:\na) Only function calls\nb) Loops with pointer manipulation\nc) Array indexing\nd) Random access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Both iterative and recursive approaches have trade-offs in terms of memory usage and code complexity.",
    "target_text": "Question: Iterative vs recursive approaches differ in:\nChoices:\na) Final results only\nb) Memory usage and code complexity\nc) Data types supported\nd) Hardware requirements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Sorting linked lists can be done using algorithms like merge sort that work well with linked structures.",
    "target_text": "Question: Which sorting algorithm works well with linked lists:\nChoices:\na) Quick sort only\nb) Bubble sort only\nc) Merge sort\nd) Selection sort only\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Merge sort on linked lists has advantage of not requiring extra space for merging.",
    "target_text": "Question: Merge sort on linked lists has advantage of:\nChoices:\na) Being always faster\nb) Not requiring extra space for merging\nc) Working only on sorted lists\nd) Using less code\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Finding nth node from end can be done efficiently using two pointers separated by n positions.",
    "target_text": "Question: To find nth node from end efficiently, use:\nChoices:\na) Count all nodes first\nb) Two pointers separated by n positions\nc) Reverse the list first\nd) Random access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Removing duplicates from linked list requires comparing each node with subsequent nodes.",
    "target_text": "Question: Removing duplicates from linked list requires:\nChoices:\na) Sorting first\nb) Comparing each node with subsequent nodes\nc) Using extra arrays\nd) Reversing the list\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: If linked list is sorted, duplicate removal becomes more efficient as duplicates will be adjacent.",
    "target_text": "Question: In sorted linked lists, duplicate removal is efficient because:\nChoices:\na) Less memory is used\nb) Duplicates are adjacent\nc) Sorting is fast\nd) No duplicates exist\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Intersection of two linked lists finds the first common node where the lists merge.",
    "target_text": "Question: Intersection of two linked lists finds:\nChoices:\na) Common data values\nb) First common node where lists merge\nc) All similar nodes\nd) Longest common subsequence\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Two linked lists intersect if they share same memory addresses for nodes, not just same data values.",
    "target_text": "Question: Two linked lists intersect when they share:\nChoices:\na) Same data values\nb) Same memory addresses for nodes\nc) Same length\nd) Same head pointer\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Palindrome checking in linked lists can be done by reversing half the list and comparing.",
    "target_text": "Question: Palindrome checking in linked lists can use:\nChoices:\na) Only forward traversal\nb) Reversing half the list and comparing\nc) Sorting the list\nd) Random access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Add two numbers represented as linked lists requires handling carry propagation.",
    "target_text": "Question: Adding numbers as linked lists requires handling:\nChoices:\na) Decimal points\nb) Carry propagation\nc) Negative numbers only\nd) Sorting digits\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: LRU cache implementation often uses doubly linked list combined with hash table.",
    "target_text": "Question: LRU cache implementation typically uses:\nChoices:\na) Only arrays\nb) Doubly linked list with hash table\nc) Only stack\nd) Only queue\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Skip list is a probabilistic data structure that builds multiple levels of linked lists.",
    "target_text": "Question: Skip list builds:\nChoices:\na) Single level only\nb) Multiple levels of linked lists\nc) Binary tree structure\nd) Hash table structure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory fragmentation can occur with frequent allocation and deallocation of nodes.",
    "target_text": "Question: Frequent node allocation/deallocation can cause:\nChoices:\na) Faster performance\nb) Memory fragmentation\nc) Automatic sorting\nd) Reduced functionality\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory pool allocation can help reduce fragmentation by pre-allocating chunks of memory.",
    "target_text": "Question: Memory pool allocation helps:\nChoices:\na) Increase memory usage\nb) Reduce fragmentation\nc) Slow down operations\nd) Complicate code only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Garbage collection in managed languages automatically handles memory deallocation for linked lists.",
    "target_text": "Question: Garbage collection automatically handles:\nChoices:\na) Node creation only\nb) Memory deallocation\nc) Data insertion only\nd) Pointer assignment only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: In languages without garbage collection, manual memory management is crucial for linked lists.",
    "target_text": "Question: Without garbage collection, linked lists require:\nChoices:\na) No special handling\nb) Manual memory management\nc) Automatic sorting\nd) Built-in functions only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Smart pointers in modern C++ help automate memory management for linked structures.",
    "target_text": "Question: Smart pointers in C++ help with:\nChoices:\na) Faster access\nb) Automated memory management\nc) Data sorting\nd) Code compilation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Reference counting is one approach to automatic memory management in linked structures.",
    "target_text": "Question: Reference counting is used for:\nChoices:\na) Counting data values\nb) Automatic memory management\nc) Performance optimization\nd) Code documentation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Weak references help break circular dependencies in linked structures.",
    "target_text": "Question: Weak references help break:\nChoices:\na) Data corruption\nb) Circular dependencies\nc) Memory allocation\nd) Code compilation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Parallel processing of linked lists is challenging due to sequential nature and pointer dependencies.",
    "target_text": "Question: Parallel processing of linked lists is challenging due to:\nChoices:\na) Large data size\nb) Sequential nature and pointer dependencies\nc) Complex algorithms\nd) Hardware limitations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Lock-free linked list implementations use atomic operations to enable concurrent access.",
    "target_text": "Question: Lock-free linked lists use:\nChoices:\na) Regular operations only\nb) Atomic operations\nc) Sequential access only\nd) Single threading\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Cache performance of linked lists is generally poor due to non-contiguous memory layout.",
    "target_text": "Question: Cache performance of linked lists is poor due to:\nChoices:\na) Large node size\nb) Non-contiguous memory layout\nc) Complex operations\nd) Pointer overhead only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Prefetching strategies can sometimes improve cache performance for linked list traversals.",
    "target_text": "Question: Prefetching strategies can improve:\nChoices:\na) Memory usage\nb) Cache performance for traversals\nc) Code readability\nd) Compilation speed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Branch prediction in modern CPUs can be negatively affected by irregular access patterns in linked lists.",
    "target_text": "Question: Irregular access patterns in linked lists can negatively affect:\nChoices:\na) Memory size\nb) Branch prediction\nc) Data types\nd) Code syntax\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Testing linked list implementations should include boundary cases like empty lists and single nodes.",
    "target_text": "Question: Testing linked lists should include:\nChoices:\na) Only normal cases\nb) Boundary cases like empty lists and single nodes\nc) Only large lists\nd) Only performance tests\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Unit testing should verify correctness of all basic operations: insert, delete, search, and traverse.",
    "target_text": "Question: Unit testing should verify:\nChoices:\na) Only insertion\nb) All basic operations: insert, delete, search, traverse\nc) Only performance\nd) Only memory usage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory leak detection tools can help identify improper memory management in linked list implementations.",
    "target_text": "Question: Memory leak detection tools help identify:\nChoices:\na) Slow operations\nb) Improper memory management\nc) Code complexity\nd) Algorithm correctness only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Visualizing linked lists with diagrams helps understand pointer relationships and operations.",
    "target_text": "Question: Visualizing linked lists helps understand:\nChoices:\na) Memory addresses only\nb) Pointer relationships and operations\nc) Data values only\nd) Performance metrics\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Step-by-step execution tracing is valuable for debugging complex linked list operations.",
    "target_text": "Question: Step-by-step execution tracing is valuable for:\nChoices:\na) Performance optimization\nb) Debugging complex operations\nc) Memory reduction\nd) Code formatting\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Understanding pointer manipulation is fundamental before attempting advanced linked list operations.",
    "target_text": "Question: Before advanced operations, you must understand:\nChoices:\na) Only data types\nb) Pointer manipulation\nc) Only loops\nd) Only functions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Practice with simple operations builds foundation for complex algorithms and data structures.",
    "target_text": "Question: Practice with simple operations builds foundation for:\nChoices:\na) Basic programming only\nb) Complex algorithms and data structures\nc) Code formatting\nd) Documentation writing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Real-world systems often use hybrid approaches combining linked lists with other data structures.",
    "target_text": "Question: Real-world systems often use:\nChoices:\na) Only linked lists\nb) Hybrid approaches combining multiple data structures\nc) Only arrays\nd) Only primitive types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Database systems use linked structures for various internal operations like index management.",
    "target_text": "Question: Database systems use linked structures for:\nChoices:\na) Only data storage\nb) Internal operations like index management\nc) User interfaces only\nd) Network communication only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Operating systems use linked lists for process scheduling, memory management, and file systems.",
    "target_text": "Question: Operating systems use linked lists for:\nChoices:\na) Only file storage\nb) Process scheduling, memory management, file systems\nc) Only user interfaces\nd) Only network protocols\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Compiler design uses linked structures for symbol tables, syntax trees, and intermediate representations.",
    "target_text": "Question: Compiler design uses linked structures for:\nChoices:\na) Only source code storage\nb) Symbol tables, syntax trees, intermediate representations\nc) Only error messages\nd) Only optimization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Understanding time and space complexity helps choose appropriate data structure for specific problems.",
    "target_text": "Question: Understanding complexity helps:\nChoices:\na) Write better documentation\nb) Choose appropriate data structure for problems\nc) Debug syntax errors\nd) Format code properly\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Trade-offs between different implementations should be considered based on usage patterns.",
    "target_text": "Question: Implementation trade-offs should be considered based on:\nChoices:\na) Code length only\nb) Usage patterns\nc) Programming language only\nd) Hardware specifications only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Mastery of linked lists concepts is essential for understanding more advanced data structures and algorithms.",
    "target_text": "Question: Mastery of linked lists is essential for:\nChoices:\na) Basic programming only\nb) Understanding advanced data structures and algorithms\nc) Web development only\nd) Database administration only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: When creating a node, the constructor typically initializes the data field and sets the next pointer to NULL.",
    "target_text": "Question: In node constructor, the next pointer is typically set to:\nChoices:\na) Previous node\nb) NULL\nc) Head node\nd) Random value\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: A temporary pointer is often used during traversal to avoid losing the reference to the head node.",
    "target_text": "Question: During traversal, a temporary pointer helps:\nChoices:\na) Speed up operations\nb) Avoid losing reference to head node\nc) Reduce memory usage\nd) Sort the list automatically\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: The address-of operator (&) is used to get the memory address of a variable in C/C++.",
    "target_text": "Question: The address-of operator (&) in C/C++ is used to:\nChoices:\na) Dereference a pointer\nb) Get memory address of a variable\nc) Allocate memory\nd) Free memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Dereferencing a pointer using the * operator accesses the value stored at the memory address.",
    "target_text": "Question: Dereferencing a pointer using * operator:\nChoices:\na) Gets the pointer's address\nb) Accesses value at the memory address\nc) Allocates new memory\nd) Deletes the pointer\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Arrow operator (->) is a shorthand for dereferencing a pointer and accessing a member.",
    "target_text": "Question: Arrow operator (->) is shorthand for:\nChoices:\na) Pointer addition\nb) Dereferencing pointer and accessing member\nc) Memory allocation\nd) Pointer comparison\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Dot operator (.) is used to access members of a structure or object directly.",
    "target_text": "Question: Dot operator (.) is used to access members of:\nChoices:\na) Pointers only\nb) Structure or object directly\nc) Arrays only\nd) Functions only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Self-assignment in linked lists (like list = list) should be handled carefully to avoid errors.",
    "target_text": "Question: Self-assignment in linked lists should be:\nChoices:\na) Always allowed\nb) Handled carefully to avoid errors\nc) Never performed\nd) Ignored completely\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Deep copy of a linked list creates new nodes with same data, while shallow copy only copies pointers.",
    "target_text": "Question: Deep copy of linked list creates:\nChoices:\na) Only pointer copies\nb) New nodes with same data\nc) Empty list\nd) Reference to original list\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Shallow copy of linked lists can lead to problems when original list is modified or deleted.",
    "target_text": "Question: Shallow copy can cause problems when:\nChoices:\na) List is traversed\nb) Original list is modified or deleted\nc) New nodes are added\nd) Memory is allocated\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Copy constructor in C++ should create a deep copy to avoid sharing nodes between lists.",
    "target_text": "Question: Copy constructor should create:\nChoices:\na) Shallow copy\nb) Deep copy\nc) No copy\nd) Reference only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Assignment operator overloading in C++ for linked lists should handle self-assignment and create deep copy.",
    "target_text": "Question: Assignment operator overloading should handle:\nChoices:\na) Only new assignments\nb) Self-assignment and create deep copy\nc) Only deletion\nd) Only traversal\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Destructor in C++ should traverse the list and delete all nodes to prevent memory leaks.",
    "target_text": "Question: Destructor should:\nChoices:\na) Only delete head node\nb) Traverse list and delete all nodes\nc) Set pointers to NULL only\nd) Do nothing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: RAII (Resource Acquisition Is Initialization) principle ensures automatic resource management in C++.",
    "target_text": "Question: RAII principle ensures:\nChoices:\na) Fast execution\nb) Automatic resource management\nc) Code readability\nd) Memory expansion\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Exception safety in linked list operations ensures data structure remains in valid state even if exceptions occur.",
    "target_text": "Question: Exception safety ensures data structure:\nChoices:\na) Never throws exceptions\nb) Remains in valid state if exceptions occur\nc) Handles all data types\nd) Runs faster\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Iterator pattern provides a way to traverse linked list elements without exposing internal structure.",
    "target_text": "Question: Iterator pattern provides way to traverse without:\nChoices:\na) Using loops\nb) Exposing internal structure\nc) Accessing data\nd) Using pointers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Forward iterator in linked lists can only move in one direction from beginning to end.",
    "target_text": "Question: Forward iterator can move:\nChoices:\na) In both directions\nb) Only from beginning to end\nc) Only backward\nd) To random positions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Bidirectional iterator allows movement in both forward and backward directions in doubly linked lists.",
    "target_text": "Question: Bidirectional iterator allows movement:\nChoices:\na) Only forward\nb) In both forward and backward directions\nc) Only backward\nd) To random positions only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Constant iterator prevents modification of data while allowing traversal of the linked list.",
    "target_text": "Question: Constant iterator prevents:\nChoices:\na) Traversal\nb) Modification of data\nc) Memory allocation\nd) Pointer operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Generic linked lists use templates or generics to work with any data type.",
    "target_text": "Question: Generic linked lists use templates to:\nChoices:\na) Increase speed\nb) Work with any data type\nc) Reduce memory\nd) Simplify syntax\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Template specialization allows different implementations for specific data types in generic linked lists.",
    "target_text": "Question: Template specialization allows:\nChoices:\na) Only one implementation\nb) Different implementations for specific data types\nc) Automatic memory management\nd) Faster compilation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Type safety in generic linked lists prevents mixing incompatible data types.",
    "target_text": "Question: Type safety prevents:\nChoices:\na) Memory allocation\nb) Mixing incompatible data types\nc) Fast access\nd) Pointer operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Function pointers can be used to make linked list operations more flexible and reusable.",
    "target_text": "Question: Function pointers make operations:\nChoices:\na) Slower\nb) More flexible and reusable\nc) More complex only\nd) Memory intensive\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Callback functions allow customization of linked list operations like comparison or printing.",
    "target_text": "Question: Callback functions allow:\nChoices:\na) Automatic execution\nb) Customization of operations\nc) Memory reduction\nd) Error elimination\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Lambda expressions in modern languages provide inline function definitions for linked list operations.",
    "target_text": "Question: Lambda expressions provide:\nChoices:\na) Better performance only\nb) Inline function definitions\nc) Automatic memory management\nd) Error checking\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Higher-order functions that take other functions as parameters work well with linked list processing.",
    "target_text": "Question: Higher-order functions take:\nChoices:\na) Only data parameters\nb) Other functions as parameters\nc) No parameters\nd) Only primitive types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Immutable linked lists create new nodes instead of modifying existing ones.",
    "target_text": "Question: Immutable linked lists:\nChoices:\na) Modify existing nodes\nb) Create new nodes instead of modifying\nc) Never change size\nd) Use less memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Persistent data structures allow access to previous versions after modifications.",
    "target_text": "Question: Persistent data structures allow access to:\nChoices:\na) Current version only\nb) Previous versions after modifications\nc) Future versions\nd) Random versions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Structural sharing in immutable lists reuses unchanged parts to save memory.",
    "target_text": "Question: Structural sharing reuses unchanged parts to:\nChoices:\na) Increase speed\nb) Save memory\nc) Improve readability\nd) Reduce complexity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Copy-on-write optimization delays copying until actual modification is needed.",
    "target_text": "Question: Copy-on-write delays copying until:\nChoices:\na) Program starts\nb) Actual modification is needed\nc) Memory is full\nd) List is traversed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Thread safety in linked lists requires synchronization mechanisms when accessed by multiple threads.",
    "target_text": "Question: Thread safety requires:\nChoices:\na) Single threading only\nb) Synchronization mechanisms\nc) More memory\nd) Special hardware\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Mutex locks provide mutual exclusion to prevent race conditions in concurrent linked list access.",
    "target_text": "Question: Mutex locks provide mutual exclusion to prevent:\nChoices:\na) Memory leaks\nb) Race conditions\nc) Slow performance\nd) Code complexity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Read-write locks allow multiple readers but only one writer for linked list operations.",
    "target_text": "Question: Read-write locks allow:\nChoices:\na) Only one reader\nb) Multiple readers but only one writer\nc) Multiple writers\nd) No concurrent access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Atomic compare-and-swap operations enable lock-free implementations of linked list modifications.",
    "target_text": "Question: Atomic compare-and-swap enables:\nChoices:\na) Faster locks\nb) Lock-free implementations\nc) Better memory usage\nd) Simpler code\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: ABA problem in concurrent programming occurs when a value changes and then changes back.",
    "target_text": "Question: ABA problem occurs when value:\nChoices:\na) Never changes\nb) Changes and then changes back\nc) Changes once only\nd) Changes randomly\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Hazard pointers help manage memory safely in lock-free linked list implementations.",
    "target_text": "Question: Hazard pointers help manage:\nChoices:\na) Lock acquisition\nb) Memory safely in lock-free implementations\nc) Thread priorities\nd) Performance optimization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory ordering constraints ensure proper synchronization in concurrent linked list operations.",
    "target_text": "Question: Memory ordering constraints ensure:\nChoices:\na) Faster execution\nb) Proper synchronization\nc) Less memory usage\nd) Code simplicity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Profiling tools help identify performance bottlenecks in linked list implementations.",
    "target_text": "Question: Profiling tools help identify:\nChoices:\na) Syntax errors\nb) Performance bottlenecks\nc) Memory addresses\nd) Code formatting issues\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Benchmark testing compares performance of different linked list implementations under various conditions.",
    "target_text": "Question: Benchmark testing compares:\nChoices:\na) Code length only\nb) Performance of different implementations\nc) Memory addresses\nd) Compilation time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Cache miss analysis helps understand memory access patterns in linked list operations.",
    "target_text": "Question: Cache miss analysis helps understand:\nChoices:\na) Code complexity\nb) Memory access patterns\nc) Thread synchronization\nd) Algorithm correctness\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory bandwidth utilization affects performance of linked list operations on modern systems.",
    "target_text": "Question: Memory bandwidth utilization affects:\nChoices:\na) Code readability\nb) Performance of operations\nc) Compilation speed\nd) Debugging ease\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: NUMA (Non-Uniform Memory Access) architectures can impact linked list performance based on memory locality.",
    "target_text": "Question: NUMA architectures impact performance based on:\nChoices:\na) Code structure\nb) Memory locality\nc) Thread count\nd) Algorithm choice\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Data structure alignment can affect cache performance and memory usage in linked lists.",
    "target_text": "Question: Data structure alignment affects:\nChoices:\na) Code correctness only\nb) Cache performance and memory usage\nc) Compilation time\nd) Thread safety\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Padding in structures may be added by compiler to align data on memory boundaries.",
    "target_text": "Question: Padding in structures is added to:\nChoices:\na) Increase data size\nb) Align data on memory boundaries\nc) Improve readability\nd) Reduce compilation time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Pack pragma directive can minimize padding but may hurt performance on some architectures.",
    "target_text": "Question: Pack pragma directive can minimize padding but may:\nChoices:\na) Improve performance always\nb) Hurt performance on some architectures\nc) Increase memory usage\nd) Cause compilation errors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Custom memory allocators can improve performance by reducing system call overhead.",
    "target_text": "Question: Custom memory allocators improve performance by:\nChoices:\na) Using more memory\nb) Reducing system call overhead\nc) Increasing code complexity\nd) Using multiple threads\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Object pooling reuses allocated nodes instead of constantly allocating and deallocating.",
    "target_text": "Question: Object pooling reuses nodes instead of:\nChoices:\na) Traversing lists\nb) Constantly allocating and deallocating\nc) Accessing data\nd) Comparing values\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Slab allocation provides efficient memory management for objects of same size like linked list nodes.",
    "target_text": "Question: Slab allocation provides efficient management for:\nChoices:\na) Variable-sized objects\nb) Objects of same size\nc) Large objects only\nd) System resources\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Buddy allocation system divides memory into powers of 2 to reduce fragmentation.",
    "target_text": "Question: Buddy allocation divides memory into powers of 2 to:\nChoices:\na) Increase speed\nb) Reduce fragmentation\nc) Simplify code\nd) Use less memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Garbage collection pauses can affect real-time performance of linked list operations.",
    "target_text": "Question: Garbage collection pauses can affect:\nChoices:\na) Code correctness\nb) Real-time performance\nc) Memory size\nd) Algorithm choice\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Incremental garbage collection spreads collection work over time to reduce pause times.",
    "target_text": "Question: Incremental garbage collection spreads work to:\nChoices:\na) Use more memory\nb) Reduce pause times\nc) Increase throughput\nd) Simplify implementation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Generational garbage collection assumes younger objects are more likely to become garbage.",
    "target_text": "Question: Generational garbage collection assumes younger objects are:\nChoices:\na) More important\nb) More likely to become garbage\nc) Larger in size\nd) More complex\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Mark-and-sweep garbage collection marks reachable objects then sweeps away unreachable ones.",
    "target_text": "Question: Mark-and-sweep collection marks reachable objects then:\nChoices:\na) Copies them\nb) Sweeps away unreachable ones\nc) Compacts memory\nd) Sorts them\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Copying garbage collection moves live objects to new space and frees old space entirely.",
    "target_text": "Question: Copying garbage collection moves live objects and:\nChoices:\na) Marks old objects\nb) Frees old space entirely\nc) Compresses data\nd) Sorts objects\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Memory-mapped files can provide persistent storage for linked list data structures.",
    "target_text": "Question: Memory-mapped files provide:\nChoices:\na) Faster access only\nb) Persistent storage\nc) Better compression\nd) Thread safety\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Serialization converts linked list structure into format suitable for storage or transmission.",
    "target_text": "Question: Serialization converts structure into format suitable for:\nChoices:\na) Faster processing\nb) Storage or transmission\nc) Memory optimization\nd) Thread synchronization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Deserialization reconstructs linked list from serialized format back into memory structure.",
    "target_text": "Question: Deserialization reconstructs list from serialized format back into:\nChoices:\na) File storage\nb) Memory structure\nc) Network packets\nd) Compressed format\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Binary serialization is more compact but less human-readable than text-based formats.",
    "target_text": "Question: Binary serialization is more compact but:\nChoices:\na) Slower to process\nb) Less human-readable\nc) Uses more memory\nd) Less secure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: JSON serialization provides human-readable format but may be less efficient for large lists.",
    "target_text": "Question: JSON serialization provides human-readable format but may be:\nChoices:\na) More secure\nb) Less efficient for large lists\nc) Faster to process\nd) More compact\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Protocol buffers provide efficient binary serialization with schema evolution support.",
    "target_text": "Question: Protocol buffers provide efficient binary serialization with:\nChoices:\na) Better readability\nb) Schema evolution support\nc) Larger file sizes\nd) Simpler implementation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Version compatibility ensures serialized data can be read by different versions of software.",
    "target_text": "Question: Version compatibility ensures serialized data can be read by:\nChoices:\na) Same version only\nb) Different versions of software\nc) Any programming language\nd) Different hardware only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Checksum validation helps detect corruption in serialized linked list data.",
    "target_text": "Question: Checksum validation helps detect:\nChoices:\na) Performance issues\nb) Corruption in serialized data\nc) Memory leaks\nd) Thread conflicts\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Compression algorithms can reduce storage size of serialized linked list data.",
    "target_text": "Question: Compression algorithms can reduce:\nChoices:\na) Processing time\nb) Storage size of serialized data\nc) Memory fragmentation\nd) Thread overhead\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Encryption protects sensitive linked list data during storage and transmission.",
    "target_text": "Question: Encryption protects sensitive data during:\nChoices:\na) Compilation only\nb) Storage and transmission\nc) Development only\nd) Testing only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Network protocols often use linked structures for packet queuing and routing information.",
    "target_text": "Question: Network protocols use linked structures for:\nChoices:\na) Only error detection\nb) Packet queuing and routing information\nc) Only encryption\nd) Only compression\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Distributed systems may use linked lists for maintaining consistent ordering across nodes.",
    "target_text": "Question: Distributed systems use linked lists for maintaining:\nChoices:\na) Network speed\nb) Consistent ordering across nodes\nc) Security levels\nd) Storage efficiency\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Event-driven programming often uses linked lists for maintaining event queues and handlers.",
    "target_text": "Question: Event-driven programming uses linked lists for:\nChoices:\na) Only user interfaces\nb) Event queues and handlers\nc) Only network communication\nd) Only file operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Message passing systems use linked structures for buffering and ordering messages.",
    "target_text": "Question: Message passing systems use linked structures for:\nChoices:\na) Only synchronization\nb) Buffering and ordering messages\nc) Only error handling\nd) Only routing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Real-time systems require predictable performance, making linked lists suitable for certain operations.",
    "target_text": "Question: Real-time systems require:\nChoices:\na) Maximum throughput\nb) Predictable performance\nc) Minimum memory usage\nd) Complex algorithms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Embedded systems with limited memory may use specialized linked list implementations.",
    "target_text": "Question: Embedded systems with limited memory may use:\nChoices:\na) Standard implementations only\nb) Specialized linked list implementations\nc) Only arrays\nd) Only static structures\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Educational value of linked lists includes understanding pointers, memory management, and recursive thinking.",
    "target_text": "Question: Educational value of linked lists includes understanding:\nChoices:\na) Only syntax\nb) Pointers, memory management, and recursive thinking\nc) Only algorithms\nd) Only performance\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Problem-solving skills developed through linked lists transfer to many other programming challenges.",
    "target_text": "Question: Skills developed through linked lists:\nChoices:\na) Apply only to lists\nb) Transfer to many other programming challenges\nc) Are obsolete in modern programming\nd) Only help with academic problems\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Algorithmic thinking improves through practice with linked list manipulation and traversal problems.",
    "target_text": "Question: Algorithmic thinking improves through practice with:\nChoices:\na) Only theoretical concepts\nb) Linked list manipulation and traversal problems\nc) Only mathematical formulas\nd) Only syntax memorization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Code organization and modularity concepts are reinforced when implementing linked list operations.",
    "target_text": "Question: Linked list implementation reinforces concepts of:\nChoices:\na) Only performance optimization\nb) Code organization and modularity\nc) Only memory management\nd) Only debugging techniques\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Abstract thinking develops as students learn to visualize and manipulate pointer relationships.",
    "target_text": "Question: Abstract thinking develops through:\nChoices:\na) Only reading theory\nb) Visualizing and manipulating pointer relationships\nc) Only writing syntax\nd) Only memorizing algorithms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Linked List | Context: Foundation concepts learned with linked lists apply to advanced topics like graph algorithms and tree traversals.",
    "target_text": "Question: Foundation concepts from linked lists apply to:\nChoices:\na) Only basic programming\nb) Graph algorithms and tree traversals\nc) Only web development\nd) Only database design\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: A stack is a linear data structure that follows the Last In First Out (LIFO) principle.",
    "target_text": "Question: What principle does a stack follow?\nChoices:\na) First In First Out (FIFO)\nb) Last In First Out (LIFO)\nc) Random access\nd) Sorted order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: In LIFO principle, the last element added to the stack is the first one to be removed.",
    "target_text": "Question: In LIFO principle, which element is removed first:\nChoices:\na) First element added\nb) Last element added\nc) Middle element\nd) Random element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: The top of the stack is where elements are added and removed from.",
    "target_text": "Question: Where are elements added and removed in a stack?\nChoices:\na) Bottom\nb) Middle\nc) Top\nd) Any position\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Push operation adds an element to the top of the stack.",
    "target_text": "Question: What does the push operation do:\nChoices:\na) Removes element from top\nb) Adds element to top\nc) Views top element\nd) Checks if stack is empty\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Pop operation removes and returns the top element from the stack.",
    "target_text": "Question: What does the pop operation do?\nChoices:\na) Adds element to stack\nb) Removes and returns top element\nc) Views top element without removing\nd) Clears entire stack\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Peek or top operation returns the top element without removing it from the stack.",
    "target_text": "Question: Peek operation:\nChoices:\na) Removes top element\nb) Returns top element without removing\nc) Adds new element\nd) Counts stack elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: isEmpty operation checks whether the stack contains any elements.",
    "target_text": "Question: What does isEmpty operation check?\nChoices:\na) If stack is full\nb) If stack contains any elements\nc) Size of stack\nd) Top element value\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack overflow occurs when trying to push an element onto a full stack.",
    "target_text": "Question: Stack overflow occurs when:\nChoices:\na) Popping from empty stack\nb) Pushing onto full stack\nc) Peeking at empty stack\nd) Stack is half full\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack underflow occurs when trying to pop from an empty stack.",
    "target_text": "Question: Stack underflow occurs when:\nChoices:\na) Pushing onto full stack\nb) Popping from empty stack\nc) Stack is half empty\nd) Peeking at full stack\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stacks can be implemented using arrays with a top pointer indicating the current top element.",
    "target_text": "Question: In array implementation, what indicates current top element?\nChoices:\na) Size variable\nb) Top pointer\nc) Bottom pointer\nd) Middle index\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stacks can also be implemented using linked lists where new elements are added at the head.",
    "target_text": "Question: In linked list implementation, new elements are added at:\nChoices:\na) Tail\nb) Head\nc) Middle\nd) Random position\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Array implementation has fixed size while linked list implementation has dynamic size.",
    "target_text": "Question: Which implementation has dynamic size?\nChoices:\na) Array implementation\nb) Linked list implementation\nc) Both have same size\nd) Neither can change size\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Time complexity of push operation is O(1) for both array and linked list implementations.",
    "target_text": "Question: Time complexity of push operation is:\nChoices:\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Time complexity of pop operation is O(1) for both array and linked list implementations.",
    "target_text": "Question: Time complexity of pop operation is:\nChoices:\na) O(n)\nb) O(1)\nc) O(log n)\nd) O(n²)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Space complexity of stack operations is O(1) as they don't require additional space proportional to input.",
    "target_text": "Question: Space complexity of basic stack operations is:\nChoices:\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n²)\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stacks are used for function call management in programming languages.",
    "target_text": "Question: Stacks are used for:\nChoices:\na) Random access to data\nb) Function call management\nc) Sorting data\nd) Database indexing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Each function call creates a new stack frame containing local variables and parameters.",
    "target_text": "Question: Stack frame contains:\nChoices:\na) Global variables only\nb) Local variables and parameters\nc) Function names only\nd) Return addresses only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: When a function returns, its stack frame is popped from the call stack.",
    "target_text": "Question: When function returns, its stack frame is:\nChoices:\na) Moved to bottom\nb) Popped from call stack\nc) Duplicated\nd) Kept permanently\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Expression evaluation uses stacks to handle operator precedence and parentheses.",
    "target_text": "Question: Expression evaluation uses stacks to handle:\nChoices:\na) Variable names\nb) Operator precedence and parentheses\nc) Function definitions\nd) Memory allocation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Infix expressions are converted to postfix using stacks for easier evaluation.",
    "target_text": "Question: Infix expressions are converted to postfix for:\nChoices:\na) Better readability\nb) Easier evaluation\nc) Smaller size\nd) Faster typing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Postfix expressions can be evaluated using a single stack without considering operator precedence.",
    "target_text": "Question: Postfix evaluation uses stack without considering:\nChoices:\na) Operands\nb) Operator precedence\nc) Result values\nd) Expression length\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Undo operations in text editors and applications are implemented using stacks.",
    "target_text": "Question: Undo operations are implemented using:\nChoices:\na) Arrays\nb) Stacks\nc) Trees\nd) Hash tables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Each operation that can be undone is pushed onto the undo stack.",
    "target_text": "Question: Operations that can be undone are:\nChoices:\na) Stored in database\nb) Pushed onto undo stack\nc) Ignored\nd) Executed immediately\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Browser history navigation uses stacks to track visited pages for back button functionality.",
    "target_text": "Question: Browser back button functionality uses:\nChoices:\na) Queues\nb) Stacks to track visited pages\nc) Arrays\nd) Linked lists\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Balanced parentheses checking is a classic application of stacks in programming.",
    "target_text": "Question: Balanced parentheses checking uses:\nChoices:\na) Queues\nb) Stacks\nc) Trees\nd) Graphs\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: For balanced parentheses, opening brackets are pushed and closing brackets cause a pop operation.",
    "target_text": "Question: In balanced parentheses checking, opening brackets are:\nChoices:\na) Ignored\nb) Pushed onto stack\nc) Counted only\nd) Removed immediately\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: If stack is empty when all characters are processed, parentheses are balanced.",
    "target_text": "Question: Parentheses are balanced if stack is empty when:\nChoices:\na) First bracket is found\nb) All characters are processed\nc) Stack becomes full\nd) Error occurs\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Recursion elimination can be achieved by using explicit stacks instead of function calls.",
    "target_text": "Question: Recursion elimination uses:\nChoices:\na) More recursive calls\nb) Explicit stacks instead of function calls\nc) Global variables\nd) Database storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack-based algorithms can avoid stack overflow issues that occur with deep recursion.",
    "target_text": "Question: Stack-based algorithms can avoid:\nChoices:\na) Memory usage\nb) Stack overflow from deep recursion\nc) Time complexity\nd) Code complexity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: DFS (Depth First Search) can be implemented using stacks for graph traversal.",
    "target_text": "Question: DFS graph traversal can be implemented using:\nChoices:\na) Queues\nb) Stacks\nc) Arrays only\nd) Hash tables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: In array implementation, the top variable starts at -1 for an empty stack.",
    "target_text": "Question: In array implementation, empty stack has top value:\nChoices:\na) 0\nb) -1\nc) 1\nd) NULL\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Before popping, you should check if the stack is empty to avoid underflow.",
    "target_text": "Question: Before popping, you should check if stack is:\nChoices:\na) Full\nb) Empty\nc) Sorted\nd) Large\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Before pushing, you should check if the stack is full in array implementation.",
    "target_text": "Question: Before pushing in array implementation, check if stack is:\nChoices:\na) Empty\nb) Full\nc) Sorted\nd) Small\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack size operation returns the number of elements currently in the stack.",
    "target_text": "Question: Stack size operation returns:\nChoices:\na) Maximum capacity\nb) Number of elements currently in stack\nc) Memory used\nd) Top element value\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Clear operation removes all elements from the stack, making it empty.",
    "target_text": "Question: Clear operation:\nChoices:\na) Sorts stack elements\nb) Removes all elements making stack empty\nc) Adds elements\nd) Finds maximum element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack can store elements of any data type including integers, strings, and objects.",
    "target_text": "Question: Stack can store:\nChoices:\na) Only integers\nb) Any data type\nc) Only strings\nd) Only primitive types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Generic stacks use templates or generics to work with different data types.",
    "target_text": "Question: Generic stacks use templates to:\nChoices:\na) Increase speed\nb) Work with different data types\nc) Reduce memory\nd) Simplify code only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack iterator allows traversal of stack elements without modifying the stack.",
    "target_text": "Question: Stack iterator allows:\nChoices:\na) Modifying stack elements\nb) Traversal without modifying stack\nc) Only adding elements\nd) Only removing elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack is a restricted data structure as elements can only be accessed from one end.",
    "target_text": "Question: Stack is restricted because:\nChoices:\na) It's slow\nb) Elements can only be accessed from one end\nc) It uses more memory\nd) It's complex to implement\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack follows abstract data type (ADT) principles with defined operations and hidden implementation.",
    "target_text": "Question: Stack ADT has:\nChoices:\na) Visible implementation\nb) Defined operations and hidden implementation\nc) No defined operations\nd) Only one operation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Multiple stacks can be implemented in a single array by dividing the array into sections.",
    "target_text": "Question: Multiple stacks in single array require:\nChoices:\na) Separate arrays\nb) Dividing array into sections\nc) Linked lists only\nd) External memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Two stacks can efficiently share an array by growing from opposite ends.",
    "target_text": "Question: Two stacks can share array by:\nChoices:\na) Using same end\nb) Growing from opposite ends\nc) Alternating elements\nd) Using external storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack implementation choice depends on whether you need fixed or dynamic size.",
    "target_text": "Question: Implementation choice depends on:\nChoices:\na) Programming language only\nb) Whether you need fixed or dynamic size\nc) Available memory only\nd) Programmer preference only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Dynamic array implementation combines benefits of both array and linked list approaches.",
    "target_text": "Question: Dynamic array implementation combines benefits of:\nChoices:\na) Only arrays\nb) Array and linked list approaches\nc) Only linked lists\nd) Trees and graphs\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack memory is automatically managed by the system for local variables and function calls.",
    "target_text": "Question: Stack memory is managed by:\nChoices:\na) Programmer manually\nb) System automatically\nc) Garbage collector only\nd) External tools\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Heap memory is used for dynamic allocation while stack memory is for automatic allocation.",
    "target_text": "Question: Stack memory is used for:\nChoices:\na) Dynamic allocation\nb) Automatic allocation\nc) Permanent storage\nd) Global variables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack frame contains return address, local variables, and function parameters.",
    "target_text": "Question: Stack frame contains:\nChoices:\na) Only return address\nb) Return address, local variables, and parameters\nc) Only global variables\nd) Only function code\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Activation record is another name for stack frame in function call management.",
    "target_text": "Question: Activation record is another name for:\nChoices:\na) Function definition\nb) Stack frame\nc) Global variable\nd) Return value\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack pointer register in CPU keeps track of the current top of the system stack.",
    "target_text": "Question: Stack pointer register keeps track of:\nChoices:\na) Program counter\nb) Current top of system stack\nc) Instruction cache\nd) Memory size\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Base pointer register helps access local variables and parameters within a function.",
    "target_text": "Question: Base pointer register helps access:\nChoices:\na) Global variables only\nb) Local variables and parameters\nc) System functions\nd) Hardware registers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack grows downward in memory addresses on most computer architectures.",
    "target_text": "Question: On most architectures, stack grows:\nChoices:\na) Upward in memory\nb) Downward in memory\nc) In both directions\nd) Randomly\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack size limit prevents infinite recursion from crashing the system.",
    "target_text": "Question: Stack size limit prevents:\nChoices:\na) Fast execution\nb) Infinite recursion from crashing system\nc) Memory allocation\nd) Function calls\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Tower of Hanoi is a classic recursive problem that can be solved using stacks.",
    "target_text": "Question: Tower of Hanoi can be solved using:\nChoices:\na) Queues only\nb) Stacks\nc) Arrays only\nd) Hash tables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: N-Queens problem backtracking can be implemented using stacks to track board states.",
    "target_text": "Question: N-Queens backtracking uses stacks to track:\nChoices:\na) Queen positions only\nb) Board states\nc) Attack patterns only\nd) Solution count\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Maze solving algorithms use stacks to backtrack when dead ends are encountered.",
    "target_text": "Question: Maze solving uses stacks to:\nChoices:\na) Store maze layout\nb) Backtrack from dead ends\nc) Count steps\nd) Find shortest path only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Compiler design uses stacks for syntax analysis and parsing expressions.",
    "target_text": "Question: Compilers use stacks for:\nChoices:\na) Code generation only\nb) Syntax analysis and parsing\nc) Optimization only\nd) Error reporting only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Operator precedence parsing uses operator stack and operand stack for expression evaluation.",
    "target_text": "Question: Operator precedence parsing uses:\nChoices:\na) Single stack only\nb) Operator stack and operand stack\nc) No stacks\nd) Queue only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: LR parsers use parsing stack to keep track of grammar symbols during syntax analysis.",
    "target_text": "Question: LR parsers use parsing stack to track:\nChoices:\na) Tokens only\nb) Grammar symbols during analysis\nc) Error messages\nd) Parse tree nodes only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: JVM (Java Virtual Machine) uses operand stack for bytecode instruction execution.",
    "target_text": "Question: JVM uses operand stack for:\nChoices:\na) Memory management\nb) Bytecode instruction execution\nc) Garbage collection\nd) Class loading\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Assembly language PUSH instruction adds data to the top of the stack.",
    "target_text": "Question: PUSH instruction in assembly:\nChoices:\na) Removes data from stack\nb) Adds data to top of stack\nc) Compares stack values\nd) Clears the stack\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Assembly language POP instruction removes data from the top of the stack.",
    "target_text": "Question: POP instruction in assembly:\nChoices:\na) Adds data to stack\nb) Removes data from top of stack\nc) Duplicates top element\nd) Sorts stack contents\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Function prologue sets up stack frame by saving base pointer and allocating local space.",
    "target_text": "Question: Function prologue sets up stack frame by:\nChoices:\na) Only saving return address\nb) Saving base pointer and allocating local space\nc) Only allocating memory\nd) Clearing registers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Function epilogue cleans up stack frame by restoring base pointer and deallocating space.",
    "target_text": "Question: Function epilogue cleans up by:\nChoices:\na) Only jumping to return address\nb) Restoring base pointer and deallocating space\nc) Only clearing registers\nd) Saving all variables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Tail recursion optimization can eliminate stack frame creation for certain recursive calls.",
    "target_text": "Question: Tail recursion optimization eliminates:\nChoices:\na) All function calls\nb) Stack frame creation for certain recursive calls\nc) Return values\nd) Local variables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack-based virtual machines use stack for all computations instead of registers.",
    "target_text": "Question: Stack-based virtual machines use stack for:\nChoices:\na) Storage only\nb) All computations instead of registers\nc) Input/output only\nd) Error handling only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Reverse Polish Notation (RPN) eliminates need for parentheses in mathematical expressions.",
    "target_text": "Question: RPN eliminates need for:\nChoices:\na) Operators\nb) Parentheses in expressions\nc) Operands\nd) Mathematical operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: RPN calculators use single stack for all operations, making implementation simple.",
    "target_text": "Question: RPN calculators use:\nChoices:\na) Multiple stacks\nb) Single stack for all operations\nc) No stacks\nd) Arrays only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Converting infix to postfix requires operator stack to handle precedence and associativity.",
    "target_text": "Question: Infix to postfix conversion requires operator stack to handle:\nChoices:\na) Only operands\nb) Precedence and associativity\nc) Only parentheses\nd) Variable names\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Prefix notation (Polish notation) places operators before operands.",
    "target_text": "Question: In prefix notation, operators are placed:\nChoices:\na) After operands\nb) Before operands\nc) Between operands\nd) Randomly\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Evaluation of prefix expressions can be done using stacks by scanning from right to left.",
    "target_text": "Question: Prefix evaluation scans expression:\nChoices:\na) Left to right\nb) Right to left\nc) Middle outward\nd) Random order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Memory stack and data structure stack are different concepts in computer science.",
    "target_text": "Question: Memory stack and data structure stack are:\nChoices:\na) Exactly the same\nb) Different concepts\nc) Only used together\nd) Mutually exclusive\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack data structure can be implemented using the memory stack but they serve different purposes.",
    "target_text": "Question: Stack data structure and memory stack:\nChoices:\na) Always serve same purpose\nb) Can be related but serve different purposes\nc) Are never related\nd) Must be implemented together\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Debugging tools often show call stack to help trace function execution and locate errors.",
    "target_text": "Question: Call stack in debugging helps:\nChoices:\na) Optimize code\nb) Trace function execution and locate errors\nc) Allocate memory\nd) Compile faster\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack trace provides sequence of function calls that led to current execution point.",
    "target_text": "Question: Stack trace provides:\nChoices:\na) Memory usage statistics\nb) Sequence of function calls to current point\nc) Variable values only\nd) Compilation errors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Exception handling uses stack unwinding to clean up resources when exceptions propagate.",
    "target_text": "Question: Stack unwinding in exception handling:\nChoices:\na) Prevents exceptions\nb) Cleans up resources when exceptions propagate\nc) Generates exceptions\nd) Ignores exceptions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack-based buffer overflow is a security vulnerability where stack memory is overwritten.",
    "target_text": "Question: Stack-based buffer overflow occurs when:\nChoices:\na) Stack becomes empty\nb) Stack memory is overwritten\nc) Stack grows normally\nd) Functions return properly\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Return address on stack can be target of buffer overflow attacks to redirect program execution.",
    "target_text": "Question: Return address attacks aim to:\nChoices:\na) Speed up execution\nb) Redirect program execution\nc) Save memory\nd) Improve performance\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack canaries are security mechanism to detect stack buffer overflows.",
    "target_text": "Question: Stack canaries are used to:\nChoices:\na) Optimize performance\nb) Detect stack buffer overflows\nc) Allocate memory\nd) Debug programs\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Non-executable stack (NX bit) prevents code execution from stack memory regions.",
    "target_text": "Question: NX bit prevents:\nChoices:\na) Memory allocation\nb) Code execution from stack memory\nc) Function calls\nd) Variable access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Address Space Layout Randomization (ASLR) randomizes stack location to prevent attacks.",
    "target_text": "Question: ASLR randomizes stack location to:\nChoices:\na) Improve performance\nb) Prevent attacks\nc) Save memory\nd) Speed up access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack machine architecture performs operations using stack instead of registers.",
    "target_text": "Question: Stack machine architecture performs operations using:\nChoices:\na) Only registers\nb) Stack instead of registers\nc) Memory directly\nd) Cache only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Zero-address instructions in stack machines operate on top stack elements implicitly.",
    "target_text": "Question: Zero-address instructions operate on:\nChoices:\na) Memory addresses\nb) Top stack elements implicitly\nc) Register values\nd) External devices\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: PostScript language uses stack-based programming model for graphics operations.",
    "target_text": "Question: PostScript uses stack-based model for:\nChoices:\na) Text processing only\nb) Graphics operations\nc) Database queries\nd) Network communication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Forth programming language is entirely based on stack operations and postfix notation.",
    "target_text": "Question: Forth language is based on:\nChoices:\na) Object-oriented programming\nb) Stack operations and postfix notation\nc) Functional programming only\nd) Logic programming\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Java bytecode uses operand stack for intermediate calculations during method execution.",
    "target_text": "Question: Java bytecode uses operand stack for:\nChoices:\na) Class loading\nb) Intermediate calculations during method execution\nc) Garbage collection\nd) Thread synchronization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack-based languages require no explicit operand addressing in arithmetic operations.",
    "target_text": "Question: Stack-based languages require no explicit:\nChoices:\na) Variables\nb) Operand addressing in arithmetic operations\nc) Functions\nd) Data types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Concatenative programming languages like Forth compose programs by combining functions that operate on stacks.",
    "target_text": "Question: Concatenative languages compose programs by:\nChoices:\na) Object inheritance\nb) Combining functions that operate on stacks\nc) Variable declarations\nd) Class definitions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Undo/Redo functionality requires two stacks - one for undo operations and one for redo operations.",
    "target_text": "Question: Undo/Redo functionality requires:\nChoices:\na) Single stack\nb) Two stacks - one for undo, one for redo\nc) Three stacks\nd) No stacks\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Command pattern combined with stacks enables sophisticated undo/redo systems.",
    "target_text": "Question: Command pattern with stacks enables:\nChoices:\na) Faster execution\nb) Sophisticated undo/redo systems\nc) Memory optimization\nd) Error prevention\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack size for undo operations is often limited to prevent excessive memory usage.",
    "target_text": "Question: Undo stack size is limited to:\nChoices:\na) Improve performance\nb) Prevent excessive memory usage\nc) Reduce complexity\nd) Increase speed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: When redo stack is not empty and new operation is performed, redo stack should be cleared.",
    "target_text": "Question: When new operation is performed with non-empty redo stack:\nChoices:\na) Keep redo stack unchanged\nb) Clear redo stack\nc) Merge with undo stack\nd) Ignore the operation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Memory management for stack can use fixed-size arrays or dynamic allocation strategies.",
    "target_text": "Question: Stack memory management can use:\nChoices:\na) Only fixed-size arrays\nb) Fixed-size arrays or dynamic allocation\nc) Only dynamic allocation\nd) External files only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Dynamic stack resizing typically doubles capacity when full and halves when quarter full.",
    "target_text": "Question: Dynamic resizing typically doubles capacity when full and halves when:\nChoices:\na) Half full\nb) Quarter full\nc) Three-quarters full\nd) Empty\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Amortized analysis shows that dynamic resizing achieves O(1) average time for push operations.",
    "target_text": "Question: Amortized analysis of dynamic resizing shows:\nChoices:\na) O(n) average time\nb) O(1) average time for push\nc) O(log n) average time\nd) O(n²) average time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack interface typically includes methods like push, pop, peek, isEmpty, and size.",
    "target_text": "Question: Standard stack interface includes:\nChoices:\na) Only push and pop\nb) Push, pop, peek, isEmpty, size\nc) Only peek and size\nd) Random access methods\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Exception handling for stack operations should throw appropriate exceptions for overflow and underflow.",
    "target_text": "Question: Stack exception handling should throw exceptions for:\nChoices:\na) Only overflow\nb) Overflow and underflow\nc) Only underflow\nd) All operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Thread-safe stack implementation requires synchronization mechanisms for concurrent access.",
    "target_text": "Question: Thread-safe stack requires:\nChoices:\na) Faster processors\nb) Synchronization mechanisms for concurrent access\nc) More memory\nd) Special data types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Lock-free stack implementations use atomic compare-and-swap operations for thread safety.",
    "target_text": "Question: Lock-free stacks use atomic compare-and-swap for:\nChoices:\na) Performance optimization\nb) Thread safety\nc) Memory management\nd) Error handling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: ABA problem in concurrent stacks occurs when pointer value changes and then changes back.",
    "target_text": "Question: ABA problem in concurrent stacks occurs when pointer:\nChoices:\na) Never changes\nb) Changes and then changes back\nc) Changes once\nd) Becomes null\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack validation checks if sequence of push/pop operations is valid for given input/output.",
    "target_text": "Question: Stack validation checks if push/pop sequence is:\nChoices:\na) Fast enough\nb) Valid for given input/output\nc) Memory efficient\nd) Thread safe\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Catalan numbers count the number of valid stack sequences for n elements.",
    "target_text": "Question: Catalan numbers count:\nChoices:\na) Stack operations\nb) Valid stack sequences for n elements\nc) Memory usage\nd) Time complexity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack sorting problem asks whether an input sequence can be sorted using a single stack.",
    "target_text": "Question: Stack sorting asks if input sequence can be:\nChoices:\na) Reversed using stack\nb) Sorted using single stack\nc) Duplicated using stack\nd) Compressed using stack\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: 231-pattern avoidance characterizes sequences that can be stack-sorted.",
    "target_text": "Question: Stack-sortable sequences avoid:\nChoices:\na) 123-pattern\nb) 231-pattern\nc) 321-pattern\nd) 132-pattern\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Min-stack data structure supports finding minimum element in O(1) time along with standard operations.",
    "target_text": "Question: Min-stack finds minimum element in:\nChoices:\na) O(n) time\nb) O(1) time\nc) O(log n) time\nd) O(n²) time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Min-stack can be implemented using auxiliary stack to track minimum values.",
    "target_text": "Question: Min-stack implementation can use:\nChoices:\na) Single stack only\nb) Auxiliary stack to track minimums\nc) Array only\nd) Hash table only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Max-stack similarly supports finding maximum element in O(1) time.",
    "target_text": "Question: Max-stack finds maximum element in:\nChoices:\na) O(n) time\nb) O(1) time\nc) O(log n) time\nd) O(n²) time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Monotonic stack maintains elements in monotonically increasing or decreasing order.",
    "target_text": "Question: Monotonic stack maintains elements in:\nChoices:\na) Random order\nb) Monotonically increasing or decreasing order\nc) Alphabetical order\nd) Reverse input order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Monotonic stacks are useful for problems like next greater element and largest rectangle.",
    "target_text": "Question: Monotonic stacks are useful for:\nChoices:\na) Sorting only\nb) Next greater element and largest rectangle problems\nc) Memory management\nd) String processing only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack can be used to implement iterative versions of recursive algorithms.",
    "target_text": "Question: Stack can implement:\nChoices:\na) Only recursive algorithms\nb) Iterative versions of recursive algorithms\nc) Only sorting algorithms\nd) Only search algorithms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Iterative tree traversal algorithms use explicit stack instead of function call stack.",
    "target_text": "Question: Iterative tree traversal uses:\nChoices:\na) Function call stack\nb) Explicit stack instead of function call stack\nc) No stack\nd) Multiple stacks always\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Preorder traversal using stack processes root before children.",
    "target_text": "Question: Preorder traversal processes:\nChoices:\na) Children before root\nb) Root before children\nc) Left child only\nd) Right child only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Inorder traversal using stack requires careful handling to process left subtree, root, then right subtree.",
    "target_text": "Question: Inorder traversal processes:\nChoices:\na) Root, left, right\nb) Left subtree, root, right subtree\nc) Right, root, left\nd) Only root\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Postorder traversal using stack is most complex as root is processed after both children.",
    "target_text": "Question: Postorder traversal processes root:\nChoices:\na) Before children\nb) After both children\nc) Between children\nd) Instead of children\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack-based graph DFS avoids recursion and potential stack overflow for large graphs.",
    "target_text": "Question: Stack-based DFS avoids:\nChoices:\na) Visiting all nodes\nb) Recursion and potential stack overflow\nc) Finding paths\nd) Graph representation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Topological sorting can be implemented using DFS with a stack for result ordering.",
    "target_text": "Question: Topological sorting with DFS uses stack for:\nChoices:\na) Input storage\nb) Result ordering\nc) Temporary calculations\nd) Error handling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Strongly connected components algorithms like Tarjan's use stack for tracking vertices.",
    "target_text": "Question: Tarjan's algorithm uses stack for:\nChoices:\na) Input parsing\nb) Tracking vertices\nc) Output formatting\nd) Memory management\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Path finding in maze uses stack to remember path and backtrack when needed.",
    "target_text": "Question: Maze path finding uses stack to:\nChoices:\na) Store maze layout\nb) Remember path and backtrack\nc) Count steps\nd) Mark visited cells only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Sudoku solver uses stack to store board states for backtracking.",
    "target_text": "Question: Sudoku solver uses stack to store:\nChoices:\na) Solution only\nb) Board states for backtracking\nc) Rules only\nd) User input\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Eight queens problem uses stack to track queen placements and backtrack on conflicts.",
    "target_text": "Question: Eight queens uses stack to:\nChoices:\na) Count solutions\nb) Track placements and backtrack on conflicts\nc) Display board\nd) Check rules only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Shunting yard algorithm converts infix expressions to postfix using operator stack.",
    "target_text": "Question: Shunting yard algorithm uses operator stack to convert:\nChoices:\na) Postfix to infix\nb) Infix to postfix\nc) Prefix to postfix\nd) Variables to constants\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Operator associativity affects how operators of same precedence are handled in conversion.",
    "target_text": "Question: Operator associativity affects handling of:\nChoices:\na) Different precedence operators\nb) Same precedence operators\nc) Operands only\nd) Parentheses only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Left associative operators are popped from stack when same or higher precedence operator is encountered.",
    "target_text": "Question: Left associative operators are popped when encountering:\nChoices:\na) Lower precedence operators\nb) Same or higher precedence operators\nc) Any operator\nd) No operators\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Right associative operators require special handling in expression conversion algorithms.",
    "target_text": "Question: Right associative operators require:\nChoices:\na) No special handling\nb) Special handling in conversion\nc) Elimination from expression\nd) Replacement with left associative\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Parentheses in expressions have highest precedence and force evaluation order.",
    "target_text": "Question: Parentheses have:\nChoices:\na) Lowest precedence\nb) Highest precedence\nc) No precedence\nd) Variable precedence\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Unmatched parentheses in expressions can be detected during stack-based parsing.",
    "target_text": "Question: Unmatched parentheses can be detected during:\nChoices:\na) Code compilation only\nb) Stack-based parsing\nc) Runtime only\nd) Output generation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Function call stack grows with each function call and shrinks with each return.",
    "target_text": "Question: Function call stack grows with calls and:\nChoices:\na) Grows with returns\nb) Shrinks with returns\nc) Stays same with returns\nd) Disappears with returns\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Nested function calls create nested stack frames in the call stack.",
    "target_text": "Question: Nested function calls create:\nChoices:\na) Single stack frame\nb) Nested stack frames\nc) No stack frames\nd) Parallel stack frames\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Local variables in different function calls are isolated by separate stack frames.",
    "target_text": "Question: Local variables are isolated by:\nChoices:\na) Global scope\nb) Separate stack frames\nc) Static allocation\nd) Heap memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Parameter passing uses stack to transfer values between caller and callee functions.",
    "target_text": "Question: Parameter passing uses stack to:\nChoices:\na) Store return values only\nb) Transfer values between caller and callee\nc) Allocate memory only\nd) Handle exceptions only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Return value from function is typically passed through registers or stack depending on calling convention.",
    "target_text": "Question: Return value is passed through:\nChoices:\na) Global variables only\nb) Registers or stack depending on convention\nc) Files only\nd) Network only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Calling conventions define how parameters and return values are passed using stack and registers.",
    "target_text": "Question: Calling conventions define how:\nChoices:\na) Functions are named\nb) Parameters and return values are passed\nc) Variables are declared\nd) Loops are executed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack frame layout depends on processor architecture and calling convention used.",
    "target_text": "Question: Stack frame layout depends on:\nChoices:\na) Programming language only\nb) Processor architecture and calling convention\nc) Variable names only\nd) Function length only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack alignment requirements ensure optimal performance on modern processors.",
    "target_text": "Question: Stack alignment ensures:\nChoices:\na) Correct functionality only\nb) Optimal performance on modern processors\nc) Memory savings only\nd) Code readability only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack-based calculators like HP calculators use RPN for natural mathematical expression entry.",
    "target_text": "Question: HP calculators use RPN for:\nChoices:\na) Memory efficiency only\nb) Natural mathematical expression entry\nc) Display purposes only\nd) Power saving only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Mathematical software often provides stack-based evaluation engines for expression processing.",
    "target_text": "Question: Mathematical software uses stack-based engines for:\nChoices:\na) User interface only\nb) Expression processing\nc) File storage only\nd) Network communication only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Spreadsheet formula evaluation uses stacks to handle complex nested expressions.",
    "target_text": "Question: Spreadsheet formula evaluation uses stacks for:\nChoices:\na) Cell formatting\nb) Complex nested expressions\nc) Data storage\nd) Chart generation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Scientific calculators implement stack-based evaluation for multi-step calculations.",
    "target_text": "Question: Scientific calculators use stack-based evaluation for:\nChoices:\na) Simple addition only\nb) Multi-step calculations\nc) Display control only\nd) Memory management only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack underflow protection prevents program crashes when popping from empty stack.",
    "target_text": "Question: Stack underflow protection prevents:\nChoices:\na) Memory leaks\nb) Program crashes when popping from empty stack\nc) Slow performance\nd) Compilation errors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack overflow protection limits stack growth to prevent system instability.",
    "target_text": "Question: Stack overflow protection limits growth to prevent:\nChoices:\na) Fast execution\nb) System instability\nc) Memory optimization\nd) Code clarity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Guard pages in memory protection can detect stack overflow by triggering page faults.",
    "target_text": "Question: Guard pages detect stack overflow by triggering:\nChoices:\na) Interrupts\nb) Page faults\nc) System calls\nd) Network events\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack probes check available stack space before large local variable allocation.",
    "target_text": "Question: Stack probes check available space before:\nChoices:\na) Function calls\nb) Large local variable allocation\nc) Return statements\nd) Loop execution\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Virtual memory systems can automatically expand stack segments when needed.",
    "target_text": "Question: Virtual memory can automatically:\nChoices:\na) Compress stack data\nb) Expand stack segments when needed\nc) Delete old stack frames\nd) Encrypt stack contents\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack-based programming teaches fundamental concepts of computation and algorithm design.",
    "target_text": "Question: Stack-based programming teaches:\nChoices:\na) Only syntax rules\nb) Fundamental concepts of computation and algorithm design\nc) Only debugging techniques\nd) Only optimization methods\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Understanding stacks provides foundation for learning compilers, interpreters, and virtual machines.",
    "target_text": "Question: Understanding stacks provides foundation for:\nChoices:\na) Only basic programming\nb) Compilers, interpreters, and virtual machines\nc) Only web development\nd) Only database design\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack visualization helps students understand LIFO behavior and operation effects.",
    "target_text": "Question: Stack visualization helps understand:\nChoices:\na) Only implementation details\nb) LIFO behavior and operation effects\nc) Only memory usage\nd) Only performance metrics\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Hands-on stack implementation reinforces programming concepts like pointers and memory management.",
    "target_text": "Question: Stack implementation reinforces concepts like:\nChoices:\na) Only syntax\nb) Pointers and memory management\nc) Only algorithms\nd) Only testing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Problem-solving skills developed through stack exercises transfer to many computational challenges.",
    "target_text": "Question: Stack problem-solving skills:\nChoices:\na) Apply only to stacks\nb) Transfer to many computational challenges\nc) Are outdated\nd) Only help with academic problems\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack implementation using circular array can maximize space utilization when multiple stacks share same array.",
    "target_text": "Question: Circular array implementation maximizes:\nChoices:\na) Time complexity\nb) Space utilization when multiple stacks share array\nc) Code readability\nd) Memory access speed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Double-ended stack (deque) allows push and pop operations at both ends of the data structure.",
    "target_text": "Question: Double-ended stack allows operations at:\nChoices:\na) Only one end\nb) Both ends\nc) Middle only\nd) Random positions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack can be used to reverse a string by pushing all characters and then popping them.",
    "target_text": "Question: To reverse string using stack:\nChoices:\na) Push all characters then pop them\nb) Pop all characters then push them\nc) Only push characters\nd) Only peek at characters\nAnswer: a"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Next greater element problem can be solved efficiently using monotonic decreasing stack.",
    "target_text": "Question: Next greater element uses:\nChoices:\na) Monotonic increasing stack\nb) Monotonic decreasing stack\nc) Random stack\nd) Sorted stack\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Daily temperatures problem finds next warmer day using stack to store indices.",
    "target_text": "Question: Daily temperatures problem uses stack to store:\nChoices:\na) Temperature values\nb) Indices\nc) Days of week\nd) Weather conditions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stock span problem calculates consecutive days with price less than or equal to current using stack.",
    "target_text": "Question: Stock span calculates consecutive days with price:\nChoices:\na) Greater than current\nb) Less than or equal to current\nc) Exactly equal to current\nd) Unrelated to current\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Largest rectangle in histogram uses stack to find maximum rectangular area possible.",
    "target_text": "Question: Largest rectangle in histogram finds:\nChoices:\na) Tallest bar\nb) Maximum rectangular area possible\nc) Average height\nd) Total area\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Trapping rainwater problem uses stack to calculate water that can be trapped between buildings.",
    "target_text": "Question: Trapping rainwater calculates:\nChoices:\na) Building heights\nb) Water that can be trapped\nc) Ground area\nd) Building materials\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Valid parentheses problem checks if brackets are properly matched and nested.",
    "target_text": "Question: Valid parentheses checks if brackets are:\nChoices:\na) Only opened\nb) Properly matched and nested\nc) Only closed\nd) In alphabetical order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Remove duplicate letters uses stack to create lexicographically smallest subsequence.",
    "target_text": "Question: Remove duplicate letters creates:\nChoices:\na) Longest subsequence\nb) Lexicographically smallest subsequence\nc) Random subsequence\nd) Reversed sequence\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Decode string problem uses stack to handle nested brackets in encoded strings.",
    "target_text": "Question: Decode string uses stack to handle:\nChoices:\na) Character encoding\nb) Nested brackets in encoded strings\nc) String length\nd) Memory allocation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Baseball game problem uses stack to track scores and handle cancel operations.",
    "target_text": "Question: Baseball game uses stack to:\nChoices:\na) Count players\nb) Track scores and handle cancel operations\nc) Time the game\nd) Store team names\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Asteroid collision uses stack to simulate collisions between moving asteroids.",
    "target_text": "Question: Asteroid collision uses stack to simulate:\nChoices:\na) Space travel\nb) Collisions between moving asteroids\nc) Gravity effects\nd) Star formation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Mini parser uses stack to parse nested integer lists represented as strings.",
    "target_text": "Question: Mini parser uses stack to parse:\nChoices:\na) Simple numbers\nb) Nested integer lists as strings\nc) Boolean values\nd) Character arrays\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Online stock span uses stack to maintain decreasing sequence of stock prices.",
    "target_text": "Question: Online stock span maintains:\nChoices:\na) Increasing sequence\nb) Decreasing sequence of stock prices\nc) Random sequence\nd) Constant sequence\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Score of parentheses uses stack to calculate nested parentheses scores.",
    "target_text": "Question: Score of parentheses calculates:\nChoices:\na) Number of brackets\nb) Nested parentheses scores\nc) String length\nd) Character frequency\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Minimum add to make parentheses valid uses stack to count unmatched brackets.",
    "target_text": "Question: Minimum add uses stack to count:\nChoices:\na) Total brackets\nb) Unmatched brackets\nc) Valid pairs\nd) String characters\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Remove all adjacent duplicates uses stack to eliminate consecutive duplicate characters.",
    "target_text": "Question: Remove adjacent duplicates eliminates:\nChoices:\na) All duplicates\nb) Consecutive duplicate characters\nc) Random characters\nd) Vowels only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Validate stack sequences checks if given pop sequence is possible for given push sequence.",
    "target_text": "Question: Validate stack sequences checks if pop sequence is:\nChoices:\na) Sorted\nb) Possible for given push sequence\nc) Reversed\nd) Unique\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Simplify path uses stack to resolve directory paths with dots and double dots.",
    "target_text": "Question: Simplify path resolves directory paths with:\nChoices:\na) File extensions\nb) Dots and double dots\nc) Permissions\nd) File sizes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Basic calculator implements arithmetic evaluation using two stacks for numbers and operators.",
    "target_text": "Question: Basic calculator uses two stacks for:\nChoices:\na) Input and output\nb) Numbers and operators\nc) Variables and constants\nd) Functions and arguments\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Exclusive time of functions uses stack to track function execution times with nested calls.",
    "target_text": "Question: Exclusive time tracks:\nChoices:\na) Total execution time\nb) Function execution times with nested calls\nc) Memory usage\nd) CPU temperature\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Binary tree inorder traversal can be implemented iteratively using stack and current pointer.",
    "target_text": "Question: Iterative inorder traversal uses:\nChoices:\na) Only recursion\nb) Stack and current pointer\nc) Queue only\nd) Array indexing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Binary tree zigzag traversal uses two stacks to alternate direction between levels.",
    "target_text": "Question: Zigzag traversal uses two stacks to:\nChoices:\na) Store all nodes\nb) Alternate direction between levels\nc) Count levels\nd) Find maximum depth\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Flatten binary tree to linked list uses stack to convert tree to right-skewed structure.",
    "target_text": "Question: Flatten binary tree converts to:\nChoices:\na) Balanced tree\nb) Right-skewed structure\nc) Left-skewed structure\nd) Complete tree\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Sum of subarray minimums uses monotonic stack to find contribution of each element.",
    "target_text": "Question: Sum of subarray minimums finds:\nChoices:\na) Maximum elements\nb) Contribution of each element\nc) Array length\nd) Total sum\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Online stock span problem requires maintaining stack of price indices for efficient computation.",
    "target_text": "Question: Online stock span maintains stack of:\nChoices:\na) Stock names\nb) Price indices\nc) Company data\nd) Trading volumes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Car fleet problem uses stack to group cars that will never catch up to form fleets.",
    "target_text": "Question: Car fleet groups cars that will:\nChoices:\na) Always overtake\nb) Never catch up to form fleets\nc) Stop moving\nd) Change lanes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Maximum binary tree construction uses stack to build tree from array using greater element relationships.",
    "target_text": "Question: Maximum binary tree uses:\nChoices:\na) Sorting algorithm\nb) Stack with greater element relationships\nc) Queue processing\nd) Hash table lookup\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: 132 pattern detection uses stack to find subsequence where middle element is largest.",
    "target_text": "Question: 132 pattern finds subsequence where middle element is:\nChoices:\na) Smallest\nb) Largest\nc) Equal to others\nd) Random\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Longest valid parentheses uses stack with indices to find maximum length of valid parentheses.",
    "target_text": "Question: Longest valid parentheses finds:\nChoices:\na) Total parentheses count\nb) Maximum length of valid parentheses\nc) Number of invalid pairs\nd) Average length\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Remove K digits uses stack to create smallest possible number by removing K digits.",
    "target_text": "Question: Remove K digits creates:\nChoices:\na) Largest possible number\nb) Smallest possible number\nc) Random number\nd) Original number\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Sliding window maximum uses deque (double-ended queue) which combines stack and queue properties.",
    "target_text": "Question: Sliding window maximum uses deque which combines:\nChoices:\na) Array and linked list\nb) Stack and queue properties\nc) Hash table and tree\nd) Set and map\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack-based state machine implementation tracks current state and allows state transitions.",
    "target_text": "Question: Stack-based state machine tracks:\nChoices:\na) Input symbols only\nb) Current state and allows transitions\nc) Output symbols only\nd) Transition count\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Recursive descent parser uses call stack implicitly or explicit stack for predictive parsing.",
    "target_text": "Question: Recursive descent parser uses:\nChoices:\na) Only hash tables\nb) Call stack or explicit stack for parsing\nc) Only arrays\nd) Only linked lists\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Bracket sequence generation uses stack to ensure all generated sequences are valid.",
    "target_text": "Question: Bracket sequence generation ensures sequences are:\nChoices:\na) Long\nb) Valid\nc) Random\nd) Short\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Palindrome linked list can be checked using stack to store first half values.",
    "target_text": "Question: Palindrome linked list uses stack to store:\nChoices:\na) All values\nb) First half values\nc) Last half values\nd) Random values\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack overflow attacks exploit buffer overflows to overwrite return addresses on the stack.",
    "target_text": "Question: Stack overflow attacks overwrite:\nChoices:\na) Data values only\nb) Return addresses on stack\nc) Program code\nd) System files\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Return-oriented programming (ROP) chains together existing code snippets using stack manipulation.",
    "target_text": "Question: ROP chains together code snippets using:\nChoices:\na) Heap manipulation\nb) Stack manipulation\nc) Register operations\nd) File operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Control flow integrity protects against stack-based attacks by validating return addresses.",
    "target_text": "Question: Control flow integrity validates:\nChoices:\na) Data integrity only\nb) Return addresses\nc) Input parameters only\nd) File permissions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Shadow stack maintains separate copy of return addresses to detect tampering.",
    "target_text": "Question: Shadow stack maintains separate copy of:\nChoices:\na) All stack data\nb) Return addresses\nc) Local variables\nd) Function parameters\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack pivoting technique redirects execution to heap or other memory regions during attacks.",
    "target_text": "Question: Stack pivoting redirects execution to:\nChoices:\na) Same stack location\nb) Heap or other memory regions\nc) System calls only\nd) File system\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Intel CET (Control-flow Enforcement Technology) provides hardware stack protection.",
    "target_text": "Question: Intel CET provides:\nChoices:\na) Software optimization\nb) Hardware stack protection\nc) Network security\nd) File encryption\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack smashing protection adds canary values to detect buffer overflow attempts.",
    "target_text": "Question: Stack smashing protection adds canary values to detect:\nChoices:\na) Performance issues\nb) Buffer overflow attempts\nc) Memory leaks\nd) Logic errors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Fortify source adds runtime checks to prevent stack buffer overflows in C programs.",
    "target_text": "Question: Fortify source adds runtime checks to prevent:\nChoices:\na) Compilation errors\nb) Stack buffer overflows\nc) Memory allocation\nd) Function calls\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack layout randomization makes exploitation harder by randomizing stack frame organization.",
    "target_text": "Question: Stack layout randomization makes exploitation harder by randomizing:\nChoices:\na) Function names\nb) Stack frame organization\nc) Variable names\nd) Code structure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Bounded stack checking verifies stack operations stay within allocated bounds.",
    "target_text": "Question: Bounded stack checking verifies operations stay within:\nChoices:\na) Time limits\nb) Allocated bounds\nc) CPU usage\nd) Network bandwidth\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack-based virtual machines translate high-level operations into stack manipulations.",
    "target_text": "Question: Stack VMs translate high-level operations into:\nChoices:\na) Register operations\nb) Stack manipulations\nc) Memory accesses\nd) I/O operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: WebAssembly uses stack machine model for portable binary instruction format.",
    "target_text": "Question: WebAssembly uses stack machine model for:\nChoices:\na) Web design\nb) Portable binary instruction format\nc) Database queries\nd) Network protocols\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: CLR (Common Language Runtime) uses evaluation stack for intermediate computations.",
    "target_text": "Question: CLR uses evaluation stack for:\nChoices:\na) Memory management\nb) Intermediate computations\nc) Type checking\nd) Exception handling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Dalvik VM uses register-based architecture instead of stack-based for Android applications.",
    "target_text": "Question: Dalvik VM uses:\nChoices:\na) Stack-based architecture\nb) Register-based architecture\nc) Memory-mapped architecture\nd) Network-based architecture\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack machine instructions typically have zero addresses as operands are implicit on stack.",
    "target_text": "Question: Stack machine instructions typically have:\nChoices:\na) Multiple addresses\nb) Zero addresses as operands are implicit\nc) One address always\nd) Variable addresses\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Intermediate code generation often uses three-address code which is later converted to stack code.",
    "target_text": "Question: Three-address code is later converted to:\nChoices:\na) Assembly code directly\nb) Stack code\nc) Machine code directly\nd) High-level code\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack scheduling in operating systems manages process execution using stack-like priority.",
    "target_text": "Question: Stack scheduling manages process execution using:\nChoices:\na) Random selection\nb) Stack-like priority\nc) Round-robin only\nd) First-come-first-serve\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Interrupt handling uses system stack to save processor state during interrupt processing.",
    "target_text": "Question: Interrupt handling uses system stack to save:\nChoices:\na) User data only\nb) Processor state during interrupt processing\nc) Program code\nd) File contents\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Context switching saves current process state on stack before switching to another process.",
    "target_text": "Question: Context switching saves current process state on stack before:\nChoices:\na) Terminating process\nb) Switching to another process\nc) Allocating memory\nd) Starting I/O operation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Kernel stack is separate from user stack to maintain security and privilege separation.",
    "target_text": "Question: Kernel stack is separate from user stack to maintain:\nChoices:\na) Performance only\nb) Security and privilege separation\nc) Memory efficiency\nd) Code organization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Thread-local storage often uses stack-like allocation for per-thread variables.",
    "target_text": "Question: Thread-local storage uses stack-like allocation for:\nChoices:\na) Global variables\nb) Per-thread variables\nc) Shared variables\nd) System variables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack frame inspection in debuggers allows examining local variables and call hierarchy.",
    "target_text": "Question: Stack frame inspection allows examining:\nChoices:\na) Global variables only\nb) Local variables and call hierarchy\nc) System resources\nd) Network connections\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Call stack analysis helps identify performance bottlenecks and infinite recursion.",
    "target_text": "Question: Call stack analysis helps identify:\nChoices:\na) Syntax errors only\nb) Performance bottlenecks and infinite recursion\nc) Compilation warnings\nd) Variable types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Profiling tools use stack sampling to determine where programs spend most execution time.",
    "target_text": "Question: Profiling tools use stack sampling to determine:\nChoices:\na) Memory usage patterns\nb) Where programs spend most execution time\nc) Variable declarations\nd) Code formatting\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Stack trace compression reduces memory overhead of storing multiple similar call stacks.",
    "target_text": "Question: Stack trace compression reduces:\nChoices:\na) Execution time\nb) Memory overhead of storing call stacks\nc) Code complexity\nd) Network traffic\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Educational stack simulators help visualize stack operations and understand algorithm execution.",
    "target_text": "Question: Stack simulators help visualize:\nChoices:\na) Network protocols\nb) Stack operations and algorithm execution\nc) Database transactions\nd) File operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Interactive stack exercises build intuition about LIFO behavior and problem-solving patterns.",
    "target_text": "Question: Interactive exercises build intuition about:\nChoices:\na) Only syntax rules\nb) LIFO behavior and problem-solving patterns\nc) Only debugging\nd) Only testing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Step-by-step stack trace execution helps students understand recursive algorithm behavior.",
    "target_text": "Question: Step-by-step trace helps understand:\nChoices:\na) Variable naming\nb) Recursive algorithm behavior\nc) Code formatting\nd) File structure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Visual stack representations using diagrams improve comprehension of abstract stack concepts.",
    "target_text": "Question: Visual representations improve comprehension of:\nChoices:\na) Concrete implementations only\nb) Abstract stack concepts\nc) Hardware details only\nd) Network protocols\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Hands-on coding exercises with stacks develop practical programming skills and debugging abilities.",
    "target_text": "Question: Coding exercises develop:\nChoices:\na) Only theoretical knowledge\nb) Practical programming skills and debugging abilities\nc) Only documentation skills\nd) Only presentation skills\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Stack | Context: Understanding stack principles provides foundation for advanced topics like parsing theory and compiler design.",
    "target_text": "Question: Stack principles provide foundation for:\nChoices:\na) Basic arithmetic only\nb) Parsing theory and compiler design\nc) Web development only\nd) Database administration only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: A queue is a linear data structure that follows the First In First Out (FIFO) principle.",
    "target_text": "Question: What principle does a queue follow?\nChoices:\na) Last In First Out (LIFO)\nb) First In First Out (FIFO)\nc) Random access\nd) Sorted order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In FIFO principle, the first element added to the queue is the first one to be removed.",
    "target_text": "Question: In FIFO principle, which element is removed first:\nChoices:\na) Last element added\nb) First element added\nc) Middle element\nd) Largest element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Elements are added to the rear (back) of the queue and removed from the front of the queue.",
    "target_text": "Question: Elements are added to the queue at:\nChoices:\na) Front\nb) Rear (back)\nc) Middle\nd) Any position\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Elements are removed from the front of the queue in FIFO order.",
    "target_text": "Question: Elements are removed from the queue at:\nChoices:\na) Rear\nb) Front\nc) Middle\nd) Random position\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Enqueue operation adds an element to the rear of the queue.",
    "target_text": "Question: What does the enqueue operation do?\nChoices:\na) Removes element from front\nb) Adds element to rear\nc) Views front element\nd) Checks if queue is empty\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Dequeue operation removes and returns the front element from the queue.",
    "target_text": "Question: What does the dequeue operation do:\nChoices:\na) Adds element to queue\nb) Removes and returns front element\nc) Views front element without removing\nd) Clears entire queue\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Front operation returns the front element without removing it from the queue.",
    "target_text": "Question: Front operation:\nChoices:\na) Removes front element\nb) Returns front element without removing\nc) Adds new element\nd) Counts queue elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: isEmpty operation checks whether the queue contains any elements.",
    "target_text": "Question: What does isEmpty operation check?\nChoices:\na) If queue is full\nb) If queue contains any elements\nc) Size of queue\nd) Front element value\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue overflow occurs when trying to enqueue an element to a full queue.",
    "target_text": "Question: Queue overflow occurs when:\nChoices:\na) Dequeuing from empty queue\nb) Enqueuing to full queue\nc) Viewing front of empty queue\nd) Queue is half full\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue underflow occurs when trying to dequeue from an empty queue.",
    "target_text": "Question: Queue underflow occurs when:\nChoices:\na) Enqueuing to full queue\nb) Dequeuing from empty queue\nc) Queue is half empty\nd) Viewing front of full queue\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queues can be implemented using arrays with front and rear pointers.",
    "target_text": "Question: Array implementation uses:\nChoices:\na) Only front pointer\nb) Front and rear pointers\nc) Only rear pointer\nd) No pointers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queues can be implemented using linked lists where elements are added at tail and removed from head.",
    "target_text": "Question: In linked list implementation, elements are:\nChoices:\na) Added at head, removed from tail\nb) Added at tail, removed from head\nc) Added and removed from same end\nd) Added randomly\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Circular queue implementation overcomes the limitation of linear queue by reusing freed space.",
    "target_text": "Question: Circular queue overcomes limitation by:\nChoices:\na) Increasing queue size\nb) Reusing freed space\nc) Using more memory\nd) Avoiding pointers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Time complexity of enqueue operation is O(1) for both array and linked list implementations.",
    "target_text": "Question: Time complexity of enqueue operation is:\nChoices:\na) O(n)\nb) O(1)\nc) O(log n)\nd) O(n²)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Time complexity of dequeue operation is O(1) for both array and linked list implementations.",
    "target_text": "Question: Time complexity of dequeue operation is:\nChoices:\na) O(n)\nb) O(1)\nc) O(log n)\nd) O(n²)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Space complexity of basic queue operations is O(1) as they don't require additional space proportional to input.",
    "target_text": "Question: Space complexity of basic queue operations is:\nChoices:\na) O(n)\nb) O(1)\nc) O(log n)\nd) O(n²)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queues are used in BFS (Breadth First Search) traversal of graphs and trees.",
    "target_text": "Question: Queues are used in:\nChoices:\na) Depth First Search (DFS)\nb) Breadth First Search (BFS)\nc) Binary search\nd) Quick sort\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: BFS explores nodes level by level, processing all nodes at current level before moving to next level.",
    "target_text": "Question: BFS explores nodes:\nChoices:\na) Depth by depth\nb) Level by level\nc) Randomly\nd) In sorted order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: CPU scheduling algorithms like Round Robin use queues to manage process execution order.",
    "target_text": "Question: Round Robin scheduling uses:\nChoices:\na) Stacks\nb) Queues\nc) Trees\nd) Hash tables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Print job scheduling uses queues where documents are printed in the order they were submitted.",
    "target_text": "Question: Print job scheduling follows:\nChoices:\na) LIFO order\nb) FIFO order\nc) Priority order only\nd) Random order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Buffer for data streams uses queues to temporarily store data before processing.",
    "target_text": "Question: Data stream buffers use queues to:\nChoices:\na) Sort data\nb) Temporarily store data before processing\nc) Compress data\nd) Encrypt data\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Web server request handling uses queues to process client requests in order of arrival.",
    "target_text": "Question: Web servers use queues to process requests in:\nChoices:\na) Random order\nb) Order of arrival\nc) Size order\nd) Alphabetical order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Keyboard buffer uses queue to store keystrokes until they can be processed by the application.",
    "target_text": "Question: Keyboard buffer stores keystrokes until:\nChoices:\na) User stops typing\nb) They can be processed by application\nc) Buffer becomes full\nd) Computer restarts\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Call center systems use queues to manage incoming calls and assign them to available agents.",
    "target_text": "Question: Call centers use queues to:\nChoices:\na) Record conversations\nb) Manage incoming calls and assign to agents\nc) Calculate call duration\nd) Store phone numbers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Simulation systems use queues to model real-world waiting scenarios like bank queues or traffic.",
    "target_text": "Question: Simulation systems use queues to model:\nChoices:\na) Mathematical equations\nb) Real-world waiting scenarios\nc) Network protocols\nd) File systems\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In array implementation, front pointer points to the first element in the queue.",
    "target_text": "Question: Front pointer in array implementation points to:\nChoices:\na) Last element\nb) First element\nc) Middle element\nd) Next available space\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In array implementation, rear pointer points to the last element in the queue.",
    "target_text": "Question: Rear pointer in array implementation points to:\nChoices:\na) First element\nb) Last element\nc) Middle element\nd) Empty space\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Linear queue implementation wastes space as front elements cannot be reused after dequeue.",
    "target_text": "Question: Linear queue wastes space because:\nChoices:\na) Elements are too large\nb) Front elements cannot be reused after dequeue\nc) Rear pointer moves backward\nd) Array is too small\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Circular queue treats array as circular where rear can wrap around to beginning.",
    "target_text": "Question: In circular queue, rear can:\nChoices:\na) Only move forward\nb) Wrap around to beginning\nc) Move backward only\nd) Stay fixed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Circular queue uses modulo arithmetic to handle wraparound of indices.",
    "target_text": "Question: Circular queue uses modulo arithmetic to handle:\nChoices:\na) Element comparison\nb) Wraparound of indices\nc) Memory allocation\nd) Data type conversion\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In circular queue, the condition (rear + 1) % size == front indicates the queue is full.",
    "target_text": "Question: In circular queue, (rear + 1) % size == front indicates:\nChoices:\na) Queue is empty\nb) Queue is full\nc) Queue has one element\nd) Queue has error\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: In circular queue, the condition front == rear can indicate empty queue or full queue.",
    "target_text": "Question: Condition front == rear in circular queue can indicate:\nChoices:\na) Only empty queue\nb) Empty queue or full queue\nc) Only full queue\nd) Queue with one element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Double-ended queue (deque) allows insertion and deletion at both ends.",
    "target_text": "Question: Double-ended queue allows operations at:\nChoices:\na) Only front\nb) Both ends\nc) Only rear\nd) Middle only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Priority queue serves elements based on priority rather than FIFO order.",
    "target_text": "Question: Priority queue serves elements based on:\nChoices:\na) FIFO order\nb) Priority\nc) LIFO order\nd) Random order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Priority queue can be implemented using heaps for efficient insertion and extraction.",
    "target_text": "Question: Priority queue is efficiently implemented using:\nChoices:\na) Arrays only\nb) Heaps\nc) Linked lists only\nd) Stacks\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Min-priority queue returns element with minimum priority value.",
    "target_text": "Question: Min-priority queue returns element with:\nChoices:\na) Maximum priority\nb) Minimum priority\nc) Average priority\nd) Random priority\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Max-priority queue returns element with maximum priority value.",
    "target_text": "Question: Max-priority queue returns element with:\nChoices:\na) Minimum priority\nb) Maximum priority\nc) Average priority\nd) First priority\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue size operation returns the number of elements currently in the queue.",
    "target_text": "Question: Queue size operation returns:\nChoices:\na) Maximum capacity\nb) Number of elements currently in queue\nc) Memory used\nd) Front element value\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Clear operation removes all elements from the queue, making it empty.",
    "target_text": "Question: Clear operation:\nChoices:\na) Sorts queue elements\nb) Removes all elements making queue empty\nc) Adds elements\nd) Reverses queue order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue can store elements of any data type including integers, strings, and objects.",
    "target_text": "Question: Queue can store:\nChoices:\na) Only integers\nb) Any data type\nc) Only strings\nd) Only primitive types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Generic queues use templates or generics to work with different data types.",
    "target_text": "Question: Generic queues use templates to:\nChoices:\na) Increase speed\nb) Work with different data types\nc) Reduce memory\nd) Simplify code only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue is a restricted data structure as elements can only be added at rear and removed from front.",
    "target_text": "Question: Queue is restricted because:\nChoices:\na) It's slow\nb) Elements can only be added at rear and removed from front\nc) It uses more memory\nd) It's complex to implement\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue follows abstract data type (ADT) principles with defined operations and hidden implementation.",
    "target_text": "Question: Queue ADT has:\nChoices:\na) Visible implementation\nb) Defined operations and hidden implementation\nc) No defined operations\nd) Only one operation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Blocking queue operations wait when queue is full (for enqueue) or empty (for dequeue).",
    "target_text": "Question: Blocking queue operations wait when:\nChoices:\na) Queue has elements\nb) Queue is full or empty\nc) Queue is half full\nd) Operations are fast\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Non-blocking queue operations return immediately with success or failure status.",
    "target_text": "Question: Non-blocking operations:\nChoices:\na) Always wait\nb) Return immediately with status\nc) Never complete\nd) Block indefinitely\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Bounded queue has fixed maximum capacity while unbounded queue can grow dynamically.",
    "target_text": "Question: Unbounded queue can:\nChoices:\na) Hold fixed number of elements\nb) Grow dynamically\nc) Only shrink\nd) Never change size\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Thread-safe queue implementations use synchronization to handle concurrent access.",
    "target_text": "Question: Thread-safe queues use synchronization for:\nChoices:\na) Performance optimization\nb) Handling concurrent access\nc) Memory management\nd) Data compression\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Producer-consumer problem uses queues to communicate between producing and consuming threads.",
    "target_text": "Question: Producer-consumer problem uses queues for:\nChoices:\na) Data storage only\nb) Communication between threads\nc) Performance measurement\nd) Error handling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Message passing systems use queues to deliver messages between processes or threads.",
    "target_text": "Question: Message passing uses queues to:\nChoices:\na) Store process IDs\nb) Deliver messages between processes\nc) Manage memory\nd) Handle exceptions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Event-driven systems use event queues to store and process events in order.",
    "target_text": "Question: Event-driven systems use queues to:\nChoices:\na) Generate events\nb) Store and process events in order\nc) Delete events\nd) Merge events\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: GUI applications use event queues to handle user interactions like clicks and keystrokes.",
    "target_text": "Question: GUI applications use event queues for:\nChoices:\na) Drawing graphics\nb) Handling user interactions\nc) Managing windows\nd) Playing sounds\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Breadth-first search guarantees finding shortest path in unweighted graphs.",
    "target_text": "Question: BFS guarantees finding shortest path in:\nChoices:\na) Weighted graphs\nb) Unweighted graphs\nc) Directed graphs only\nd) Cyclic graphs only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Level-order traversal of binary trees uses queues to visit nodes level by level.",
    "target_text": "Question: Level-order traversal uses:\nChoices:\na) Stacks\nb) Queues\nc) Arrays only\nd) Recursion only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue-based BFS can find connected components in undirected graphs.",
    "target_text": "Question: Queue-based BFS can find:\nChoices:\na) Shortest paths only\nb) Connected components\nc) Cycles only\nd) Maximum flow\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Topological sorting can be implemented using queues with Kahn's algorithm.",
    "target_text": "Question: Kahn's algorithm for topological sorting uses:\nChoices:\na) Stacks\nb) Queues\nc) Trees\nd) Hash tables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Multi-level feedback queue scheduling uses multiple queues with different priorities.",
    "target_text": "Question: Multi-level feedback scheduling uses:\nChoices:\na) Single queue\nb) Multiple queues with different priorities\nc) No queues\nd) Stack-based scheduling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Job scheduling in operating systems uses queues to manage processes waiting for CPU time.",
    "target_text": "Question: Job scheduling uses queues to manage:\nChoices:\na) Memory allocation\nb) Processes waiting for CPU time\nc) File operations\nd) Network connections\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: I/O request scheduling uses queues to order disk read and write operations.",
    "target_text": "Question: I/O scheduling uses queues to order:\nChoices:\na) Network packets\nb) Disk read and write operations\nc) Memory allocations\nd) Process creations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Network packet buffering uses queues to temporarily store packets before routing.",
    "target_text": "Question: Network packet buffering uses queues to:\nChoices:\na) Encrypt packets\nb) Temporarily store packets before routing\nc) Compress packets\nd) Delete packets\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Quality of Service (QoS) implementations use priority queues for traffic management.",
    "target_text": "Question: QoS implementations use priority queues for:\nChoices:\na) Error detection\nb) Traffic management\nc) Data compression\nd) Security checking\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Load balancing systems use queues to distribute work among multiple servers.",
    "target_text": "Question: Load balancing uses queues to:\nChoices:\na) Monitor server health\nb) Distribute work among servers\nc) Store server configurations\nd) Backup data\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Cache replacement algorithms like LRU can be implemented using queues.",
    "target_text": "Question: LRU cache replacement can use:\nChoices:\na) Stacks only\nb) Queues\nc) Trees only\nd) Hash tables only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Streaming data processing uses queues to buffer data between processing stages.",
    "target_text": "Question: Streaming data processing uses queues to:\nChoices:\na) Sort data\nb) Buffer data between processing stages\nc) Compress data\nd) Validate data\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Asynchronous programming uses message queues to handle non-blocking operations.",
    "target_text": "Question: Asynchronous programming uses queues for:\nChoices:\na) Synchronous operations\nb) Non-blocking operations\nc) Error handling only\nd) Memory management\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Task scheduling in distributed systems uses work queues to distribute computations.",
    "target_text": "Question: Distributed task scheduling uses work queues to:\nChoices:\na) Store results\nb) Distribute computations\nc) Monitor performance\nd) Handle failures\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Database transaction logging uses queues to order commit and rollback operations.",
    "target_text": "Question: Transaction logging uses queues to order:\nChoices:\na) SELECT queries\nb) Commit and rollback operations\nc) Table creations\nd) User authentications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Before dequeuing, you should check if the queue is empty to avoid underflow.",
    "target_text": "Question: Before dequeuing, you should check if queue is:\nChoices:\na) Full\nb) Empty\nc) Sorted\nd) Large\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Before enqueuing, you should check if the queue is full in bounded implementations.",
    "target_text": "Question: Before enqueuing in bounded queue, check if it is:\nChoices:\na) Empty\nb) Full\nc) Sorted\nd) Small\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue implementation choice depends on whether you need bounded or unbounded capacity.",
    "target_text": "Question: Implementation choice depends on:\nChoices:\na) Programming language only\nb) Whether you need bounded or unbounded capacity\nc) Available memory only\nd) Programmer preference only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Dynamic array implementation of queue can resize automatically when capacity is reached.",
    "target_text": "Question: Dynamic array implementation can:\nChoices:\na) Never change size\nb) Resize automatically when capacity reached\nc) Only shrink\nd) Only grow by one element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Linked list implementation provides unlimited capacity limited only by available memory.",
    "target_text": "Question: Linked list implementation capacity is limited by:\nChoices:\na) Array size\nb) Available memory\nc) Programming language\nd) Queue operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Array implementation provides better cache performance due to contiguous memory layout.",
    "target_text": "Question: Array implementation provides better cache performance due to:\nChoices:\na) Smaller elements\nb) Contiguous memory layout\nc) Faster operations\nd) Less memory usage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Memory allocation for queue nodes happens at runtime in linked list implementation.",
    "target_text": "Question: In linked list implementation, memory allocation happens:\nChoices:\na) At compile time\nb) At runtime\nc) Never\nd) At program start only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Circular buffer is another name for circular queue implementation.",
    "target_text": "Question: Circular buffer is another name for:\nChoices:\na) Linear queue\nb) Circular queue\nc) Priority queue\nd) Deque\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Ring buffer implementation uses fixed-size array with wraparound capability.",
    "target_text": "Question: Ring buffer uses:\nChoices:\na) Variable-size array\nb) Fixed-size array with wraparound\nc) Linked list\nd) Tree structure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue visualization helps understand FIFO behavior and operation effects.",
    "target_text": "Question: Queue visualization helps understand:\nChoices:\na) Only implementation details\nb) FIFO behavior and operation effects\nc) Only memory usage\nd) Only performance metrics\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Understanding queues provides foundation for learning scheduling algorithms and system design.",
    "target_text": "Question: Understanding queues provides foundation for:\nChoices:\na) Only basic programming\nb) Scheduling algorithms and system design\nc) Only web development\nd) Only database design\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Real-world applications of queues include customer service systems and traffic management.",
    "target_text": "Question: Real-world queue applications include:\nChoices:\na) Only computer systems\nb) Customer service and traffic management\nc) Only mathematical calculations\nd) Only file operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue operations maintain order and fairness in resource allocation and task processing.",
    "target_text": "Question: Queue operations maintain:\nChoices:\na) Random access\nb) Order and fairness\nc) Sorting properties\nd) Encryption\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Hands-on queue implementation reinforces concepts like pointers and memory management.",
    "target_text": "Question: Queue implementation reinforces:\nChoices:\na) Only syntax\nb) Pointers and memory management\nc) Only algorithms\nd) Only testing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Problem-solving skills developed through queue exercises apply to many system design challenges.",
    "target_text": "Question: Queue problem-solving skills apply to:\nChoices:\na) Only queue problems\nb) Many system design challenges\nc) Only academic exercises\nd) Only simple programs\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue-based algorithms teach important concepts about ordering and fairness in computing.",
    "target_text": "Question: Queue algorithms teach concepts about:\nChoices:\na) Random processing\nb) Ordering and fairness in computing\nc) Faster execution only\nd) Memory optimization only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Simulation modeling often uses queues to represent waiting lines and service processes.",
    "target_text": "Question: Simulation modeling uses queues to represent:\nChoices:\na) Mathematical functions\nb) Waiting lines and service processes\nc) Data structures only\nd) Programming languages\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue theory studies the mathematical properties of waiting lines and service systems.",
    "target_text": "Question: Queue theory studies:\nChoices:\na) Programming techniques\nb) Mathematical properties of waiting lines\nc) Hardware design\nd) Network protocols\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Little's Law in queueing theory relates average number of customers to arrival rate and waiting time.",
    "target_text": "Question: Little's Law relates average customers to:\nChoices:\na) Service quality only\nb) Arrival rate and waiting time\nc) Queue length only\nd) Server capacity only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: M/M/1 queue model represents single-server queue with Poisson arrivals and exponential service times.",
    "target_text": "Question: M/M/1 queue model represents:\nChoices:\na) Multi-server queue\nb) Single-server queue with Poisson arrivals\nc) Priority queue\nd) Circular queue\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue utilization is the ratio of service time to total time, indicating system efficiency.",
    "target_text": "Question: Queue utilization indicates:\nChoices:\na) Queue length\nb) System efficiency\nc) Arrival rate\nd) Service quality\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Waiting time in queues includes both time spent waiting and time being served.",
    "target_text": "Question: Waiting time includes:\nChoices:\na) Only service time\nb) Time waiting and time being served\nc) Only queue time\nd) Only arrival time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Throughput measures the rate at which items are processed through the queue system.",
    "target_text": "Question: Throughput measures:\nChoices:\na) Queue capacity\nb) Rate at which items are processed\nc) Maximum queue length\nd) Service quality\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: FIFO scheduling ensures fairness by serving requests in order of arrival.",
    "target_text": "Question: FIFO scheduling ensures fairness by:\nChoices:\na) Serving largest requests first\nb) Serving requests in order of arrival\nc) Random selection\nd) Priority-based selection\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Round-robin scheduling uses time quantum to limit how long each process can use CPU.",
    "target_text": "Question: Round-robin scheduling uses time quantum to:\nChoices:\na) Increase process priority\nb) Limit CPU usage time per process\nc) Allocate memory\nd) Handle interrupts\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Shortest Job First scheduling can cause starvation of longer processes.",
    "target_text": "Question: Shortest Job First can cause:\nChoices:\na) System crashes\nb) Starvation of longer processes\nc) Memory leaks\nd) Network errors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Priority scheduling uses different queues for different priority levels.",
    "target_text": "Question: Priority scheduling uses:\nChoices:\na) Single queue\nb) Different queues for different priority levels\nc) Random assignment\nd) Stack-based ordering\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Aging technique prevents starvation by gradually increasing priority of waiting processes.",
    "target_text": "Question: Aging technique prevents starvation by:\nChoices:\na) Reducing process size\nb) Gradually increasing priority of waiting processes\nc) Faster CPU\nd) More memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Breadth-first search explores all neighbors at current depth before moving to next depth level.",
    "target_text": "Question: BFS explores neighbors at current depth before:\nChoices:\na) Stopping search\nb) Moving to next depth level\nc) Returning to start\nd) Changing direction\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: BFS tree represents the structure of breadth-first exploration from a source vertex.",
    "target_text": "Question: BFS tree represents:\nChoices:\na) Original graph structure\nb) Structure of breadth-first exploration\nc) Shortest paths only\nd) Depth-first exploration\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: BFS can find shortest path in terms of number of edges in unweighted graphs.",
    "target_text": "Question: BFS finds shortest path in terms of:\nChoices:\na) Edge weights\nb) Number of edges\nc) Vertex values\nd) Graph size\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Level-order traversal visits all nodes at depth d before visiting nodes at depth d+1.",
    "target_text": "Question: Level-order traversal visits nodes at depth d before:\nChoices:\na) Nodes at depth d-1\nb) Nodes at depth d+1\nc) Leaf nodes\nd) Root node\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Binary tree level-order traversal can determine tree width at each level.",
    "target_text": "Question: Level-order traversal can determine:\nChoices:\na) Tree height only\nb) Tree width at each level\nc) Node values only\nd) Tree balance\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Bipartite graph checking can be done using BFS with two-coloring approach.",
    "target_text": "Question: Bipartite checking uses BFS with:\nChoices:\na) Single coloring\nb) Two-coloring approach\nc) No coloring\nd) Multiple coloring\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Connected components in undirected graphs can be found using BFS from unvisited vertices.",
    "target_text": "Question: Connected components are found using BFS from:\nChoices:\na) All vertices\nb) Unvisited vertices\nc) Visited vertices only\nd) Random vertices\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Kahn's algorithm for topological sort uses queue to process vertices with zero in-degree.",
    "target_text": "Question: Kahn's algorithm processes vertices with:\nChoices:\na) Maximum in-degree\nb) Zero in-degree\nc) Zero out-degree\nd) Maximum out-degree\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Cycle detection in directed graphs can use BFS-based approach with in-degree counting.",
    "target_text": "Question: BFS cycle detection uses:\nChoices:\na) Out-degree counting\nb) In-degree counting\nc) Vertex values\nd) Edge weights\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Multi-source BFS starts from multiple source vertices simultaneously.",
    "target_text": "Question: Multi-source BFS starts from:\nChoices:\na) Single vertex\nb) Multiple source vertices simultaneously\nc) Random vertices\nd) Leaf vertices only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: 0-1 BFS handles graphs with edge weights of 0 or 1 using double-ended queue.",
    "target_text": "Question: 0-1 BFS uses:\nChoices:\na) Regular queue\nb) Double-ended queue\nc) Priority queue\nd) Stack\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Sliding window maximum uses deque to efficiently track maximum in each window.",
    "target_text": "Question: Sliding window maximum efficiently uses:\nChoices:\na) Stack\nb) Deque\nc) Regular queue\nd) Priority queue\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Monotonic deque maintains elements in monotonically decreasing order for window problems.",
    "target_text": "Question: Monotonic deque maintains elements in:\nChoices:\na) Random order\nb) Monotonically decreasing order\nc) Sorted order\nd) Reverse input order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Circular deque allows efficient insertion and deletion at both ends with wraparound.",
    "target_text": "Question: Circular deque allows operations at both ends with:\nChoices:\na) Linear access\nb) Wraparound capability\nc) Random access\nd) Stack behavior\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Binary heap implementation of priority queue provides O(log n) insertion and extraction.",
    "target_text": "Question: Binary heap priority queue provides:\nChoices:\na) O(1) operations\nb) O(log n) insertion and extraction\nc) O(n) operations\nd) O(n²) operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Fibonacci heap provides better amortized time complexity for priority queue operations.",
    "target_text": "Question: Fibonacci heap provides better:\nChoices:\na) Space complexity\nb) Amortized time complexity\nc) Worst-case complexity\nd) Code simplicity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Binomial heap supports efficient merge operation for priority queues.",
    "target_text": "Question: Binomial heap supports efficient:\nChoices:\na) Search operation\nb) Merge operation\nc) Sort operation\nd) Copy operation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Min-max heap supports both minimum and maximum extraction in O(log n) time.",
    "target_text": "Question: Min-max heap supports:\nChoices:\na) Only minimum extraction\nb) Both minimum and maximum extraction\nc) Only maximum extraction\nd) Average extraction\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: d-ary heap uses d children per node instead of 2, affecting height and operation complexity.",
    "target_text": "Question: d-ary heap affects:\nChoices:\na) Only space usage\nb) Height and operation complexity\nc) Only insertion time\nd) Only memory layout\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Lock-free queue implementations use atomic operations for thread-safe concurrent access.",
    "target_text": "Question: Lock-free queues use atomic operations for:\nChoices:\na) Performance optimization\nb) Thread-safe concurrent access\nc) Memory management\nd) Error handling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: ABA problem in concurrent queues occurs when pointer value changes and then changes back.",
    "target_text": "Question: ABA problem occurs when pointer:\nChoices:\na) Never changes\nb) Changes and then changes back\nc) Changes once\nd) Becomes null\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Memory barriers ensure proper ordering of memory operations in concurrent queue implementations.",
    "target_text": "Question: Memory barriers ensure proper:\nChoices:\na) Memory allocation\nb) Ordering of memory operations\nc) Error handling\nd) Performance optimization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Compare-and-swap (CAS) operation enables atomic updates in lock-free queue implementations.",
    "target_text": "Question: CAS operation enables:\nChoices:\na) Memory allocation\nb) Atomic updates in lock-free implementations\nc) Error detection\nd) Performance monitoring\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Hazard pointers help manage memory safety in lock-free queue implementations.",
    "target_text": "Question: Hazard pointers help manage:\nChoices:\na) Performance optimization\nb) Memory safety in lock-free implementations\nc) Error handling\nd) Thread scheduling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Michael & Scott queue algorithm is a well-known lock-free queue implementation.",
    "target_text": "Question: Michael & Scott algorithm is known for:\nChoices:\na) Sorting\nb) Lock-free queue implementation\nc) Graph traversal\nd) String matching\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: MPMC (Multi-Producer Multi-Consumer) queues handle multiple threads producing and consuming.",
    "target_text": "Question: MPMC queues handle:\nChoices:\na) Single producer, single consumer\nb) Multiple threads producing and consuming\nc) Only producers\nd) Only consumers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: SPSC (Single-Producer Single-Consumer) queues can be implemented more efficiently than MPMC.",
    "target_text": "Question: SPSC queues can be implemented:\nChoices:\na) Less efficiently than MPMC\nb) More efficiently than MPMC\nc) Same efficiency as MPMC\nd) Cannot be implemented\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Ring buffer implementation for SPSC queue avoids locks using memory barriers.",
    "target_text": "Question: SPSC ring buffer avoids locks using:\nChoices:\na) Mutexes\nb) Memory barriers\nc) Semaphores\nd) Condition variables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Disruptor pattern provides high-performance alternative to traditional queue implementations.",
    "target_text": "Question: Disruptor pattern provides:\nChoices:\na) Lower performance\nb) High-performance alternative to traditional queues\nc) Same performance\nd) Only memory optimization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Wait-free algorithms guarantee that every thread makes progress in bounded steps.",
    "target_text": "Question: Wait-free algorithms guarantee:\nChoices:\na) No threads make progress\nb) Every thread makes progress in bounded steps\nc) Only one thread makes progress\nd) Random progress\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Message queue systems enable asynchronous communication between distributed components.",
    "target_text": "Question: Message queue systems enable:\nChoices:\na) Synchronous communication only\nb) Asynchronous communication between components\nc) Local communication only\nd) One-way communication only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Apache Kafka uses distributed message queues for high-throughput data streaming.",
    "target_text": "Question: Apache Kafka uses message queues for:\nChoices:\na) Database storage\nb) High-throughput data streaming\nc) File processing\nd) User authentication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: RabbitMQ implements AMQP protocol for reliable message delivery using queues.",
    "target_text": "Question: RabbitMQ uses queues for:\nChoices:\na) File storage\nb) Reliable message delivery\nc) Database operations\nd) Web serving\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Amazon SQS provides managed message queue service for decoupling application components.",
    "target_text": "Question: Amazon SQS provides queues for:\nChoices:\na) Database storage\nb) Decoupling application components\nc) File hosting\nd) Web browsing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Pub-Sub pattern uses queues to deliver messages from publishers to multiple subscribers.",
    "target_text": "Question: Pub-Sub pattern uses queues to deliver messages from:\nChoices:\na) Subscribers to publishers\nb) Publishers to multiple subscribers\nc) Database to clients\nd) Servers to databases\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Dead letter queues store messages that cannot be processed successfully.",
    "target_text": "Question: Dead letter queues store messages that:\nChoices:\na) Are processed successfully\nb) Cannot be processed successfully\nc) Are too large\nd) Are too small\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Message acknowledgment ensures reliable delivery by confirming message processing.",
    "target_text": "Question: Message acknowledgment ensures reliable delivery by:\nChoices:\na) Duplicating messages\nb) Confirming message processing\nc) Deleting messages\nd) Encrypting messages\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: At-least-once delivery guarantees message delivery but may result in duplicates.",
    "target_text": "Question: At-least-once delivery may result in:\nChoices:\na) Message loss\nb) Message duplicates\nc) No message delivery\nd) Corrupted messages\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Exactly-once delivery ensures each message is processed exactly one time.",
    "target_text": "Question: Exactly-once delivery ensures each message is processed:\nChoices:\na) At least once\nb) Exactly one time\nc) Multiple times\nd) Never\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Message TTL (Time To Live) specifies how long messages remain in queue before expiring.",
    "target_text": "Question: Message TTL specifies how long messages:\nChoices:\na) Take to send\nb) Remain in queue before expiring\nc) Take to process\nd) Are stored on disk\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Flow control mechanisms prevent fast producers from overwhelming slow consumers.",
    "target_text": "Question: Flow control prevents fast producers from:\nChoices:\na) Sending messages\nb) Overwhelming slow consumers\nc) Processing data\nd) Creating queues\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Back-pressure handling slows down or blocks producers when consumers cannot keep up.",
    "target_text": "Question: Back-pressure handling occurs when:\nChoices:\na) Producers are too slow\nb) Consumers cannot keep up\nc) Queues are empty\nd) Messages are too small\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue partitioning distributes messages across multiple queues for parallel processing.",
    "target_text": "Question: Queue partitioning enables:\nChoices:\na) Sequential processing\nb) Parallel processing\nc) Single-threaded processing\nd) No processing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Message ordering can be maintained per partition while allowing parallel processing.",
    "target_text": "Question: Message ordering per partition allows:\nChoices:\na) No parallelism\nb) Parallel processing while maintaining order\nc) Random processing\nd) Sequential processing only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Event sourcing uses event queues to capture and replay state changes.",
    "target_text": "Question: Event sourcing uses queues to:\nChoices:\na) Store current state only\nb) Capture and replay state changes\nc) Delete old events\nd) Compress data\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: CQRS (Command Query Responsibility Segregation) often uses queues for command processing.",
    "target_text": "Question: CQRS uses queues for:\nChoices:\na) Query processing only\nb) Command processing\nc) Data storage only\nd) User interface\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Microservices architecture uses message queues for loose coupling between services.",
    "target_text": "Question: Microservices use message queues for:\nChoices:\na) Tight coupling\nb) Loose coupling between services\nc) Data storage\nd) User authentication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Saga pattern uses event queues to coordinate distributed transactions.",
    "target_text": "Question: Saga pattern uses queues to coordinate:\nChoices:\na) Local transactions\nb) Distributed transactions\nc) Database queries\nd) User sessions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Circuit breaker pattern can be combined with queues to handle service failures gracefully.",
    "target_text": "Question: Circuit breaker with queues handles:\nChoices:\na) Normal operations\nb) Service failures gracefully\nc) Fast processing\nd) Data compression\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Bulkhead pattern uses separate queues to isolate different types of operations.",
    "target_text": "Question: Bulkhead pattern uses separate queues to:\nChoices:\na) Combine operations\nb) Isolate different types of operations\nc) Speed up processing\nd) Reduce memory usage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Rate limiting can be implemented using token bucket or leaky bucket queue algorithms.",
    "target_text": "Question: Rate limiting uses queue algorithms like:\nChoices:\na) FIFO and LIFO\nb) Token bucket and leaky bucket\nc) Priority and circular\nd) Stack and heap\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Traffic shaping uses queues to control the rate and pattern of network packet transmission.",
    "target_text": "Question: Traffic shaping uses queues to control:\nChoices:\na) Packet content\nb) Rate and pattern of packet transmission\nc) Network topology\nd) Security protocols\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Quality of Service implementation uses multiple priority queues for different traffic classes.",
    "target_text": "Question: QoS implementation uses multiple priority queues for:\nChoices:\na) Same traffic type\nb) Different traffic classes\nc) Error handling\nd) Security checking\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Weighted fair queuing ensures bandwidth allocation based on assigned weights.",
    "target_text": "Question: Weighted fair queuing ensures bandwidth allocation based on:\nChoices:\na) Arrival time\nb) Assigned weights\nc) Packet size\nd) Random selection\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Class-based queuing organizes traffic into different classes with separate queues.",
    "target_text": "Question: Class-based queuing organizes traffic into:\nChoices:\na) Single queue\nb) Different classes with separate queues\nc) Random groups\nd) Size-based categories\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Understanding queue principles provides foundation for system design and performance optimization.",
    "target_text": "Question: Queue principles provide foundation for:\nChoices:\na) Only basic programming\nb) System design and performance optimization\nc) Only academic study\nd) Only simple applications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Batch processing systems use job queues to schedule and execute computational tasks efficiently.",
    "target_text": "Question: Batch processing systems use job queues to:\nChoices:\na) Store user data\nb) Schedule and execute computational tasks\nc) Handle user interfaces\nd) Manage file systems\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Time-sharing systems use ready queues to manage processes waiting for CPU allocation.",
    "target_text": "Question: Time-sharing systems use ready queues for:\nChoices:\na) Memory management\nb) Managing processes waiting for CPU\nc) File operations\nd) Network communication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Device drivers use request queues to handle I/O operations in order of submission.",
    "target_text": "Question: Device drivers use request queues to handle:\nChoices:\na) Memory allocation\nb) I/O operations in order of submission\nc) Process creation\nd) Network routing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Elevator scheduling algorithm uses queues to optimize disk head movement patterns.",
    "target_text": "Question: Elevator scheduling uses queues to optimize:\nChoices:\na) Memory access\nb) Disk head movement patterns\nc) Network bandwidth\nd) CPU utilization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Real-time systems use priority queues to ensure time-critical tasks meet deadlines.",
    "target_text": "Question: Real-time systems use priority queues to ensure:\nChoices:\na) Maximum throughput\nb) Time-critical tasks meet deadlines\nc) Minimum memory usage\nd) Random execution order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Virtual memory management uses page replacement queues for efficient memory utilization.",
    "target_text": "Question: Virtual memory uses page replacement queues for:\nChoices:\na) CPU scheduling\nb) Efficient memory utilization\nc) Network management\nd) File storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Interrupt handling systems use interrupt queues to process hardware and software interrupts.",
    "target_text": "Question: Interrupt handling uses queues to process:\nChoices:\na) User applications only\nb) Hardware and software interrupts\nc) File operations only\nd) Network packets only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Load balancers use connection queues to distribute incoming requests across multiple servers.",
    "target_text": "Question: Load balancers use connection queues to:\nChoices:\na) Store server configurations\nb) Distribute requests across servers\nc) Monitor server health\nd) Encrypt communications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Web crawlers use URL queues to systematically discover and process web pages.",
    "target_text": "Question: Web crawlers use URL queues to:\nChoices:\na) Store downloaded content\nb) Systematically discover and process pages\nc) Analyze page content\nd) Generate search indices\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: MapReduce frameworks use task queues to distribute computation across worker nodes.",
    "target_text": "Question: MapReduce uses task queues to:\nChoices:\na) Store input data\nb) Distribute computation across workers\nc) Merge final results\nd) Monitor system health\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Stream processing engines use event queues to handle continuous data flows.",
    "target_text": "Question: Stream processing engines use event queues for:\nChoices:\na) Batch processing\nb) Handling continuous data flows\nc) Static data analysis\nd) File storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Gaming systems use action queues to process player inputs in multiplayer environments.",
    "target_text": "Question: Gaming systems use action queues to process:\nChoices:\na) Graphics rendering\nb) Player inputs in multiplayer environments\nc) Sound effects\nd) Game physics only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Email servers use mail queues to handle outgoing message delivery and retry mechanisms.",
    "target_text": "Question: Email servers use mail queues for:\nChoices:\na) Spam filtering\nb) Outgoing delivery and retry mechanisms\nc) Message encryption\nd) User authentication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: CDN (Content Delivery Network) systems use request queues for cache management and content distribution.",
    "target_text": "Question: CDN systems use request queues for:\nChoices:\na) Content creation\nb) Cache management and content distribution\nc) User registration\nd) Bandwidth monitoring\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Blockchain networks use transaction queues (mempools) before including transactions in blocks.",
    "target_text": "Question: Blockchain networks use transaction queues before:\nChoices:\na) Validating transactions\nb) Including transactions in blocks\nc) Creating new blocks\nd) Mining rewards\nAnswer: b"
  },
  {
    "input_text": "Gaming a data structure MCQ | Topic: Queue | Context: IoT (Internet of Things) systems use sensor data queues to handle asynchronous data collection.",
    "target_text": "Question: IoT systems use sensor data queues for:\nChoices:\na) Device configuration\nb) Asynchronous data collection\nc) Power management\nd) Network security\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Video streaming services use buffer queues to ensure smooth playback despite network variations.",
    "target_text": "Question: Video streaming uses buffer queues to ensure:\nChoices:\na) High video quality\nb) Smooth playback despite network variations\nc) Low bandwidth usage\nd) Secure transmission\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Database systems use transaction queues to serialize conflicting operations and maintain consistency.",
    "target_text": "Question: Database systems use transaction queues to:\nChoices:\na) Increase performance only\nb) Serialize conflicting operations and maintain consistency\nc) Store backup data\nd) Handle user authentication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Search engines use crawl queues to prioritize and schedule web page indexing tasks.",
    "target_text": "Question: Search engines use crawl queues to:\nChoices:\na) Store search results\nb) Prioritize and schedule indexing tasks\nc) Rank web pages\nd) Handle user queries\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Compiler optimization uses work queues to parallelize compilation tasks across multiple threads.",
    "target_text": "Question: Compiler optimization uses work queues to:\nChoices:\na) Parse source code\nb) Parallelize compilation tasks\nc) Generate object code\nd) Handle syntax errors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Machine learning training uses data queues to feed batches to neural networks efficiently.",
    "target_text": "Question: ML training uses data queues to:\nChoices:\na) Store model weights\nb) Feed batches to neural networks efficiently\nc) Evaluate model performance\nd) Visualize training progress\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Container orchestration systems use task queues to manage deployment and scaling operations.",
    "target_text": "Question: Container orchestration uses task queues for:\nChoices:\na) Image creation\nb) Managing deployment and scaling operations\nc) Network configuration\nd) Storage management\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Event-driven architectures use event buses with queues to decouple system components.",
    "target_text": "Question: Event-driven architectures use queues to:\nChoices:\na) Increase coupling\nb) Decouple system components\nc) Reduce functionality\nd) Centralize control\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: API rate limiting uses request queues to control and smooth out traffic spikes.",
    "target_text": "Question: API rate limiting uses request queues to:\nChoices:\na) Increase request speed\nb) Control and smooth out traffic spikes\nc) Store API keys\nd) Generate documentation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Simulation frameworks use event queues to model discrete event systems accurately.",
    "target_text": "Question: Simulation frameworks use event queues to model:\nChoices:\na) Continuous systems only\nb) Discrete event systems accurately\nc) Static systems only\nd) Mathematical equations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Financial trading systems use order queues to match buy and sell orders fairly.",
    "target_text": "Question: Trading systems use order queues to:\nChoices:\na) Store market data\nb) Match buy and sell orders fairly\nc) Calculate prices\nd) Generate reports\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Hospital management systems use patient queues for appointment scheduling and emergency triage.",
    "target_text": "Question: Hospital systems use patient queues for:\nChoices:\na) Medical records only\nb) Appointment scheduling and emergency triage\nc) Billing operations\nd) Staff management\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Manufacturing systems use production queues to optimize workflow and resource allocation.",
    "target_text": "Question: Manufacturing systems use production queues to optimize:\nChoices:\na) Product design\nb) Workflow and resource allocation\nc) Quality control\nd) Marketing strategies\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: GPS navigation systems use route calculation queues to handle multiple simultaneous requests.",
    "target_text": "Question: GPS systems use route calculation queues to handle:\nChoices:\na) Map updates\nb) Multiple simultaneous requests\nc) Traffic data\nd) Location tracking\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Memory-mapped queues use shared memory for high-performance inter-process communication.",
    "target_text": "Question: Memory-mapped queues use shared memory for:\nChoices:\na) Data persistence\nb) High-performance inter-process communication\nc) Security isolation\nd) Error recovery\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Zero-copy queues minimize memory operations by avoiding unnecessary data copying.",
    "target_text": "Question: Zero-copy queues minimize memory operations by:\nChoices:\na) Using more memory\nb) Avoiding unnecessary data copying\nc) Slower processing\nd) Complex algorithms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Cache-aware queue implementations optimize data locality to improve performance.",
    "target_text": "Question: Cache-aware queues optimize data locality to:\nChoices:\na) Use more memory\nb) Improve performance\nc) Reduce functionality\nd) Increase complexity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: NUMA-aware queues consider memory architecture for optimal performance on multi-processor systems.",
    "target_text": "Question: NUMA-aware queues consider memory architecture for:\nChoices:\na) Code simplicity\nb) Optimal performance on multi-processor systems\nc) Reduced memory usage\nd) Easier debugging\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Persistent queues maintain data across system restarts using disk storage or logs.",
    "target_text": "Question: Persistent queues maintain data across restarts using:\nChoices:\na) Memory only\nb) Disk storage or logs\nc) Network storage\nd) Cache memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Transactional queues provide ACID properties for reliable message processing.",
    "target_text": "Question: Transactional queues provide ACID properties for:\nChoices:\na) Fast processing\nb) Reliable message processing\nc) Simple implementation\nd) Low memory usage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Replicated queues maintain copies across multiple nodes for fault tolerance.",
    "target_text": "Question: Replicated queues maintain copies for:\nChoices:\na) Performance optimization\nb) Fault tolerance\nc) Memory efficiency\nd) Code simplicity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Partitioned queues distribute load across multiple queue instances for scalability.",
    "target_text": "Question: Partitioned queues distribute load for:\nChoices:\na) Fault tolerance\nb) Scalability\nc) Security\nd) Simplicity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Sharded queues split data across multiple shards based on message keys or hash values.",
    "target_text": "Question: Sharded queues split data based on:\nChoices:\na) Message size\nb) Message keys or hash values\nc) Arrival time\nd) Random distribution\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Consistent hashing in distributed queues minimizes data movement when nodes are added or removed.",
    "target_text": "Question: Consistent hashing minimizes data movement when:\nChoices:\na) Messages are processed\nb) Nodes are added or removed\nc) Queues are created\nd) Systems are restarted\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Vector clocks in distributed queues help establish causal ordering of events.",
    "target_text": "Question: Vector clocks help establish:\nChoices:\na) Message size\nb) Causal ordering of events\nc) Processing speed\nd) Memory usage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Gossip protocols can be used for membership management in distributed queue systems.",
    "target_text": "Question: Gossip protocols are used for:\nChoices:\na) Message delivery\nb) Membership management\nc) Data encryption\nd) Performance monitoring\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Byzantine fault tolerance in queues handles malicious or corrupted nodes in distributed systems.",
    "target_text": "Question: Byzantine fault tolerance handles:\nChoices:\na) Network latency\nb) Malicious or corrupted nodes\nc) Memory limitations\nd) Processing delays\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Consensus algorithms like Raft ensure agreement on queue operations in distributed systems.",
    "target_text": "Question: Consensus algorithms ensure:\nChoices:\na) Fast processing\nb) Agreement on queue operations\nc) Low memory usage\nd) Simple implementation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue monitoring includes metrics like throughput, latency, queue depth, and error rates.",
    "target_text": "Question: Queue monitoring includes metrics like:\nChoices:\na) Code complexity only\nb) Throughput, latency, queue depth, error rates\nc) Memory addresses\nd) Variable names\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue health checks monitor system status and trigger alerts for anomalous conditions.",
    "target_text": "Question: Queue health checks monitor status and:\nChoices:\na) Optimize performance automatically\nb) Trigger alerts for anomalous conditions\nc) Fix errors automatically\nd) Generate documentation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Auto-scaling queues adjust capacity based on workload patterns and performance metrics.",
    "target_text": "Question: Auto-scaling queues adjust capacity based on:\nChoices:\na) Time of day only\nb) Workload patterns and performance metrics\nc) User preferences\nd) Random intervals\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue analytics provide insights into usage patterns, bottlenecks, and optimization opportunities.",
    "target_text": "Question: Queue analytics provide insights into:\nChoices:\na) Code structure only\nb) Usage patterns, bottlenecks, optimization opportunities\nc) Hardware specifications\nd) Network topology\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Capacity planning for queues involves predicting future load and resource requirements.",
    "target_text": "Question: Capacity planning involves predicting:\nChoices:\na) Code changes\nb) Future load and resource requirements\nc) User behavior only\nd) Technology trends\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue security includes authentication, authorization, encryption, and audit logging.",
    "target_text": "Question: Queue security includes:\nChoices:\na) Performance optimization only\nb) Authentication, authorization, encryption, audit logging\nc) Code formatting\nd) Data compression\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Message encryption protects sensitive data in transit and at rest within queue systems.",
    "target_text": "Question: Message encryption protects data:\nChoices:\na) Only during processing\nb) In transit and at rest\nc) Only in memory\nd) Only on disk\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Access control lists (ACLs) define permissions for queue operations and message access.",
    "target_text": "Question: ACLs define permissions for:\nChoices:\na) Hardware access\nb) Queue operations and message access\nc) Network routing\nd) File system operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Digital signatures ensure message integrity and non-repudiation in secure queue systems.",
    "target_text": "Question: Digital signatures ensure:\nChoices:\na) Fast processing\nb) Message integrity and non-repudiation\nc) Low latency\nd) High throughput\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue testing strategies include unit tests, integration tests, load tests, and chaos engineering.",
    "target_text": "Question: Queue testing strategies include:\nChoices:\na) Only unit tests\nb) Unit, integration, load tests, chaos engineering\nc) Only performance tests\nd) Only functional tests\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Load testing validates queue performance under expected and peak traffic conditions.",
    "target_text": "Question: Load testing validates performance under:\nChoices:\na) Normal conditions only\nb) Expected and peak traffic conditions\nc) Minimum load only\nd) Development environment only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Chaos engineering introduces controlled failures to test queue resilience and recovery mechanisms.",
    "target_text": "Question: Chaos engineering introduces controlled failures to test:\nChoices:\na) Performance optimization\nb) Queue resilience and recovery mechanisms\nc) Code quality\nd) Documentation accuracy\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue benchmarking compares different implementations and configurations for optimal performance.",
    "target_text": "Question: Queue benchmarking compares implementations for:\nChoices:\na) Code readability\nb) Optimal performance\nc) Development ease\nd) Documentation quality\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Fault injection testing validates queue behavior under various failure scenarios.",
    "target_text": "Question: Fault injection testing validates behavior under:\nChoices:\na) Normal operation\nb) Various failure scenarios\nc) Peak performance\nd) Optimal conditions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue documentation should include API specifications, usage examples, and operational guidelines.",
    "target_text": "Question: Queue documentation should include:\nChoices:\na) Only source code\nb) API specs, usage examples, operational guidelines\nc) Only installation instructions\nd) Only performance metrics\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Best practices for queue design include idempotency, graceful degradation, and monitoring.",
    "target_text": "Question: Queue design best practices include:\nChoices:\na) Complex algorithms only\nb) Idempotency, graceful degradation, monitoring\nc) Maximum performance only\nd) Minimum memory usage only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue maintenance involves regular cleanup, performance tuning, and capacity adjustments.",
    "target_text": "Question: Queue maintenance involves:\nChoices:\na) Code refactoring only\nb) Cleanup, performance tuning, capacity adjustments\nc) Documentation updates only\nd) Version control only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Disaster recovery planning for queues includes backup strategies and failover procedures.",
    "target_text": "Question: Disaster recovery planning includes:\nChoices:\na) Performance optimization only\nb) Backup strategies and failover procedures\nc) Code optimization only\nd) User training only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue migration strategies help transition between different implementations or cloud providers.",
    "target_text": "Question: Queue migration strategies help transition between:\nChoices:\na) Development phases\nb) Different implementations or cloud providers\nc) Team members\nd) Programming languages\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Version compatibility ensures queue systems can handle protocol and format changes gracefully.",
    "target_text": "Question: Version compatibility handles:\nChoices:\na) Code changes only\nb) Protocol and format changes gracefully\nc) Performance improvements only\nd) Bug fixes only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue deprecation strategies provide smooth transitions when retiring old queue implementations.",
    "target_text": "Question: Queue deprecation strategies provide:\nChoices:\na) Immediate shutdowns\nb) Smooth transitions when retiring implementations\nc) Performance improvements\nd) Feature additions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Compliance requirements may mandate specific queue behaviors for data retention and audit trails.",
    "target_text": "Question: Compliance requirements may mandate specific behaviors for:\nChoices:\na) Performance optimization\nb) Data retention and audit trails\nc) Code quality\nd) Development processes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue cost optimization involves balancing performance requirements with resource utilization efficiency.",
    "target_text": "Question: Queue cost optimization balances:\nChoices:\na) Features and complexity\nb) Performance requirements with resource efficiency\nc) Speed and accuracy\nd) Security and usability\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Cloud-native queue services provide managed infrastructure with automatic scaling and maintenance.",
    "target_text": "Question: Cloud-native queue services provide:\nChoices:\na) Manual configuration only\nb) Managed infrastructure with automatic scaling\nc) Local deployment only\nd) Fixed capacity only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Serverless queue architectures eliminate infrastructure management while providing event-driven processing.",
    "target_text": "Question: Serverless queue architectures eliminate infrastructure management while providing:\nChoices:\na) Batch processing only\nb) Event-driven processing\nc) Manual scaling\nd) Fixed scheduling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Edge computing uses local queues to process data closer to sources, reducing latency.",
    "target_text": "Question: Edge computing uses local queues to:\nChoices:\na) Centralize processing\nb) Process data closer to sources, reducing latency\nc) Increase bandwidth usage\nd) Simplify architecture\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Hybrid queue deployments combine on-premises and cloud-based components for optimal flexibility.",
    "target_text": "Question: Hybrid queue deployments combine components for:\nChoices:\na) Maximum security only\nb) Optimal flexibility\nc) Minimum cost only\nd) Simplest architecture\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Queue standardization efforts aim to improve interoperability between different queue implementations.",
    "target_text": "Question: Queue standardization efforts aim to improve:\nChoices:\na) Performance only\nb) Interoperability between implementations\nc) Security only\nd) Cost efficiency only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Educational queue simulations help students understand system behavior and performance characteristics.",
    "target_text": "Question: Educational queue simulations help understand:\nChoices:\na) Programming syntax only\nb) System behavior and performance characteristics\nc) Hardware specifications\nd) Network protocols only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Queue | Context: Research in queue theory continues to advance understanding of distributed systems and performance optimization.",
    "target_text": "Question: Queue theory research advances understanding of:\nChoices:\na) Basic algorithms only\nb) Distributed systems and performance optimization\nc) Programming languages only\nd) Hardware design only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: A heap is a specialized tree-based data structure that satisfies the heap property.",
    "target_text": "Question: What is a heap?\nChoices:\na) A linear data structure\nb) A specialized tree-based data structure\nc) A graph-based structure\nd) An array-only structure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: The heap property states that parent nodes have a specific ordering relationship with their children.",
    "target_text": "Question: The heap property relates to:\nChoices:\na) Node colors\nb) Tree height\nc) Ordering relationship between parent and children\nd) Number of nodes\nAnswer: c"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: A max-heap is a heap where parent nodes are greater than or equal to their children.",
    "target_text": "Question: In a max-heap, parent nodes are:\nChoices:\na) Less than children\nb) Greater than or equal to children\nc) Equal to children only\nd) Unrelated to children\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: A min-heap is a heap where parent nodes are less than or equal to their children.",
    "target_text": "Question: In a min-heap, parent nodes are:\nChoices:\na) Greater than children\nb) Less than or equal to children\nc) Equal to children only\nd) Random compared to children\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Binary heap is the most common type of heap where each node has at most two children.",
    "target_text": "Question: In a binary heap, each node has at most:\nChoices:\na) One child\nb) Two children\nc) Three children\nd) Unlimited children\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heaps are complete binary trees, meaning all levels are filled except possibly the last level.",
    "target_text": "Question: Heaps are:\nChoices:\na) Full binary trees\nb) Complete binary trees\nc) Perfect binary trees\nd) Balanced binary trees\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In a complete binary tree, the last level is filled from left to right.",
    "target_text": "Question: In a complete binary tree, the last level is filled:\nChoices:\na) From right to left\nb) From left to right\nc) Randomly\nd) From center outward\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: The root of a max-heap contains the maximum element in the heap.",
    "target_text": "Question: The root of a max-heap contains:\nChoices:\na) Minimum element\nb) Maximum element\nc) Average element\nd) Random element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: The root of a min-heap contains the minimum element in the heap.",
    "target_text": "Question: The root of a min-heap contains:\nChoices:\na) Maximum element\nb) Minimum element\nc) Average element\nd) Middle element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heaps are commonly implemented using arrays for efficient memory usage and cache performance.",
    "target_text": "Question: Heaps are commonly implemented using:\nChoices:\na) Linked lists only\nb) Arrays\nc) Hash tables only\nd) Stacks only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In array representation of heap, the root element is stored at index 0.",
    "target_text": "Question: In array representation, the root is at index:\nChoices:\na) 1\nb) 0\nc) -1\nd) n-1\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: For a node at index i, the left child is at index 2*i + 1 in zero-based indexing.",
    "target_text": "Question: For node at index i, left child is at:\nChoices:\na) 2*i\nb) 2*i + 1\nc) i + 1\nd) i/2\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: For a node at index i, the right child is at index 2*i + 2 in zero-based indexing.",
    "target_text": "Question: For node at index i, right child is at:\nChoices:\na) 2*i + 1\nb) 2*i + 2\nc) i + 2\nd) i*2\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: For a node at index i, the parent is at index (i-1)/2 in zero-based indexing.",
    "target_text": "Question: For node at index i, parent is at:\nChoices:\na) i/2\nb) (i-1)/2\nc) i-1\nd) 2*i\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Insert operation in heap adds new element while maintaining heap property.",
    "target_text": "Question: Insert operation must maintain:\nChoices:\na) Tree balance only\nb) Heap property\nc) Node count only\nd) Array size only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heapify operation restores heap property by comparing node with its children and swapping if necessary.",
    "target_text": "Question: Heapify operation:\nChoices:\na) Adds new elements\nb) Restores heap property\nc) Removes all elements\nd) Sorts the array\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Extract-max operation removes and returns the maximum element from a max-heap.",
    "target_text": "Question: Extract-max removes and returns:\nChoices:\na) Any element\nb) Maximum element from max-heap\nc) Minimum element\nd) Last inserted element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Extract-min operation removes and returns the minimum element from a min-heap.",
    "target_text": "Question: Extract-min removes and returns:\nChoices:\na) Maximum element\nb) Minimum element from min-heap\nc) Random element\nd) First inserted element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Time complexity of insert operation in binary heap is O(log n) due to upward heapify.",
    "target_text": "Question: Time complexity of heap insert is:\nChoices:\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n²)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Time complexity of extract operation in binary heap is O(log n) due to downward heapify.",
    "target_text": "Question: Time complexity of heap extract is:\nChoices:\na) O(1)\nb) O(log n)\nc) O(n)\nd) O(n log n)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Space complexity of binary heap is O(n) where n is the number of elements.",
    "target_text": "Question: Space complexity of binary heap is:\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n²)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap sort algorithm uses heap data structure to sort elements in O(n log n) time.",
    "target_text": "Question: Heap sort has time complexity of:\nChoices:\na) O(n)\nb) O(n log n)\nc) O(n²)\nd) O(2ⁿ)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Priority queue is commonly implemented using heap data structure.",
    "target_text": "Question: Priority queue is commonly implemented using:\nChoices:\na) Arrays only\nb) Heap data structure\nc) Linked lists only\nd) Stacks only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Dijkstra's shortest path algorithm uses priority queue implemented with min-heap.",
    "target_text": "Question: Dijkstra's algorithm uses:\nChoices:\na) Max-heap\nb) Min-heap priority queue\nc) Stack\nd) Regular queue\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Huffman coding algorithm uses min-heap to build optimal prefix codes.",
    "target_text": "Question: Huffman coding uses:\nChoices:\na) Max-heap\nb) Min-heap\nc) Binary search tree\nd) Hash table\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Build-heap operation creates heap from unsorted array in O(n) time.",
    "target_text": "Question: Build-heap operation takes:\nChoices:\na) O(log n) time\nb) O(n) time\nc) O(n log n) time\nd) O(n²) time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Bottom-up heap construction is more efficient than repeated insertion for building heap.",
    "target_text": "Question: Bottom-up heap construction is:\nChoices:\na) Less efficient than repeated insertion\nb) More efficient than repeated insertion\nc) Same efficiency as repeated insertion\nd) Not applicable to heaps\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap property ensures that extreme element (max or min) is always at the root.",
    "target_text": "Question: Heap property ensures extreme element is at:\nChoices:\na) Leaf nodes\nb) Root\nc) Middle level\nd) Random position\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heapify-up operation moves newly inserted element up the tree to maintain heap property.",
    "target_text": "Question: Heapify-up moves element:\nChoices:\na) Down the tree\nb) Up the tree\nc) Sideways\nd) To random position\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heapify-down operation moves element down the tree after extraction to maintain heap property.",
    "target_text": "Question: Heapify-down moves element:\nChoices:\na) Up the tree\nb) Down the tree\nc) To root\nd) To leaf\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Binary heap height is O(log n) due to complete tree structure.",
    "target_text": "Question: Binary heap height is:\nChoices:\na) O(n)\nb) O(log n)\nc) O(1)\nd) O(n²)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Peek operation returns the root element without removing it from the heap.",
    "target_text": "Question: Peek operation:\nChoices:\na) Removes root element\nb) Returns root without removing\nc) Adds new element\nd) Reorganizes heap\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Time complexity of peek operation is O(1) as it only accesses the root.",
    "target_text": "Question: Time complexity of peek operation is:\nChoices:\na) O(log n)\nb) O(1)\nc) O(n)\nd) O(n log n)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Delete operation removes specific element from heap and maintains heap property.",
    "target_text": "Question: Delete operation removes specific element and:\nChoices:\na) Ignores heap property\nb) Maintains heap property\nc) Destroys the heap\nd) Sorts the remaining elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Decrease-key operation reduces the key value of a specific element in min-heap.",
    "target_text": "Question: Decrease-key operation in min-heap:\nChoices:\na) Increases key value\nb) Reduces key value\nc) Removes the key\nd) Duplicates the key\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Increase-key operation increases the key value of a specific element in max-heap.",
    "target_text": "Question: Increase-key operation in max-heap:\nChoices:\na) Decreases key value\nb) Increases key value\nc) Removes the key\nd) Keeps key unchanged\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Merge operation combines two heaps into a single heap maintaining heap property.",
    "target_text": "Question: Merge operation combines heaps while:\nChoices:\na) Destroying heap property\nb) Maintaining heap property\nc) Sorting elements\nd) Reversing order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Array representation of heap provides good cache locality and memory efficiency.",
    "target_text": "Question: Array representation provides:\nChoices:\na) Poor cache performance\nb) Good cache locality and memory efficiency\nc) Complex implementation\nd) Slow access times\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Pointer-based representation of heap allows dynamic memory allocation but has overhead.",
    "target_text": "Question: Pointer-based representation:\nChoices:\na) Has no overhead\nb) Allows dynamic allocation but has overhead\nc) Uses less memory\nd) Is always faster\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Implicit tree structure in array representation eliminates need for explicit pointers.",
    "target_text": "Question: Implicit tree structure eliminates need for:\nChoices:\na) Array indices\nb) Explicit pointers\nc) Tree operations\nd) Memory allocation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Complete binary tree property ensures heap can be efficiently stored in contiguous array.",
    "target_text": "Question: Complete tree property enables efficient storage in:\nChoices:\na) Linked list\nb) Contiguous array\nc) Hash table\nd) Stack\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap sort is an in-place sorting algorithm with O(1) extra space.",
    "target_text": "Question: Heap sort uses:\nChoices:\na) O(n) extra space\nb) O(1) extra space\nc) O(log n) extra space\nd) O(n²) extra space\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap sort is not stable as it may change relative order of equal elements.",
    "target_text": "Question: Heap sort is:\nChoices:\na) Stable\nb) Not stable\nc) Sometimes stable\nd) Conditionally stable\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Selection algorithms use heaps to find kth smallest or largest element efficiently.",
    "target_text": "Question: Selection algorithms use heaps to find:\nChoices:\na) All elements\nb) kth smallest or largest element\nc) Average element\nd) Random element\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Top-k problems can be solved efficiently using heaps of size k.",
    "target_text": "Question: Top-k problems use heaps of size:\nChoices:\na) n\nb) k\nc) log k\nd) k²\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Median finding in stream of data can use two heaps (max-heap and min-heap).",
    "target_text": "Question: Median finding in streams uses:\nChoices:\na) Single heap\nb) Two heaps (max and min)\nc) Three heaps\nd) No heaps\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Event simulation systems use priority queues implemented with heaps for event scheduling.",
    "target_text": "Question: Event simulation uses heaps for:\nChoices:\na) Data storage\nb) Event scheduling\nc) User interface\nd) Network communication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Operating system task scheduling can use priority queues implemented with heaps.",
    "target_text": "Question: OS task scheduling can use heaps for:\nChoices:\na) Memory allocation\nb) Priority-based scheduling\nc) File operations\nd) Network management\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Graph algorithms like Prim's MST use min-heap priority queue for efficient edge selection.",
    "target_text": "Question: Prim's MST algorithm uses:\nChoices:\na) Max-heap\nb) Min-heap for edge selection\nc) Stack\nd) Regular queue\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: A* search algorithm uses priority queue with f-score to guide path finding.",
    "target_text": "Question: A* search uses priority queue with:\nChoices:\na) Random scores\nb) f-score to guide pathfinding\nc) Node count\nd) Edge weight only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Binomial heap supports efficient merge operation in O(log n) time.",
    "target_text": "Question: Binomial heap merge operation takes:\nChoices:\na) O(1) time\nb) O(log n) time\nc) O(n) time\nd) O(n²) time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Fibonacci heap provides better amortized time complexity for decrease-key operation.",
    "target_text": "Question: Fibonacci heap provides better:\nChoices:\na) Worst-case complexity\nb) Amortized time complexity for decrease-key\nc) Space complexity\nd) Implementation simplicity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: d-ary heap has d children per node instead of 2, affecting height and operation complexity.",
    "target_text": "Question: d-ary heap has:\nChoices:\na) 2 children per node\nb) d children per node\nc) Variable children\nd) No children limit\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Ternary heap (3-ary heap) can provide better performance for some applications than binary heap.",
    "target_text": "Question: Ternary heap has:\nChoices:\na) 2 children per node\nb) 3 children per node\nc) 4 children per node\nd) Unlimited children\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Min-max heap supports both minimum and maximum operations efficiently.",
    "target_text": "Question: Min-max heap supports:\nChoices:\na) Only minimum operations\nb) Both minimum and maximum operations\nc) Only maximum operations\nd) Neither operation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap property violation can be detected by comparing node with its children.",
    "target_text": "Question: Heap property violation is detected by comparing:\nChoices:\na) Node with siblings\nb) Node with children\nc) Node with parent only\nd) Random nodes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap validation checks if tree satisfies heap property at every node.",
    "target_text": "Question: Heap validation checks heap property at:\nChoices:\na) Root only\nb) Every node\nc) Leaf nodes only\nd) Random nodes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Level-order traversal of heap visits nodes level by level from top to bottom.",
    "target_text": "Question: Level-order traversal visits nodes:\nChoices:\na) Randomly\nb) Level by level from top to bottom\nc) From bottom to top\nd) Left to right only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap elements can be of any comparable data type including numbers, strings, and objects.",
    "target_text": "Question: Heap elements can be:\nChoices:\na) Only numbers\nb) Any comparable data type\nc) Only strings\nd) Only integers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Custom comparison functions allow heaps to work with complex objects and custom ordering.",
    "target_text": "Question: Custom comparison functions enable:\nChoices:\na) Faster operations\nb) Working with complex objects and custom ordering\nc) Smaller memory usage\nd) Simpler implementation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Generic heaps use templates or generics to work with different data types.",
    "target_text": "Question: Generic heaps use templates to:\nChoices:\na) Increase speed\nb) Work with different data types\nc) Reduce memory\nd) Simplify algorithms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap overflow occurs when trying to insert into a full fixed-size heap.",
    "target_text": "Question: Heap overflow occurs when:\nChoices:\na) Extracting from empty heap\nb) Inserting into full fixed-size heap\nc) Heap property is violated\nd) Array is too small\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap underflow occurs when trying to extract from an empty heap.",
    "target_text": "Question: Heap underflow occurs when:\nChoices:\na) Inserting into full heap\nb) Extracting from empty heap\nc) Heap is half full\nd) Array is resized\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Dynamic heap resizing allows heap to grow and shrink based on number of elements.",
    "target_text": "Question: Dynamic resizing allows heap to:\nChoices:\na) Stay fixed size\nb) Grow and shrink based on elements\nc) Only grow\nd) Only shrink\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Memory management for heaps involves allocation and deallocation of storage space.",
    "target_text": "Question: Heap memory management involves:\nChoices:\na) Only allocation\nb) Allocation and deallocation\nc) Only deallocation\nd) No memory operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Error handling in heap operations should check for boundary conditions and invalid states.",
    "target_text": "Question: Heap error handling should check for:\nChoices:\na) Performance only\nb) Boundary conditions and invalid states\nc) Memory addresses\nd) Code syntax\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Thread-safe heap implementations require synchronization for concurrent access.",
    "target_text": "Question: Thread-safe heaps require:\nChoices:\na) Faster processors\nb) Synchronization for concurrent access\nc) More memory\nd) Special data types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Lock-free heap implementations use atomic operations to avoid traditional locking.",
    "target_text": "Question: Lock-free heaps use:\nChoices:\na) Traditional locks\nb) Atomic operations\nc) No synchronization\nd) Manual coordination\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap iterator allows traversal of heap elements without modifying the structure.",
    "target_text": "Question: Heap iterator allows:\nChoices:\na) Modifying heap structure\nb) Traversal without modifying structure\nc) Only insertion\nd) Only deletion\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap debugging involves checking heap property invariants and structure validity.",
    "target_text": "Question: Heap debugging checks:\nChoices:\na) Code syntax only\nb) Heap property invariants and structure validity\nc) Performance metrics only\nd) Memory addresses only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap visualization helps understand structure and operation effects through graphical representation.",
    "target_text": "Question: Heap visualization helps understand:\nChoices:\na) Code complexity only\nb) Structure and operation effects\nc) Memory usage only\nd) Performance metrics only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Understanding heaps provides foundation for priority queue applications and sorting algorithms.",
    "target_text": "Question: Understanding heaps provides foundation for:\nChoices:\na) Only basic programming\nb) Priority queues and sorting algorithms\nc) Only web development\nd) Only database design\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap-based algorithms are essential in graph algorithms, scheduling, and optimization problems.",
    "target_text": "Question: Heap-based algorithms are essential in:\nChoices:\na) String processing only\nb) Graph algorithms, scheduling, optimization\nc) Array operations only\nd) File operations only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Practice with heap operations develops understanding of tree structures and algorithm design.",
    "target_text": "Question: Heap practice develops understanding of:\nChoices:\na) Only syntax\nb) Tree structures and algorithm design\nc) Only testing\nd) Only documentation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Real-world applications of heaps include task scheduling, data compression, and pathfinding.",
    "target_text": "Question: Real-world heap applications include:\nChoices:\na) Only academic problems\nb) Task scheduling, data compression, pathfinding\nc) Only simple calculations\nd) Only data storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap efficiency makes it suitable for applications requiring frequent minimum or maximum operations.",
    "target_text": "Question: Heaps are suitable for applications requiring frequent:\nChoices:\na) Random access\nb) Minimum or maximum operations\nc) Middle element access\nd) Sequential access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Problem-solving skills from heap study transfer to many algorithmic and system design challenges.",
    "target_text": "Question: Heap problem-solving skills transfer to:\nChoices:\na) Only heap problems\nb) Many algorithmic and system design challenges\nc) Only academic exercises\nd) Only simple programs\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Binary heap search operation has O(n) time complexity as heap is not designed for searching.",
    "target_text": "Question: Binary heap search has time complexity:\nChoices:\na) O(1)\nb) O(n)\nc) O(log n)\nd) O(n log n)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heaps do not maintain sorted order but only guarantee the heap property relationship.",
    "target_text": "Question: Heaps guarantee:\nChoices:\na) Fully sorted order\nb) Only heap property relationship\nc) Random order\nd) Reverse sorted order\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Parent-child relationship in heap depends on the comparison operator used (< for min, > for max).",
    "target_text": "Question: Parent-child relationship depends on:\nChoices:\na) Node position\nb) Comparison operator used\nc) Tree height\nd) Array index\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap construction from array elements requires heapify operations starting from bottom level.",
    "target_text": "Question: Heap construction starts heapify from:\nChoices:\na) Root level\nb) Bottom level\nc) Middle level\nd) Random level\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Last non-leaf node in heap is at index (n/2 - 1) where n is total number of elements.",
    "target_text": "Question: Last non-leaf node is at index:\nChoices:\na) n-1\nb) n/2 - 1\nc) n/2\nd) 0\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Leaf nodes in heap have no children and are located at the bottom level of the tree.",
    "target_text": "Question: Leaf nodes in heap:\nChoices:\na) Have two children\nb) Have no children\nc) Have one child\nd) Have variable children\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap size refers to the current number of elements stored in the heap.",
    "target_text": "Question: Heap size refers to:\nChoices:\na) Maximum capacity\nb) Current number of elements\nc) Array length\nd) Tree height\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap capacity refers to the maximum number of elements the heap can store.",
    "target_text": "Question: Heap capacity refers to:\nChoices:\na) Current elements\nb) Maximum elements it can store\nc) Tree height\nd) Memory address range\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: isEmpty operation checks if heap contains no elements.",
    "target_text": "Question: isEmpty operation checks if heap:\nChoices:\na) Is full\nb) Contains no elements\nc) Has maximum elements\nd) Needs resizing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: isFull operation checks if heap has reached its maximum capacity.",
    "target_text": "Question: isFull operation checks if heap:\nChoices:\na) Is empty\nb) Has reached maximum capacity\nc) Needs sorting\nd) Has errors\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Clear operation removes all elements from heap, making it empty.",
    "target_text": "Question: Clear operation:\nChoices:\na) Sorts heap elements\nb) Removes all elements making heap empty\nc) Adds elements\nd) Checks heap property\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Copy constructor creates a new heap with same elements as original heap.",
    "target_text": "Question: Copy constructor creates:\nChoices:\na) Empty heap\nb) New heap with same elements\nc) Reference to original\nd) Sorted version\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Deep copy of heap creates independent copy with separate memory allocation.",
    "target_text": "Question: Deep copy creates:\nChoices:\na) Shared memory reference\nb) Independent copy with separate memory\nc) Partial copy\nd) Empty structure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Shallow copy of heap only copies references, leading to shared memory issues.",
    "target_text": "Question: Shallow copy leads to:\nChoices:\na) Independent memory\nb) Shared memory issues\nc) Better performance\nd) Automatic sorting\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Comparison of two heaps checks if they contain same elements in same heap structure.",
    "target_text": "Question: Heap comparison checks if they contain:\nChoices:\na) Different elements\nb) Same elements in same structure\nc) Any elements\nd) Sorted elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap serialization converts heap structure into format suitable for storage or transmission.",
    "target_text": "Question: Heap serialization converts structure for:\nChoices:\na) Fast access\nb) Storage or transmission\nc) Memory optimization\nd) Error checking\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Deserialization reconstructs heap from serialized format back into usable structure.",
    "target_text": "Question: Deserialization reconstructs heap from:\nChoices:\na) Random data\nb) Serialized format\nc) Empty structure\nd) User input\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap performance depends on cache locality, which is better in array implementation.",
    "target_text": "Question: Array implementation provides better:\nChoices:\na) Dynamic allocation\nb) Cache locality\nc) Pointer flexibility\nd) Memory fragmentation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Cache misses in heap operations can be reduced by optimizing memory access patterns.",
    "target_text": "Question: Cache misses can be reduced by optimizing:\nChoices:\na) Algorithm logic\nb) Memory access patterns\nc) Variable names\nd) Code comments\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Memory fragmentation can occur in pointer-based heap implementations.",
    "target_text": "Question: Memory fragmentation occurs in:\nChoices:\na) Array-based implementations\nb) Pointer-based implementations\nc) All implementations\nd) No implementations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Memory allocation strategies affect performance of dynamic heap implementations.",
    "target_text": "Question: Memory allocation strategies affect:\nChoices:\na) Algorithm correctness\nb) Performance of dynamic implementations\nc) Heap property\nd) Tree structure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Garbage collection can impact performance of heap operations in managed languages.",
    "target_text": "Question: Garbage collection can impact:\nChoices:\na) Algorithm correctness\nb) Performance of heap operations\nc) Heap property\nd) Tree structure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Branch prediction in modern CPUs can be affected by comparison patterns in heap operations.",
    "target_text": "Question: Branch prediction is affected by:\nChoices:\na) Memory size\nb) Comparison patterns in heap operations\nc) Variable types\nd) Code length\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: SIMD instructions can potentially optimize certain heap operations through parallel processing.",
    "target_text": "Question: SIMD instructions can optimize heap operations through:\nChoices:\na) Sequential processing\nb) Parallel processing\nc) Recursive calls\nd) Memory allocation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: K-way merge uses heap to efficiently merge k sorted sequences.",
    "target_text": "Question: K-way merge uses heap to merge:\nChoices:\na) Unsorted sequences\nb) K sorted sequences\nc) Single sequence\nd) Random sequences\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: External sorting algorithms use heaps when data doesn't fit in main memory.",
    "target_text": "Question: External sorting uses heaps when data doesn't fit in:\nChoices:\na) Secondary storage\nb) Main memory\nc) Cache memory\nd) Virtual memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Tournament sort uses complete binary tree structure similar to heap for sorting.",
    "target_text": "Question: Tournament sort uses structure similar to:\nChoices:\na) Array\nb) Heap\nc) Linked list\nd) Hash table\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Smoothsort is a variation of heap sort with better performance on partially sorted data.",
    "target_text": "Question: Smoothsort is variation of heap sort with better performance on:\nChoices:\na) Random data\nb) Partially sorted data\nc) Reverse sorted data\nd) Duplicate data\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Introsort combines quicksort, heapsort, and insertion sort for optimal performance.",
    "target_text": "Question: Introsort combines quicksort, insertion sort, and:\nChoices:\na) Merge sort\nb) Heap sort\nc) Bubble sort\nd) Selection sort\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Partial sorting problems can be solved efficiently using heaps instead of full sorting.",
    "target_text": "Question: Partial sorting problems are efficiently solved using:\nChoices:\na) Full sorting algorithms\nb) Heaps instead of full sorting\nc) Linear search\nd) Hash tables\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Order statistics problems use heaps to find elements at specific ranks efficiently.",
    "target_text": "Question: Order statistics use heaps to find elements at:\nChoices:\na) Random positions\nb) Specific ranks efficiently\nc) All positions\nd) No specific position\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Sliding window maximum/minimum problems can be solved using heaps with lazy deletion.",
    "target_text": "Question: Sliding window problems use heaps with:\nChoices:\na) Immediate deletion\nb) Lazy deletion\nc) No deletion\nd) Random deletion\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Running median calculation uses two heaps to maintain median efficiently in streaming data.",
    "target_text": "Question: Running median uses two heaps for:\nChoices:\na) Static data\nb) Streaming data\nc) Sorted data\nd) Small datasets\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Load balancing algorithms can use heaps to distribute tasks based on server loads.",
    "target_text": "Question: Load balancing uses heaps to distribute tasks based on:\nChoices:\na) Task size\nb) Server loads\nc) Random assignment\nd) Task type\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Job scheduling systems use priority heaps to manage tasks with different priorities.",
    "target_text": "Question: Job scheduling uses priority heaps to manage:\nChoices:\na) Same priority tasks\nb) Tasks with different priorities\nc) Completed tasks\nd) System resources\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Timer management in operating systems uses heaps to track events ordered by time.",
    "target_text": "Question: Timer management uses heaps to track events ordered by:\nChoices:\na) Priority\nb) Time\nc) Size\nd) Type\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Memory management algorithms can use heaps to track free memory blocks by size.",
    "target_text": "Question: Memory management uses heaps to track free blocks by:\nChoices:\na) Address\nb) Size\nc) Type\nd) Age\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Bandwidth allocation in networks can use heaps to prioritize traffic flows.",
    "target_text": "Question: Bandwidth allocation uses heaps to:\nChoices:\na) Store network topology\nb) Prioritize traffic flows\nc) Monitor connections\nd) Route packets\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Resource allocation in cloud computing uses heaps to optimize resource utilization.",
    "target_text": "Question: Cloud resource allocation uses heaps to:\nChoices:\na) Store user data\nb) Optimize resource utilization\nc) Handle authentication\nd) Manage billing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Database query optimization can use heaps for cost-based query plan selection.",
    "target_text": "Question: Database optimization uses heaps for:\nChoices:\na) Data storage\nb) Cost-based query plan selection\nc) User authentication\nd) Backup operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Machine learning algorithms use heaps in k-nearest neighbors for efficient neighbor finding.",
    "target_text": "Question: k-NN algorithms use heaps for:\nChoices:\na) Feature selection\nb) Efficient neighbor finding\nc) Model training\nd) Data preprocessing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Game AI systems use heaps in A* pathfinding for open set management.",
    "target_text": "Question: Game AI uses heaps in A* for:\nChoices:\na) Score calculation\nb) Open set management\nc) Graphics rendering\nd) Player input\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Image processing algorithms use heaps in region growing for pixel selection by similarity.",
    "target_text": "Question: Region growing uses heaps for pixel selection by:\nChoices:\na) Position\nb) Similarity\nc) Color only\nd) Random criteria\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Financial algorithms use heaps for option pricing models with early exercise features.",
    "target_text": "Question: Option pricing models use heaps for:\nChoices:\na) Price storage\nb) Early exercise features\nc) Market data\nd) User interface\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Simulation engines use heaps for discrete event scheduling in time-ordered processing.",
    "target_text": "Question: Simulation engines use heaps for:\nChoices:\na) Data visualization\nb) Discrete event scheduling\nc) User interaction\nd) Results storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Network packet scheduling uses heaps to implement quality of service policies.",
    "target_text": "Question: Network packet scheduling uses heaps to implement:\nChoices:\na) Routing tables\nb) Quality of service policies\nc) Security protocols\nd) Error detection\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Compiler optimization uses heaps in register allocation for spill cost management.",
    "target_text": "Question: Register allocation uses heaps for:\nChoices:\na) Code generation\nb) Spill cost management\nc) Syntax analysis\nd) Error reporting\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Parallel computing uses heaps for work-stealing schedulers to balance load among threads.",
    "target_text": "Question: Work-stealing schedulers use heaps to:\nChoices:\na) Synchronize threads\nb) Balance load among threads\nc) Allocate memory\nd) Handle exceptions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Data stream algorithms use heaps to maintain top-k elements efficiently in one pass.",
    "target_text": "Question: Data stream algorithms use heaps to maintain:\nChoices:\na) All elements\nb) Top-k elements efficiently\nc) Average values\nd) Historical data\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Cache replacement algorithms use heaps to implement least frequently used (LFU) policies.",
    "target_text": "Question: LFU cache replacement uses heaps based on:\nChoices:\na) Access time\nb) Access frequency\nc) Data size\nd) Storage location\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Graph algorithms use heaps in shortest path problems like Dijkstra's and A* search.",
    "target_text": "Question: Shortest path algorithms use heaps for:\nChoices:\na) Graph storage\nb) Efficient vertex selection\nc) Path visualization\nd) Graph validation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Minimum spanning tree algorithms like Prim's use heaps for efficient edge selection.",
    "target_text": "Question: Prim's MST algorithm uses heaps for:\nChoices:\na) Graph representation\nb) Efficient edge selection\nc) Cycle detection\nd) Tree visualization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Maximum flow algorithms can use heaps in push-relabel methods for vertex selection.",
    "target_text": "Question: Push-relabel maximum flow uses heaps for:\nChoices:\na) Flow calculation\nb) Vertex selection\nc) Cut identification\nd) Graph storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Approximation algorithms use heaps in facility location problems for efficient candidate selection.",
    "target_text": "Question: Facility location algorithms use heaps for:\nChoices:\na) Distance calculation\nb) Efficient candidate selection\nc) Cost computation\nd) Solution verification\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Dynamic programming algorithms use heaps in optimization problems with priority-based state exploration.",
    "target_text": "Question: DP optimization uses heaps for:\nChoices:\na) State storage\nb) Priority-based state exploration\nc) Result caching\nd) Algorithm verification\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Online algorithms use heaps to make decisions with partial information in competitive analysis.",
    "target_text": "Question: Online algorithms use heaps to make decisions with:\nChoices:\na) Complete information\nb) Partial information\nc) No information\nd) Future information\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Distributed systems use heaps for consensus algorithms in leader election processes.",
    "target_text": "Question: Consensus algorithms use heaps for:\nChoices:\na) Data replication\nb) Leader election processes\nc) Message routing\nd) Fault detection\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Multi-threaded applications use concurrent heaps with lock-free or wait-free implementations.",
    "target_text": "Question: Concurrent heaps use:\nChoices:\na) Traditional locking only\nb) Lock-free or wait-free implementations\nc) Sequential access only\nd) Single-threaded operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Memory allocators use heaps to manage free memory chunks efficiently by size.",
    "target_text": "Question: Memory allocators use heaps to manage:\nChoices:\na) Used memory only\nb) Free memory chunks by size\nc) Virtual memory\nd) Cache memory\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Garbage collectors use heaps in generational collection strategies for object management.",
    "target_text": "Question: Generational garbage collection uses heaps for:\nChoices:\na) Code storage\nb) Object management\nc) Thread synchronization\nd) Exception handling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Real-time systems use heaps for deadline-driven scheduling with earliest deadline first policies.",
    "target_text": "Question: Deadline-driven scheduling uses heaps for:\nChoices:\na) Resource allocation\nb) Earliest deadline first policies\nc) Memory management\nd) I/O operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Embedded systems use heaps for power-aware scheduling to optimize energy consumption.",
    "target_text": "Question: Power-aware scheduling uses heaps to optimize:\nChoices:\na) Processing speed\nb) Energy consumption\nc) Memory usage\nd) Code size\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Bioinformatics algorithms use heaps in sequence alignment for efficient gap penalty management.",
    "target_text": "Question: Sequence alignment uses heaps for:\nChoices:\na) Sequence storage\nb) Gap penalty management\nc) Base pair counting\nd) Quality scoring\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Computational geometry uses heaps in sweep line algorithms for event point processing.",
    "target_text": "Question: Sweep line algorithms use heaps for:\nChoices:\na) Shape storage\nb) Event point processing\nc) Coordinate transformation\nd) Distance calculation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Cryptographic algorithms use heaps in key generation processes for entropy management.",
    "target_text": "Question: Key generation uses heaps for:\nChoices:\na) Encryption\nb) Entropy management\nc) Decryption\nd) Authentication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Blockchain systems use heaps for transaction fee prioritization in mempool management.",
    "target_text": "Question: Blockchain mempool uses heaps for:\nChoices:\na) Block validation\nb) Transaction fee prioritization\nc) Consensus mechanism\nd) Network communication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Recommendation systems use heaps for collaborative filtering in top-N recommendation generation.",
    "target_text": "Question: Collaborative filtering uses heaps for:\nChoices:\na) User profiling\nb) Top-N recommendation generation\nc) Data preprocessing\nd) Model training\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Search engines use heaps for relevance scoring in query result ranking.",
    "target_text": "Question: Search engines use heaps for:\nChoices:\na) Index storage\nb) Query result ranking\nc) Web crawling\nd) Content analysis\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Video streaming systems use heaps for adaptive bitrate selection based on network conditions.",
    "target_text": "Question: Adaptive bitrate selection uses heaps based on:\nChoices:\na) Video content\nb) Network conditions\nc) User preferences\nd) Device capabilities\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: IoT systems use heaps for sensor data prioritization in resource-constrained environments.",
    "target_text": "Question: IoT sensor prioritization uses heaps in:\nChoices:\na) High-resource environments\nb) Resource-constrained environments\nc) Cloud-only deployments\nd) Unlimited bandwidth scenarios\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Automotive systems use heaps for safety-critical task scheduling in real-time control.",
    "target_text": "Question: Automotive systems use heaps for:\nChoices:\na) Entertainment features\nb) Safety-critical task scheduling\nc) Navigation only\nd) Communication systems\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Weather forecasting uses heaps for ensemble prediction prioritization in meteorological models.",
    "target_text": "Question: Weather forecasting uses heaps for:\nChoices:\na) Data collection\nb) Ensemble prediction prioritization\nc) Sensor calibration\nd) Historical analysis\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Social network analysis uses heaps for influence maximization in viral marketing algorithms.",
    "target_text": "Question: Influence maximization uses heaps for:\nChoices:\na) User authentication\nb) Viral marketing algorithms\nc) Content moderation\nd) Privacy protection\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Computer graphics uses heaps for ray tracing acceleration in rendering pipelines.",
    "target_text": "Question: Ray tracing uses heaps for:\nChoices:\na) Texture mapping\nb) Rendering acceleration\nc) Color correction\nd) Model animation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Supply chain optimization uses heaps for demand forecasting prioritization in inventory management.",
    "target_text": "Question: Supply chain optimization uses heaps for:\nChoices:\na) Product manufacturing\nb) Demand forecasting prioritization\nc) Quality control\nd) Customer service\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Educational applications use heaps for adaptive learning systems in personalized content delivery.",
    "target_text": "Question: Adaptive learning uses heaps for:\nChoices:\na) Student registration\nb) Personalized content delivery\nc) Grade calculation\nd) Attendance tracking\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Quantum computing simulators use heaps for state vector prioritization in quantum algorithm simulation.",
    "target_text": "Question: Quantum simulators use heaps for:\nChoices:\na) Qubit initialization\nb) State vector prioritization\nc) Error correction\nd) Measurement operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Research in heap data structures continues advancing with new variants and optimization techniques.",
    "target_text": "Question: Heap research continues advancing with:\nChoices:\na) Only theoretical analysis\nb) New variants and optimization techniques\nc) Only implementation details\nd) Only educational materials\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap-based median finding uses two heaps to maintain running median efficiently for streaming data.",
    "target_text": "Question: For running median, two heaps are used where max-heap stores:\nChoices:\na) All elements\nb) Smaller half of elements\nc) Larger half of elements\nd) Random elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: In two-heap median approach, min-heap stores the larger half while max-heap stores smaller half.",
    "target_text": "Question: In two-heap median approach, min-heap stores:\nChoices:\na) Smaller half of elements\nb) Larger half of elements\nc) All elements\nd) Median element only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap pollution occurs when heap contains objects whose types are not instances of its parameterized type.",
    "target_text": "Question: Heap pollution occurs when heap contains:\nChoices:\na) Too many elements\nb) Objects with incorrect types\nc) Duplicate elements\nd) NULL elements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Type safety in generic heaps prevents ClassCastException at runtime through compile-time checking.",
    "target_text": "Question: Type safety in generic heaps prevents:\nChoices:\na) Memory leaks\nb) ClassCastException at runtime\nc) Stack overflow\nd) Infinite loops\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Wildcard types in Java heaps use ? extends and ? super for flexible generic programming.",
    "target_text": "Question: Wildcard types in Java heaps use:\nChoices:\na) Only ? extends\nb) ? extends and ? super\nc) Only ? super\nd) No special syntax\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: PECS principle (Producer Extends, Consumer Super) guides wildcard usage in heap collections.",
    "target_text": "Question: PECS principle guides:\nChoices:\na) Memory allocation\nb) Wildcard usage in collections\nc) Algorithm selection\nd) Performance optimization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Soft heap data structure deliberately violates heap property for some elements to achieve linear time.",
    "target_text": "Question: Soft heap deliberately violates heap property to achieve:\nChoices:\na) Better space complexity\nb) Linear time complexity\nc) Simpler implementation\nd) Better cache performance\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Weak heap is a variant where heap property is relaxed for right children to simplify operations.",
    "target_text": "Question: Weak heap relaxes heap property for:\nChoices:\na) Left children\nb) Right children\nc) Root node\nd) Leaf nodes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Skew heap is a self-adjusting heap that merges along the right spine for amortized efficiency.",
    "target_text": "Question: Skew heap merges along:\nChoices:\na) Left spine\nb) Right spine\nc) Random path\nd) Shortest path\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Leftist heap maintains the leftist property where left subtree has longer or equal null path length.",
    "target_text": "Question: Leftist heap maintains property where left subtree has:\nChoices:\na) Shorter null path length\nb) Longer or equal null path length\nc) Same number of nodes\nd) Random structure\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Pairing heap supports fast decrease-key operation but has complex analysis for worst-case bounds.",
    "target_text": "Question: Pairing heap is known for:\nChoices:\na) Worst-case optimal operations\nb) Fast decrease-key but complex analysis\nc) Simple implementation only\nd) Constant time operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Rank-pairing heap improves upon pairing heap with better theoretical bounds for decrease-key.",
    "target_text": "Question: Rank-pairing heap improves upon pairing heap with:\nChoices:\na) Simpler implementation\nb) Better theoretical bounds\nc) Less memory usage\nd) Faster insertion\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Hollow heap provides optimal amortized bounds for all operations including delete and decrease-key.",
    "target_text": "Question: Hollow heap provides optimal amortized bounds for:\nChoices:\na) Only basic operations\nb) All operations including delete and decrease-key\nc) Only decrease-key\nd) Only insertion and extraction\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: 2-3 heap combines properties of 2-3 trees with heap structure for better worst-case performance.",
    "target_text": "Question: 2-3 heap combines properties of:\nChoices:\na) Binary trees and arrays\nb) 2-3 trees and heap structure\nc) Hash tables and trees\nd) Stacks and queues\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Brodal queue achieves optimal worst-case bounds for all priority queue operations.",
    "target_text": "Question: Brodal queue achieves:\nChoices:\na) Good average performance\nb) Optimal worst-case bounds\nc) Simple implementation\nd) Minimal memory usage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Beap (binary heap + array) stores elements in triangular array structure with heap properties.",
    "target_text": "Question: Beap stores elements in:\nChoices:\na) Linear array\nb) Triangular array structure\nc) Circular array\nd) Multi-dimensional array\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Van Emde Boas tree provides O(log log u) operations for integer keys in universe size u.",
    "target_text": "Question: Van Emde Boas tree operations have complexity:\nChoices:\na) O(log n)\nb) O(log log u)\nc) O(log u)\nd) O(u)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Y-fast trie combines hash tables with Van Emde Boas trees for dynamic integer sets.",
    "target_text": "Question: Y-fast trie combines:\nChoices:\na) Arrays and trees\nb) Hash tables with Van Emde Boas trees\nc) Heaps and queues\nd) Stacks and lists\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Fusion tree achieves O(log n / log log n) search time for integer keys using bit manipulation.",
    "target_text": "Question: Fusion tree achieves search time of:\nChoices:\na) O(log n)\nb) O(log n / log log n)\nc) O(log log n)\nd) O(n)\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Cache-oblivious heaps achieve optimal cache performance without knowing cache parameters.",
    "target_text": "Question: Cache-oblivious heaps achieve optimal performance without knowing:\nChoices:\na) Data size\nb) Cache parameters\nc) Algorithm complexity\nd) Memory layout\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: External memory heaps are designed for data that doesn't fit in main memory using disk-based storage.",
    "target_text": "Question: External memory heaps are designed for data that doesn't fit in:\nChoices:\na) Cache memory\nb) Main memory\nc) Virtual memory\nd) Secondary storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: I/O-efficient heaps minimize disk accesses by optimizing block transfers in external storage.",
    "target_text": "Question: I/O-efficient heaps minimize:\nChoices:\na) Memory usage\nb) Disk accesses\nc) CPU time\nd) Network traffic\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Buffer tree combines heap properties with buffering to achieve efficient external memory operations.",
    "target_text": "Question: Buffer tree combines heap properties with:\nChoices:\na) Caching\nb) Buffering\nc) Compression\nd) Encryption\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Persistent heaps maintain multiple versions of the structure while sharing common parts.",
    "target_text": "Question: Persistent heaps maintain:\nChoices:\na) Single version only\nb) Multiple versions while sharing parts\nc) Complete copies only\nd) No version history\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Functional heaps in immutable programming create new versions without modifying existing structure.",
    "target_text": "Question: Functional heaps create new versions:\nChoices:\na) By modifying existing structure\nb) Without modifying existing structure\nc) Using reference copying\nd) Through memory reallocation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Path copying in persistent heaps creates new path from root to modified node.",
    "target_text": "Question: Path copying creates new path from:\nChoices:\na) Leaf to root\nb) Root to modified node\nc) Random nodes\nd) Adjacent nodes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Fat node method stores multiple values per node to implement persistence efficiently.",
    "target_text": "Question: Fat node method stores:\nChoices:\na) Single value per node\nb) Multiple values per node\nc) No values\nd) References only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Parallel heap construction uses divide-and-conquer to build heaps efficiently on multiple processors.",
    "target_text": "Question: Parallel heap construction uses:\nChoices:\na) Sequential processing\nb) Divide-and-conquer on multiple processors\nc) Single-threaded algorithms\nd) Memory sharing only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Work-optimal parallel algorithms achieve same total work as best sequential algorithm.",
    "target_text": "Question: Work-optimal parallel algorithms achieve:\nChoices:\na) Better total work than sequential\nb) Same total work as best sequential\nc) Worse total work than sequential\nd) Undefined work complexity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Parallel merge in heap operations requires careful synchronization to maintain heap property.",
    "target_text": "Question: Parallel merge requires careful:\nChoices:\na) Memory allocation\nb) Synchronization to maintain heap property\nc) Algorithm selection\nd) Data compression\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Lock-free heap operations use compare-and-swap to avoid blocking in concurrent environments.",
    "target_text": "Question: Lock-free heap operations use:\nChoices:\na) Traditional locking\nb) Compare-and-swap\nc) Thread barriers\nd) Message passing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Wait-free heap guarantees that every thread completes operations in bounded steps.",
    "target_text": "Question: Wait-free heap guarantees every thread completes operations in:\nChoices:\na) Unbounded steps\nb) Bounded steps\nc) Constant time\nd) Linear time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Obstruction-free heap ensures progress when thread runs in isolation without interference.",
    "target_text": "Question: Obstruction-free heap ensures progress when thread runs:\nChoices:\na) With maximum interference\nb) In isolation without interference\nc) With controlled interference\nd) Never guarantees progress\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Memory reclamation in concurrent heaps uses techniques like hazard pointers or epochs.",
    "target_text": "Question: Memory reclamation in concurrent heaps uses:\nChoices:\na) Immediate deletion\nb) Hazard pointers or epochs\nc) Reference counting only\nd) No special techniques\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: ABA prevention in concurrent heaps uses version numbers or pointer marking techniques.",
    "target_text": "Question: ABA prevention uses:\nChoices:\na) Thread synchronization only\nb) Version numbers or pointer marking\nc) Memory barriers only\nd) Lock acquisition\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Scalable heap implementations distribute load among multiple data structures to reduce contention.",
    "target_text": "Question: Scalable heaps distribute load to:\nChoices:\na) Increase contention\nb) Reduce contention\nc) Centralize operations\nd) Simplify implementation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: NUMA-aware heaps consider memory locality in non-uniform memory access architectures.",
    "target_text": "Question: NUMA-aware heaps consider:\nChoices:\na) CPU frequency\nb) Memory locality\nc) Network latency\nd) Disk speed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Locality-sensitive heaps optimize for spatial and temporal locality in memory access patterns.",
    "target_text": "Question: Locality-sensitive heaps optimize for:\nChoices:\na) CPU utilization\nb) Spatial and temporal locality\nc) Network bandwidth\nd) Power consumption\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap profiling identifies performance bottlenecks and memory usage patterns in applications.",
    "target_text": "Question: Heap profiling identifies:\nChoices:\na) Code syntax errors\nb) Performance bottlenecks and memory patterns\nc) Compilation errors\nd) Network issues\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Memory leak detection in heaps identifies objects that are no longer reachable but not freed.",
    "target_text": "Question: Memory leak detection identifies objects that are:\nChoices:\na) Still in use\nb) No longer reachable but not freed\nc) Recently allocated\nd) Properly managed\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap fragmentation analysis measures wasted space due to allocation and deallocation patterns.",
    "target_text": "Question: Heap fragmentation analysis measures:\nChoices:\na) Total memory usage\nb) Wasted space due to allocation patterns\nc) Processing speed\nd) Network throughput\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Generational hypothesis states that most objects die young, influencing garbage collection design.",
    "target_text": "Question: Generational hypothesis states that most objects:\nChoices:\na) Live forever\nb) Die young\nc) Are never used\nd) Grow over time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Card marking tracks modifications to old generation objects that reference young generation.",
    "target_text": "Question: Card marking tracks modifications to:\nChoices:\na) Young generation only\nb) Old generation objects referencing young\nc) All objects equally\nd) Stack objects only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Write barriers maintain consistency between collector and mutator in concurrent garbage collection.",
    "target_text": "Question: Write barriers maintain consistency between:\nChoices:\na) Different threads\nb) Collector and mutator\nc) Memory regions\nd) Process boundaries\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Incremental garbage collection spreads collection work over multiple small intervals.",
    "target_text": "Question: Incremental garbage collection spreads work over:\nChoices:\na) Single large interval\nb) Multiple small intervals\nc) Random intervals\nd) No specific intervals\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Concurrent garbage collection allows mutator and collector to run simultaneously.",
    "target_text": "Question: Concurrent garbage collection allows:\nChoices:\na) Only collector to run\nb) Mutator and collector to run simultaneously\nc) Only mutator to run\nd) Neither to run\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Precise garbage collection knows exact locations of all pointers for accurate reachability analysis.",
    "target_text": "Question: Precise garbage collection knows exact locations of:\nChoices:\na) All data\nb) All pointers\nc) Some pointers\nd) No pointers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Conservative garbage collection treats any bit pattern that could be a pointer as actual pointer.",
    "target_text": "Question: Conservative garbage collection treats potential pointers as:\nChoices:\na) Definitely not pointers\nb) Actual pointers\nc) Unknown data\nd) Error conditions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Reference counting garbage collection maintains count of references to each object.",
    "target_text": "Question: Reference counting maintains:\nChoices:\na) Object sizes\nb) Count of references to each object\nc) Access frequencies\nd) Creation timestamps\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Cycle collection handles reference cycles that reference counting cannot reclaim automatically.",
    "target_text": "Question: Cycle collection handles:\nChoices:\na) Simple references\nb) Reference cycles\nc) Null references\nd) Global references\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Weak references allow objects to be garbage collected even when weak references exist.",
    "target_text": "Question: Weak references allow objects to be:\nChoices:\na) Never collected\nb) Garbage collected despite references\nc) Always accessible\nd) Automatically promoted\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Phantom references provide notification when objects are about to be garbage collected.",
    "target_text": "Question: Phantom references provide:\nChoices:\na) Strong object access\nb) Notification before garbage collection\nc) Weak object access\nd) Automatic object creation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Finalization allows objects to perform cleanup before being garbage collected.",
    "target_text": "Question: Finalization allows objects to perform:\nChoices:\na) Initialization\nb) Cleanup before garbage collection\nc) Runtime optimization\nd) Memory expansion\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Resurrection occurs when finalization code makes unreachable object reachable again.",
    "target_text": "Question: Resurrection occurs when finalization makes unreachable object:\nChoices:\na) Permanently unreachable\nb) Reachable again\nc) Immediately collected\nd) Corrupted\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap size tuning involves balancing memory usage with garbage collection frequency and duration.",
    "target_text": "Question: Heap size tuning balances memory usage with:\nChoices:\na) CPU speed\nb) GC frequency and duration\nc) Network performance\nd) Disk space\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: GC ergonomics automatically adjusts heap parameters to meet performance goals.",
    "target_text": "Question: GC ergonomics automatically adjusts:\nChoices:\na) Application logic\nb) Heap parameters to meet performance goals\nc) User interfaces\nd) Network settings\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Allocation rate affects garbage collection frequency and application performance significantly.",
    "target_text": "Question: Allocation rate significantly affects:\nChoices:\na) Code readability\nb) GC frequency and performance\nc) Variable naming\nd) Function definitions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Object lifetime distribution influences choice of garbage collection strategy and parameters.",
    "target_text": "Question: Object lifetime distribution influences:\nChoices:\na) Code structure\nb) GC strategy and parameters\nc) User interface design\nd) Database schema\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Escape analysis determines whether objects can be allocated on stack instead of heap.",
    "target_text": "Question: Escape analysis determines whether objects can be allocated on:\nChoices:\na) Heap only\nb) Stack instead of heap\nc) Registers only\nd) External storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Scalar replacement converts object allocations into separate allocations of object fields.",
    "target_text": "Question: Scalar replacement converts object allocations into:\nChoices:\na) Larger objects\nb) Separate field allocations\nc) Array allocations\nd) Static allocations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: TLAB (Thread Local Allocation Buffer) reduces synchronization overhead in multi-threaded allocation.",
    "target_text": "Question: TLAB reduces:\nChoices:\na) Memory usage\nb) Synchronization overhead\nc) Code complexity\nd) Processing time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Bump pointer allocation provides fast sequential allocation in contiguous memory regions.",
    "target_text": "Question: Bump pointer allocation provides fast allocation in:\nChoices:\na) Random memory locations\nb) Contiguous memory regions\nc) External storage\nd) Network buffers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Large object heap handles objects that exceed normal generation size limits separately.",
    "target_text": "Question: Large object heap handles objects that:\nChoices:\na) Are frequently accessed\nb) Exceed normal size limits\nc) Are rarely used\nd) Have special types\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Pinned objects cannot be moved by garbage collector, affecting compaction strategies.",
    "target_text": "Question: Pinned objects cannot be:\nChoices:\na) Accessed\nb) Moved by garbage collector\nc) Modified\nd) Reference counted\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap compaction reduces fragmentation by moving objects to create contiguous free space.",
    "target_text": "Question: Heap compaction reduces fragmentation by:\nChoices:\na) Deleting objects\nb) Moving objects to create contiguous space\nc) Splitting objects\nd) Merging objects\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Mark-compact collection combines marking phase with compaction to eliminate fragmentation.",
    "target_text": "Question: Mark-compact collection combines marking with:\nChoices:\na) Copying\nb) Compaction to eliminate fragmentation\nc) Deletion\nd) Reference counting\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Copying collection moves live objects to new space, automatically achieving compaction.",
    "target_text": "Question: Copying collection achieves compaction by:\nChoices:\na) Deleting dead objects\nb) Moving live objects to new space\nc) Reorganizing pointers\nd) Merging free spaces\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Semi-space collection divides heap into two equal spaces, using one for allocation and other for copying.",
    "target_text": "Question: Semi-space collection divides heap into:\nChoices:\na) Three equal spaces\nb) Two equal spaces\nc) Variable-sized spaces\nd) Single continuous space\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap snapshots capture memory state at specific points for debugging and analysis purposes.",
    "target_text": "Question: Heap snapshots capture:\nChoices:\na) Code execution flow\nb) Memory state at specific points\nc) Network traffic\nd) User interactions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Memory dominators in heap analysis identify objects that prevent garbage collection of other objects.",
    "target_text": "Question: Memory dominators identify objects that:\nChoices:\na) Use most memory\nb) Prevent GC of other objects\nc) Are accessed frequently\nd) Are created first\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Retained size includes object size plus all objects only reachable through that object.",
    "target_text": "Question: Retained size includes object size plus:\nChoices:\na) All objects in heap\nb) Objects only reachable through that object\nc) Objects of same type\nd) Recently created objects\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Shallow size measures only the memory occupied by object itself, excluding referenced objects.",
    "target_text": "Question: Shallow size measures memory of:\nChoices:\na) Object and all references\nb) Object itself only\nc) Referenced objects only\nd) All objects of same type\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Educational heap implementations help students understand memory management and algorithm design principles.",
    "target_text": "Question: Educational heap implementations help understand:\nChoices:\na) Only syntax rules\nb) Memory management and algorithm design\nc) Only performance metrics\nd) Only debugging techniques\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap visualization tools provide graphical representation of heap structure and operations for learning.",
    "target_text": "Question: Heap visualization tools provide:\nChoices:\na) Code generation\nb) Graphical representation for learning\nc) Performance optimization\nd) Automated testing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Interactive heap simulators allow step-by-step execution to understand algorithm behavior and complexity.",
    "target_text": "Question: Interactive heap simulators allow:\nChoices:\na) Automatic code generation\nb) Step-by-step execution understanding\nc) Remote debugging\nd) Code compilation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Heap algorithm animation demonstrates dynamic behavior and helps visualize complex operations.",
    "target_text": "Question: Heap algorithm animation demonstrates:\nChoices:\na) Static structure only\nb) Dynamic behavior and complex operations\nc) Code syntax only\nd) Error conditions only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Heap | Context: Understanding heap principles provides essential foundation for advanced data structures and systems programming.",
    "target_text": "Question: Heap principles provide foundation for:\nChoices:\na) Basic programming only\nb) Advanced data structures and systems programming\nc) Web development only\nd) Database design only\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash tables in real-world applications must handle various practical considerations beyond basic algorithmic performance. These include memory alignment for optimal processor cache utilization, handling of different data types and their serialization for hashing, thread safety in concurrent environments, and persistence mechanisms for data that must survive system restarts. Additionally, production hash tables often implement features like automatic resizing policies, memory pool allocation, and performance monitoring capabilities.",
    "target_text": "Question: What practical implementation considerations must real-world hash table systems address beyond basic algorithmic functionality, and how do these concerns affect the design decisions for production-quality hash table implementations?\nChoices:\na) Real-world hash tables must address user interface design and human-computer interaction concerns, affecting design decisions through accessibility requirements and user experience optimization for better system adoption\nb) Real-world implementations must handle memory alignment, data serialization, thread safety, and persistence, affecting design through performance optimization and reliability requirements for production environments\nc) Real-world hash tables must address legal compliance and regulatory requirements for data handling, affecting design decisions through audit logging and privacy protection mechanisms for enterprise deployment\nd) Real-world implementations must handle network communication and distributed computing protocols, affecting design through bandwidth optimization and latency reduction for cloud-based applications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Adaptive hashing techniques dynamically adjust their behavior based on observed data patterns and performance characteristics. These systems can modify hash functions, adjust table sizes, change collision resolution strategies, or even switch between different hashing algorithms based on runtime analysis of key distributions, collision rates, and access patterns. This adaptability allows hash tables to maintain optimal performance across diverse and changing workloads.",
    "target_text": "Question: How do adaptive hashing systems modify their behavior in response to changing conditions, and what types of runtime analysis enable these systems to maintain optimal performance across diverse workloads?\nChoices:\na) Adaptive hashing systems modify behavior through user preference learning and interface customization, using analysis of user interaction patterns and feedback to optimize presentation and accessibility features\nb) Adaptive hashing systems adjust hash functions, table sizes, and collision strategies based on runtime analysis of key distributions, collision rates, and access patterns for optimal performance\nc) Adaptive hashing systems modify behavior through security threat detection and response protocols, using analysis of access attempts and authentication patterns to enhance protection mechanisms\nd) Adaptive hashing systems adjust through hardware resource monitoring and system optimization, using analysis of CPU utilization and memory availability to balance computational and storage requirements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Cryptographic hash functions must satisfy several stringent security requirements that go far beyond the needs of typical hash table applications. These include preimage resistance (given a hash value, it should be computationally infeasible to find an input that produces that hash), second preimage resistance (given an input and its hash, finding a different input with the same hash should be infeasible), and collision resistance (finding any two different inputs that produce the same hash should be computationally infeasible). The security of many systems depends on these properties.",
    "target_text": "Question: What are the three fundamental security properties that cryptographic hash functions must satisfy, and how do these requirements differ from the design goals of hash functions used in general-purpose hash tables?\nChoices:\na) Cryptographic hash functions must provide data compression, error correction, and network optimization capabilities, differing from hash tables by focusing on communication efficiency rather than storage organization\nb) Cryptographic hash functions require preimage resistance, second preimage resistance, and collision resistance, differing from hash tables by prioritizing security over speed and distribution uniformity\nc) Cryptographic hash functions must ensure data synchronization, version control, and backup verification features, differing from hash tables by emphasizing data integrity rather than access performance\nd) Cryptographic hash functions require mathematical precision, numerical stability, and floating-point accuracy, differing from hash tables by focusing on computational correctness rather than algorithmic efficiency\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based data structures are extensively used in modern database management systems for various purposes including B+ tree index acceleration, query plan optimization, join operations, and duplicate elimination. Hash joins are particularly important for equi-join operations where the smaller relation is hashed into memory, and the larger relation is probed against this hash table. The effectiveness of these operations depends heavily on the selectivity of join conditions and the available memory for hash table construction.",
    "target_text": "Question: How are hash-based techniques integrated into database management systems for query processing, and what factors determine the effectiveness of hash joins in relational database operations?\nChoices:\na) Hash-based techniques are integrated through data visualization and reporting interfaces, with effectiveness determined by user interface design and presentation quality for improved data accessibility\nb) Hash-based techniques support index acceleration, query optimization, and join operations, with hash join effectiveness determined by join selectivity and available memory for hash table construction\nc) Hash-based techniques are integrated through backup and recovery mechanisms, with effectiveness determined by storage reliability and disaster recovery capabilities for data protection requirements\nd) Hash-based techniques support user authentication and access control systems, with effectiveness determined by security policy complexity and authorization hierarchy management for enterprise environments\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Machine learning and artificial intelligence applications leverage hash-based techniques for feature hashing (also known as the hashing trick), locality-sensitive hashing for approximate nearest neighbor search, and hash-based dimensionality reduction. Feature hashing allows machine learning algorithms to work with extremely high-dimensional sparse feature spaces by mapping features to a lower-dimensional hash space, trading some accuracy for significant computational and memory efficiency gains.",
    "target_text": "Question: How do machine learning applications utilize hash-based techniques like feature hashing and locality-sensitive hashing, and what trade-offs do these methods involve for handling high-dimensional data in AI systems?\nChoices:\na) Machine learning uses hash-based techniques for data preprocessing and cleaning operations, involving trade-offs between data quality and processing speed for improved dataset preparation and validation\nb) Machine learning employs feature hashing for dimensionality reduction and LSH for similarity search, involving trade-offs between accuracy and computational efficiency for high-dimensional data processing\nc) Machine learning utilizes hash-based techniques for model serialization and deployment optimization, involving trade-offs between model complexity and inference speed for production system performance\nd) Machine learning applies hash-based techniques for distributed training and parallel computation, involving trade-offs between communication overhead and computational parallelism for scalable learning systems\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Content-addressable storage systems use hash values as unique identifiers for data blocks, enabling deduplication, integrity verification, and distributed storage optimization. In these systems, identical content always produces the same hash value regardless of where or when it's stored, allowing multiple references to point to the same physical storage location. This approach is fundamental to technologies like Git version control, blockchain storage, and cloud storage deduplication services.",
    "target_text": "Question: How do content-addressable storage systems utilize hash values for data organization and what advantages does this approach provide for deduplication and distributed storage applications?\nChoices:\na) Content-addressable storage uses hash values for data encryption and security protocols, providing advantages through enhanced protection and access control for sensitive information management in secure environments\nb) Content-addressable storage employs hash values as unique data identifiers, enabling deduplication, integrity verification, and distributed storage optimization through content-based addressing\nc) Content-addressable storage utilizes hash values for performance monitoring and system optimization, providing advantages through resource utilization tracking and bottleneck identification for efficient system management\nd) Content-addressable storage applies hash values for user interface customization and personalization features, providing advantages through adaptive presentation and improved user experience in interactive applications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Network routing protocols and load balancers extensively use hash-based algorithms for traffic distribution and path selection. Consistent hashing ensures that network traffic is distributed evenly across available servers while minimizing disruption when servers are added or removed. Equal-cost multi-path (ECMP) routing uses hash functions to deterministically select among multiple equal-cost paths, ensuring that packets from the same flow follow the same path to maintain proper TCP sequence ordering.",
    "target_text": "Question: How do network systems employ hash-based algorithms for traffic distribution and routing decisions, and why is deterministic path selection important for maintaining proper network protocol behavior?\nChoices:\na) Network systems use hash-based algorithms for network security and intrusion detection, with deterministic selection important for maintaining consistent security policies and threat response protocols\nb) Network systems employ hash functions for traffic distribution and ECMP routing, with deterministic path selection crucial for maintaining TCP sequence ordering and proper protocol behavior\nc) Network systems utilize hash-based algorithms for bandwidth allocation and quality of service management, with deterministic selection important for maintaining service level agreements and performance guarantees\nd) Network systems apply hash-based algorithms for network monitoring and performance analysis, with deterministic selection important for maintaining accurate measurement and statistical data collection\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Modern web browsers implement sophisticated hash-based caching mechanisms to improve page loading performance and reduce bandwidth usage. These systems use content hashing to determine cache validity, implement cache partitioning based on origin policies, and utilize hash-based cache keys that incorporate multiple factors including URL, headers, and security context. The effectiveness of web caching directly impacts user experience and server load reduction.",
    "target_text": "Question: How do web browsers implement hash-based caching mechanisms to optimize performance, and what factors are incorporated into hash-based cache keys to ensure proper cache behavior and security?\nChoices:\na) Web browsers implement hash-based caching through user preference tracking and personalization algorithms, incorporating factors like browsing history and user behavior patterns for customized content delivery\nb) Web browsers use content hashing for cache validity and hash-based keys incorporating URL, headers, and security context for proper cache behavior and performance optimization\nc) Web browsers implement hash-based caching through network topology analysis and connection optimization, incorporating factors like latency measurements and bandwidth availability for improved connectivity\nd) Web browsers utilize hash-based caching through advertising and content recommendation systems, incorporating factors like user demographics and commercial preferences for targeted content presentation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based authentication systems, including password hashing with salt, challenge-response protocols, and time-based one-time passwords (TOTP), form the backbone of modern security infrastructure. Password hashing systems use computationally expensive hash functions like bcrypt, scrypt, or Argon2 with random salts to resist brute-force attacks and rainbow table attacks. The computational cost is deliberately high to slow down attackers while remaining manageable for legitimate authentication.",
    "target_text": "Question: How do modern authentication systems employ hash-based techniques for password security, and why do these systems deliberately use computationally expensive hash functions with random salts?\nChoices:\na) Authentication systems use hash-based techniques for user interface security and session management, with expensive functions providing enhanced user experience and simplified login procedures for improved usability\nb) Authentication systems employ expensive hash functions with salts for password protection, deliberately slowing computation to resist brute-force and rainbow table attacks while remaining usable for legitimate users\nc) Authentication systems utilize hash-based techniques for data backup and recovery operations, with expensive functions providing enhanced reliability and disaster recovery capabilities for business continuity requirements\nd) Authentication systems apply hash-based techniques for network communication and protocol security, with expensive functions providing enhanced encryption and secure transmission for distributed authentication services\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Big data processing frameworks like Apache Spark and Hadoop extensively use hash-based techniques for data partitioning, shuffle operations, and distributed computing optimization. Hash partitioning ensures that related data items are processed on the same nodes, reducing network communication overhead during operations like joins and aggregations. The choice of hash function and partitioning strategy significantly impacts the performance and scalability of distributed data processing workflows.",
    "target_text": "Question: How do big data processing frameworks utilize hash-based partitioning for distributed computing, and what impact does the choice of hash function and partitioning strategy have on system performance and scalability?\nChoices:\na) Big data frameworks use hash-based partitioning for user access control and permission management, with hash function choice impacting security policy enforcement and authorization hierarchy complexity\nb) Big data frameworks employ hash partitioning to ensure related data processing on same nodes, with hash function choice significantly impacting performance and scalability of distributed workflows\nc) Big data frameworks utilize hash-based partitioning for data visualization and reporting interfaces, with hash function choice impacting presentation quality and interactive dashboard responsiveness\nd) Big data frameworks apply hash-based partitioning for backup and disaster recovery operations, with hash function choice impacting data protection reliability and system recovery time objectives\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Quantum computing poses both challenges and opportunities for hash-based systems. Quantum algorithms like Grover's algorithm can potentially reduce the effective security of cryptographic hash functions by providing quadratic speedup for brute-force attacks. However, quantum systems also enable new forms of quantum hashing and quantum-resistant hash functions that could provide enhanced security. The transition to post-quantum cryptography requires careful consideration of hash function vulnerabilities.",
    "target_text": "Question: What impact does quantum computing have on traditional hash-based security systems, and how are researchers addressing the challenges posed by quantum algorithms to cryptographic hash functions?\nChoices:\na) Quantum computing impacts hash-based systems through improved processing speed and computational efficiency, with researchers addressing challenges by developing faster classical algorithms and optimized hardware implementations\nb) Quantum computing threatens hash security through algorithms like Grover's providing attack speedup, with researchers developing quantum-resistant hash functions and post-quantum cryptographic solutions\nc) Quantum computing impacts hash-based systems through enhanced data storage and memory capabilities, with researchers addressing challenges by developing larger hash tables and improved collision resolution techniques\nd) Quantum computing affects hash-based systems through network communication and distributed processing improvements, with researchers addressing challenges by developing better distributed hash algorithms and communication protocols\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Memory-mapped hash tables provide a mechanism for persistent hash storage that can survive system restarts and be shared between processes. These implementations must handle issues like memory alignment, endianness for cross-platform compatibility, concurrent access from multiple processes, and recovery from incomplete operations due to system crashes. The design requires careful consideration of both performance and reliability requirements.",
    "target_text": "Question: What technical challenges must memory-mapped hash table implementations address to provide persistent storage and cross-process sharing, and how do these requirements affect the design complexity compared to in-memory hash tables?\nChoices:\na) Memory-mapped hash tables must address user interface consistency and cross-platform presentation issues, affecting design complexity through standardized display protocols and adaptive rendering requirements\nb) Memory-mapped implementations must handle memory alignment, endianness, concurrent access, and crash recovery, significantly increasing design complexity compared to simple in-memory tables\nc) Memory-mapped hash tables must address network security and distributed authentication challenges, affecting design complexity through encryption protocols and secure communication requirements\nd) Memory-mapped implementations must handle data compression and storage optimization issues, affecting design complexity through algorithmic efficiency and resource utilization management\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based data structures play crucial roles in compiler design and programming language implementation. Symbol tables use hash tables for efficient identifier lookup during compilation, string interning systems use hashing to ensure unique string instances, and runtime type systems often employ hash-based method dispatch. The performance of these fundamental operations directly impacts compilation speed and program execution efficiency.",
    "target_text": "Question: How are hash-based data structures integrated into compiler design and programming language implementation, and why is their performance critical for both compilation and runtime efficiency?\nChoices:\na) Hash-based structures support compiler optimization through code analysis and performance profiling, with performance critical for identifying bottlenecks and improving generated code quality\nb) Hash structures enable symbol tables, string interning, and method dispatch in compilers, with performance directly impacting compilation speed and program execution efficiency\nc) Hash-based structures provide compiler debugging and error reporting capabilities, with performance critical for identifying syntax errors and providing meaningful diagnostic information\nd) Hash structures support compiler documentation and code generation features, with performance critical for producing readable output and maintaining development workflow efficiency\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based algorithms are fundamental to modern search engines and information retrieval systems. They enable efficient duplicate detection during web crawling, support inverted index construction for text search, implement query caching for performance optimization, and provide content fingerprinting for copyright detection. The scale of these operations requires highly optimized hash implementations that can handle billions of documents and queries efficiently.",
    "target_text": "Question: What roles do hash-based algorithms play in search engine and information retrieval systems, and what scalability requirements do these applications place on hash implementation design?\nChoices:\na) Hash-based algorithms support search engine advertising and revenue optimization systems, placing scalability requirements on commercial transaction processing and financial data management capabilities\nb) Hash algorithms enable duplicate detection, inverted indexing, query caching, and content fingerprinting, requiring implementations that can efficiently handle billions of documents and queries\nc) Hash-based algorithms provide search engine user interface and personalization features, placing scalability requirements on interactive response times and customized content delivery systems\nd) Hash algorithms support search engine security and privacy protection mechanisms, requiring implementations that can handle authentication and access control for large-scale user management\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Edge computing and Internet of Things (IoT) applications present unique constraints for hash-based systems, including limited computational resources, restricted memory availability, intermittent network connectivity, and power consumption concerns. Hash implementations for these environments must balance functionality with resource efficiency, often requiring specialized algorithms and data structures optimized for embedded systems and mobile devices.",
    "target_text": "Question: What specific constraints do edge computing and IoT environments place on hash-based system design, and how do these limitations require modifications to traditional hash algorithms and implementations?\nChoices:\na) Edge computing and IoT environments constrain hash systems through regulatory compliance and legal requirements, requiring modifications for data protection and privacy preservation in distributed sensor networks\nb) Edge and IoT environments impose constraints of limited computation, memory, connectivity, and power, requiring hash implementations optimized for resource efficiency and embedded system capabilities\nc) Edge computing and IoT environments constrain hash systems through user interface and accessibility requirements, requiring modifications for simplified interaction and reduced complexity in remote device management\nd) Edge and IoT environments impose constraints through manufacturing and deployment costs, requiring hash implementations optimized for economic efficiency and reduced hardware component requirements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Social media platforms and content recommendation systems rely heavily on hash-based techniques for user profiling, content similarity detection, collaborative filtering, and real-time personalization. These systems must process enormous volumes of user interactions, content updates, and social connections while providing instantaneous responses. Hash-based similarity measures and clustering algorithms enable efficient content matching and recommendation generation at massive scale.",
    "target_text": "Question: How do social media platforms leverage hash-based techniques for content recommendation and user profiling, and what performance challenges must these systems overcome to provide real-time personalization at massive scale?\nChoices:\na) Social media platforms use hash-based techniques for content moderation and safety enforcement, overcoming challenges through automated detection and response systems for harmful content management\nb) Social platforms employ hash techniques for user profiling, similarity detection, and collaborative filtering, overcoming performance challenges of processing enormous interaction volumes for real-time personalization\nc) Social media platforms utilize hash-based techniques for advertising and revenue optimization, overcoming challenges through targeted marketing and commercial transaction processing for business model sustainability\nd) Social platforms apply hash-based techniques for legal compliance and regulatory reporting, overcoming challenges through audit logging and data governance for enterprise accountability requirements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Financial technology (fintech) applications utilize hash-based systems for transaction processing, fraud detection, regulatory compliance, and blockchain implementations. High-frequency trading systems require ultra-low latency hash operations for order matching and risk management. Cryptocurrency systems depend on cryptographic hash functions for mining, transaction verification, and blockchain integrity. The reliability and performance of these systems directly impact financial markets and economic stability.",
    "target_text": "Question: What critical roles do hash-based systems play in financial technology applications, and why are performance and reliability requirements particularly stringent in these financial market contexts?\nChoices:\na) Hash-based systems in fintech provide customer service and user experience optimization, with stringent requirements due to competitive market pressures and customer satisfaction concerns in financial services\nb) Hash systems enable transaction processing, fraud detection, trading, and blockchain operations in fintech, with stringent requirements due to direct impact on financial markets and economic stability\nc) Hash-based systems in fintech support marketing and customer acquisition activities, with stringent requirements due to regulatory advertising standards and consumer protection regulations in financial industries\nd) Hash systems provide fintech data analytics and business intelligence capabilities, with stringent requirements due to strategic decision-making dependencies and competitive advantage considerations in financial markets\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Healthcare and medical informatics systems employ hash-based techniques for patient record management, medical image analysis, drug discovery, and genomic data processing. Privacy-preserving hash functions enable secure medical data sharing while maintaining patient confidentiality. Large-scale genomic analyses require specialized hash algorithms optimized for DNA sequence processing and pattern matching across massive biological databases.",
    "target_text": "Question: How are hash-based techniques applied in healthcare and medical informatics, and what special requirements do medical applications place on hash algorithm design for privacy and biological data processing?\nChoices:\na) Hash-based techniques in healthcare support hospital administration and resource management systems, with special requirements for operational efficiency and cost optimization in medical facility management\nb) Hash techniques enable patient records, medical imaging, drug discovery, and genomics in healthcare, with special requirements for privacy preservation and biological data processing optimization\nc) Hash-based techniques in healthcare provide medical equipment monitoring and maintenance systems, with special requirements for device reliability and preventive maintenance in clinical environments\nd) Hash techniques support healthcare billing and insurance processing systems, with special requirements for financial accuracy and regulatory compliance in medical administrative operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Game development and interactive entertainment applications utilize hash-based systems for asset management, player state synchronization, anti-cheat mechanisms, and procedural content generation. Multiplayer games require consistent hash-based world state representation across different clients and servers. Performance-critical game engines must implement highly optimized hash operations that operate within strict frame time budgets while maintaining deterministic behavior across platforms.",
    "target_text": "Question: What applications do hash-based systems have in game development and interactive entertainment, and what performance constraints do real-time gaming applications place on hash algorithm implementation?\nChoices:\na) Hash-based systems in games support marketing and monetization strategies, with performance constraints related to payment processing and commercial transaction efficiency for business model optimization\nb) Hash systems enable asset management, state synchronization, anti-cheat, and content generation in games, with constraints requiring optimized operations within strict frame time budgets\nc) Hash-based systems in games provide social networking and community features, with performance constraints related to user communication and social interaction responsiveness for player engagement\nd) Hash systems support game analytics and player behavior tracking, with performance constraints related to data collection and analysis efficiency for game design optimization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Environmental monitoring and scientific computing applications leverage hash-based techniques for sensor data aggregation, climate modeling, and large-scale simulation analysis. These systems must process continuous streams of environmental measurements while detecting patterns, anomalies, and trends across vast temporal and spatial scales. Hash-based indexing and similarity detection enable efficient analysis of historical data and real-time monitoring capabilities.",
    "target_text": "Question: How do environmental monitoring and scientific computing systems utilize hash-based techniques, and what data processing challenges do these applications face when analyzing environmental measurements across large temporal and spatial scales?\nChoices:\na) Environmental systems use hash-based techniques for regulatory reporting and compliance documentation, facing challenges related to legal requirements and administrative overhead in government environmental agencies\nb) Environmental systems employ hash techniques for sensor aggregation, climate modeling, and simulation analysis, facing challenges of processing continuous measurement streams across vast temporal and spatial scales\nc) Environmental systems utilize hash-based techniques for public communication and education outreach, facing challenges related to scientific literacy and public engagement in environmental awareness campaigns\nd) Environmental systems apply hash-based techniques for funding and resource allocation management, facing challenges related to budget constraints and research prioritization in scientific project management\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Autonomous vehicle systems and robotics applications employ hash-based algorithms for sensor fusion, path planning, object recognition, and real-time decision making. These systems must process enormous amounts of sensor data from cameras, lidar, radar, and other sources while maintaining strict timing requirements for safety-critical operations. Hash-based spatial indexing and pattern matching enable efficient processing of environmental data for navigation and obstacle avoidance.",
    "target_text": "Question: What roles do hash-based algorithms play in autonomous vehicle and robotics systems, and how do safety-critical timing requirements influence the design of hash implementations for these applications?\nChoices:\na) Hash-based algorithms in autonomous systems support vehicle manufacturing and assembly line optimization, with timing requirements influencing design through production efficiency and quality control considerations\nb) Hash algorithms enable sensor fusion, path planning, object recognition, and decision making in autonomous systems, with safety-critical timing requirements demanding efficient real-time processing capabilities\nc) Hash-based algorithms in autonomous systems provide entertainment and user interface features, with timing requirements influencing design through user experience and passenger comfort optimization\nd) Hash algorithms support autonomous vehicle maintenance and diagnostic systems, with timing requirements influencing design through preventive maintenance and reliability monitoring considerations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Cloud computing platforms implement sophisticated hash-based resource management, load balancing, and data distribution systems that must scale across thousands of servers and handle millions of concurrent users. These systems use consistent hashing for data placement, hash-based sharding for database scaling, and hash algorithms for request routing and load distribution. The challenge lies in maintaining performance and consistency across highly distributed and dynamic infrastructure.",
    "target_text": "Question: How do cloud computing platforms employ hash-based techniques for resource management and scaling, and what challenges arise when implementing these systems across highly distributed and dynamic infrastructure?\nChoices:\na) Cloud platforms use hash-based techniques for billing and cost management systems, with challenges arising from pricing complexity and resource accounting accuracy in multi-tenant environments\nb) Cloud platforms employ hash techniques for resource management, load balancing, and data distribution, with challenges of maintaining performance and consistency across distributed dynamic infrastructure\nc) Cloud platforms utilize hash-based techniques for security and access control management, with challenges arising from authentication complexity and authorization hierarchy administration in enterprise environments\nd) Cloud platforms apply hash-based techniques for user interface and customer experience optimization, with challenges arising from interface consistency and personalization across diverse client platforms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Modern operating systems extensively use hash-based techniques for virtual memory management, file system indexing, process scheduling, and system resource allocation. Page table implementations often use hash structures for efficient virtual-to-physical address translation. File systems employ hash-based directory indexing for fast file lookup operations. The kernel-level implementation of these systems requires careful optimization for both space and time efficiency in constrained system environments.",
    "target_text": "Question: What fundamental roles do hash-based techniques play in modern operating system design, and what optimization requirements do kernel-level implementations place on hash algorithm design for system-critical operations?\nChoices:\na) Hash-based techniques in operating systems support user application development and software deployment, with optimization requirements focused on development tool efficiency and application performance enhancement\nb) Hash techniques enable virtual memory, file systems, process scheduling, and resource allocation in OS, with kernel-level requirements demanding careful space and time optimization for system efficiency\nc) Hash-based techniques in operating systems provide system monitoring and performance analysis capabilities, with optimization requirements focused on diagnostic accuracy and administrative tool responsiveness\nd) Hash techniques support operating system security and malware protection systems, with optimization requirements focused on threat detection speed and security policy enforcement efficiency\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Educational technology platforms and learning management systems utilize hash-based algorithms for content organization, student progress tracking, adaptive learning personalization, and plagiarism detection. These systems must efficiently match learning content to individual student needs while maintaining privacy and security of educational records. Hash-based similarity detection enables automated assessment and content recommendation across large educational databases.",
    "target_text": "Question: How do educational technology platforms leverage hash-based algorithms for learning optimization, and what privacy and security considerations must these systems address when processing student data and educational content?\nChoices:\na) Educational platforms use hash-based algorithms for financial management and tuition processing, with considerations addressing payment security and billing accuracy in educational administrative systems\nb) Educational platforms employ hash algorithms for content organization, progress tracking, personalization, and plagiarism detection, with considerations addressing privacy and security of educational records\nc) Educational platforms utilize hash-based algorithms for campus facility management and resource scheduling, with considerations addressing operational efficiency and space utilization in educational institutions\nd) Educational platforms apply hash-based algorithms for marketing and student recruitment activities, with considerations addressing communication effectiveness and enrollment optimization in competitive educational markets\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based string matching algorithms, particularly the Rabin-Karp algorithm, demonstrate how rolling hash functions can be applied to pattern searching problems. The algorithm computes a hash value for the pattern and then uses a rolling hash to compute hash values for all substrings of the text of the same length. When hash values match, a character-by-character comparison is performed to confirm the match. The efficiency of this approach depends heavily on the quality of the hash function and its ability to minimize false positive matches.",
    "target_text": "Question: How does the Rabin-Karp string matching algorithm utilize rolling hash functions to achieve efficient pattern searching, and what role does hash function quality play in minimizing false positive matches during the search process?\nChoices:\na) Rabin-Karp uses rolling hash for pattern compression and text preprocessing, with hash quality affecting compression ratios and storage efficiency for large text databases and document management systems\nb) Rabin-Karp computes pattern hash and rolling text hashes for comparison, with hash function quality crucial for minimizing false positives that require expensive character-by-character verification\nc) Rabin-Karp utilizes rolling hash for parallel pattern matching across multiple processors, with hash quality affecting load balancing and synchronization overhead in distributed text processing systems\nd) Rabin-Karp employs rolling hash for statistical analysis and pattern frequency counting, with hash quality affecting accuracy of frequency estimates and pattern distribution analysis in text mining applications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Locality-sensitive hashing (LSH) families are mathematical constructions that enable approximate similarity search in high-dimensional spaces with theoretical guarantees on performance. Different LSH families are designed for different distance metrics, such as cosine similarity, Jaccard similarity, and Euclidean distance. The parameters of an LSH family control the trade-off between search accuracy and computational efficiency, making them invaluable for applications like recommendation systems, image retrieval, and near-duplicate detection in massive datasets.",
    "target_text": "Question: What mathematical properties define locality-sensitive hashing families for different distance metrics, and how do LSH parameters control the fundamental trade-off between search accuracy and computational efficiency in high-dimensional similarity search applications?\nChoices:\na) LSH families define mathematical properties through statistical sampling and random projection techniques, with parameters controlling trade-offs between memory usage and processing speed for database optimization applications\nb) LSH families are constructed for specific distance metrics like cosine and Jaccard similarity, with parameters controlling trade-offs between search accuracy and computational efficiency for high-dimensional similarity search\nc) LSH families define mathematical properties through encryption and security protocols, with parameters controlling trade-offs between data protection and access performance for secure similarity search applications\nd) LSH families utilize mathematical properties through machine learning and adaptive algorithms, with parameters controlling trade-offs between learning accuracy and training time for intelligent similarity search systems\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based load balancing in distributed systems requires careful consideration of several factors including request characteristics, server capabilities, session affinity requirements, and failover mechanisms. Consistent hashing with virtual nodes helps ensure even load distribution even when servers have different capacities or when servers are added or removed from the system. The challenge lies in maintaining both load balance and minimizing the disruption caused by topology changes in dynamic distributed environments.",
    "target_text": "Question: What factors must be considered when implementing hash-based load balancing in distributed systems, and how does consistent hashing with virtual nodes address the challenges of maintaining load balance during dynamic topology changes?\nChoices:\na) Hash-based load balancing must consider network latency and bandwidth optimization factors, with consistent hashing addressing challenges through geographic distribution and content delivery network integration for global system performance\nb) Hash-based load balancing considers request characteristics, server capabilities, and session affinity, with consistent hashing and virtual nodes ensuring even distribution while minimizing disruption during topology changes\nc) Hash-based load balancing must consider security protocols and access control factors, with consistent hashing addressing challenges through authentication distribution and authorization management for secure distributed access\nd) Hash-based load balancing considers user interface and experience factors, with consistent hashing addressing challenges through presentation consistency and personalization maintenance across distributed service endpoints\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Multi-level hash tables, such as those used in extendible hashing and dynamic perfect hashing, provide mechanisms for handling extremely large datasets that exceed the capacity of traditional hash tables. These structures typically employ a hierarchy of hash functions and directory structures that can grow incrementally as data is added. The design must balance the overhead of maintaining multiple levels against the benefits of reduced collision rates and improved scalability for very large key sets.",
    "target_text": "Question: How do multi-level hash table structures like extendible hashing handle extremely large datasets through hierarchical organization, and what design trade-offs must be balanced between structural overhead and collision reduction benefits?\nChoices:\na) Multi-level hash tables handle large datasets through data compression and encoding hierarchies, with trade-offs balanced between compression overhead and storage efficiency for space-constrained applications\nb) Multi-level structures use hierarchical hash functions and directory systems that grow incrementally, balancing maintenance overhead against reduced collisions and improved scalability for large key sets\nc) Multi-level hash tables handle large datasets through parallel processing and distributed computation hierarchies, with trade-offs balanced between coordination overhead and computational parallelism for performance optimization\nd) Multi-level structures utilize hierarchical caching and memory management systems, balancing cache overhead against access speed improvements for memory-intensive applications with large working sets\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based duplicate detection algorithms are essential for data cleaning, web crawling, and content management systems. These algorithms must efficiently identify near-duplicates and exact duplicates across massive datasets while handling variations in formatting, encoding, and minor content modifications. Techniques like simhashing for near-duplicate detection and cryptographic hashing for exact duplicate identification each serve different purposes and have distinct computational and storage requirements.",
    "target_text": "Question: How do hash-based duplicate detection algorithms differentiate between exact and near-duplicate identification requirements, and what are the distinct computational and storage trade-offs between techniques like simhashing and cryptographic hashing for different duplicate detection scenarios?\nChoices:\na) Hash-based duplicate detection algorithms differentiate through user preference analysis and customization requirements, with trade-offs between personalization complexity and user experience optimization for content recommendation systems\nb) Hash-based algorithms use simhashing for near-duplicate detection and cryptographic hashing for exact duplicates, with distinct trade-offs in computational requirements and storage needs for different detection scenarios\nc) Hash-based duplicate detection algorithms differentiate through network protocol analysis and communication requirements, with trade-offs between transmission overhead and synchronization accuracy for distributed content management systems\nd) Hash-based algorithms utilize temporal analysis and versioning requirements, with trade-offs between historical tracking complexity and real-time processing performance for content evolution management systems\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Secure multi-party computation protocols often rely on hash-based commitment schemes and zero-knowledge proofs that enable parties to prove knowledge of information without revealing the information itself. These cryptographic applications require hash functions with specific security properties including computational binding, perfect hiding, and resistance to various cryptographic attacks. The security of entire blockchain and cryptocurrency systems often depends on the strength of these hash-based cryptographic primitives.",
    "target_text": "Question: What role do hash-based commitment schemes play in secure multi-party computation protocols, and what specific cryptographic security properties must hash functions possess to ensure the integrity of blockchain and cryptocurrency systems?\nChoices:\na) Hash-based commitment schemes provide data compression and storage optimization in multi-party protocols, requiring hash functions with efficiency properties for computational performance and memory usage optimization in distributed systems\nb) Hash-based commitments enable zero-knowledge proofs and information hiding in secure protocols, requiring hash functions with computational binding, perfect hiding, and attack resistance for blockchain security\nc) Hash-based commitment schemes provide user authentication and access control in multi-party protocols, requiring hash functions with identity verification properties for user management and authorization in distributed applications\nd) Hash-based commitments enable network communication and protocol coordination in secure protocols, requiring hash functions with transmission reliability properties for message integrity and delivery confirmation in distributed networks\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based data structures in embedded systems and IoT devices face unique constraints including limited computational power, restricted memory availability, battery life considerations, and intermittent network connectivity. These constraints require specialized hash implementations that prioritize energy efficiency and fault tolerance while maintaining acceptable performance levels. The design must often sacrifice some functionality or performance to meet the stringent resource limitations of embedded environments.",
    "target_text": "Question: What unique constraints do embedded systems and IoT devices place on hash-based data structure implementations, and how do these limitations require design sacrifices in functionality or performance to meet stringent resource requirements?\nChoices:\na) Embedded systems constrain hash structures through manufacturing cost and component availability limitations, requiring design sacrifices in hardware complexity and feature richness to meet economic constraints and market competitiveness requirements\nb) Embedded systems face constraints of limited computation, memory, battery life, and connectivity, requiring hash implementations that sacrifice functionality or performance for energy efficiency and fault tolerance\nc) Embedded systems constrain hash structures through regulatory compliance and safety certification requirements, requiring design sacrifices in innovation and flexibility to meet industry standards and legal obligations\nd) Embedded systems impose constraints through user interface and accessibility limitations, requiring design sacrifices in feature complexity and interaction richness to meet usability requirements in constrained display environments\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based indexing in time-series databases enables efficient storage and retrieval of temporal data with complex query patterns including range queries, aggregation operations, and pattern matching across time windows. These systems often employ multi-dimensional hashing schemes that consider both temporal and value dimensions to optimize query performance. The challenge lies in balancing write performance for high-frequency data ingestion with read performance for complex analytical queries.",
    "target_text": "Question: How do time-series databases utilize hash-based indexing for temporal data management, and what challenges arise when balancing write performance for data ingestion with read performance for complex analytical queries in multi-dimensional hashing schemes?\nChoices:\na) Time-series databases utilize hash-based indexing for user interface optimization and visualization enhancement, with challenges arising from presentation complexity and interactive responsiveness for real-time dashboard applications\nb) Time-series databases employ multi-dimensional hashing for temporal and value dimensions, facing challenges of balancing high-frequency write performance with complex analytical query read performance\nc) Time-series databases use hash-based indexing for security and access control management, with challenges arising from authentication overhead and authorization complexity for multi-tenant temporal data systems\nd) Time-series databases utilize hash-based indexing for compression and storage optimization, with challenges arising from encoding complexity and decompression performance for space-efficient temporal data storage\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based stream processing systems must handle continuous data flows with varying arrival rates, out-of-order events, and time-based windowing requirements. These systems use hash-based partitioning for parallel processing, hash tables for state management, and hash functions for event routing and aggregation. The architecture must provide low-latency processing while maintaining consistency and fault tolerance across distributed processing nodes.",
    "target_text": "Question: How do hash-based stream processing systems manage continuous data flows with varying characteristics, and what architectural requirements must be met to provide low-latency processing while maintaining consistency and fault tolerance?\nChoices:\na) Hash-based stream processing systems manage data flows through user preference tracking and personalization algorithms, with architectural requirements focused on customization accuracy and individual user experience optimization\nb) Hash-based systems use partitioning for parallelism, hash tables for state management, and hash routing for aggregation, requiring architecture that provides low-latency processing with consistency and fault tolerance\nc) Hash-based stream processing systems manage data flows through security monitoring and threat detection protocols, with architectural requirements focused on intrusion prevention and security policy enforcement\nd) Hash-based systems utilize data flows through compression and bandwidth optimization techniques, with architectural requirements focused on transmission efficiency and network utilization optimization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Distributed consensus algorithms, such as those used in blockchain networks and distributed databases, often incorporate hash-based mechanisms for leader election, message ordering, and state synchronization. These algorithms must handle network partitions, Byzantine failures, and varying message delays while maintaining consistency across all participating nodes. Hash-based voting and commitment protocols provide the cryptographic foundations for achieving consensus in untrusted distributed environments.",
    "target_text": "Question: What roles do hash-based mechanisms play in distributed consensus algorithms for blockchain and distributed database systems, and how do these protocols achieve consistency in untrusted environments with network failures and Byzantine behavior?\nChoices:\na) Hash-based mechanisms in consensus algorithms provide user interface consistency and experience uniformity, achieving consistency through standardized presentation protocols and synchronized user interaction across distributed nodes\nb) Hash-based mechanisms enable leader election, message ordering, and state synchronization in consensus algorithms, achieving consistency through cryptographic voting and commitment protocols in untrusted environments\nc) Hash-based mechanisms in consensus algorithms provide cost optimization and resource allocation management, achieving consistency through economic incentive structures and resource sharing protocols across distributed nodes\nd) Hash-based mechanisms enable monitoring and performance analysis in consensus algorithms, achieving consistency through statistical analysis and performance measurement synchronization across distributed nodes\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based content delivery networks (CDNs) use sophisticated caching and routing algorithms to optimize content delivery across geographically distributed servers. These systems employ consistent hashing for content placement, hash-based cache invalidation for content updates, and geographic hash routing for optimal server selection. The effectiveness of these systems directly impacts web performance, user experience, and bandwidth costs for content providers.",
    "target_text": "Question: How do content delivery networks employ hash-based algorithms for content optimization across distributed servers, and what impact do these systems have on web performance, user experience, and operational costs for content providers?\nChoices:\na) CDNs employ hash-based algorithms for billing and revenue optimization across distributed infrastructure, impacting cost accounting accuracy and pricing model effectiveness for service provider business operations\nb) CDNs use consistent hashing for content placement, hash-based cache invalidation, and geographic routing, directly impacting web performance, user experience, and bandwidth costs for providers\nc) CDNs utilize hash-based algorithms for security and access control across distributed servers, impacting authentication reliability and authorization consistency for secure content delivery applications\nd) CDNs employ hash-based algorithms for analytics and usage tracking across distributed infrastructure, impacting data collection accuracy and performance analysis capabilities for service optimization\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based intrusion detection systems analyze network traffic patterns, system call sequences, and user behavior to identify potential security threats and anomalous activities. These systems create hash signatures of normal behavior patterns and use hash-based similarity measures to detect deviations that might indicate attacks or compromised systems. The challenge lies in minimizing false positives while maintaining high sensitivity to actual security threats.",
    "target_text": "Question: How do hash-based intrusion detection systems utilize pattern analysis and similarity measures to identify security threats, and what is the fundamental challenge of balancing false positive rates with threat detection sensitivity in these security systems?\nChoices:\na) Hash-based intrusion detection systems utilize pattern analysis for system performance optimization and resource utilization monitoring, with challenges of balancing computational overhead with monitoring accuracy for system efficiency\nb) Hash-based systems create signatures of normal patterns and use similarity measures to detect anomalous deviations, facing challenges of minimizing false positives while maintaining high sensitivity to actual threats\nc) Hash-based intrusion detection systems utilize pattern analysis for user experience optimization and interface customization, with challenges of balancing personalization accuracy with privacy protection for user-friendly security systems\nd) Hash-based systems employ pattern analysis for compliance monitoring and regulatory reporting, with challenges of balancing audit accuracy with administrative overhead for regulatory compliance requirements\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based algorithmic trading systems require ultra-high performance hash operations for order book management, price discovery, risk assessment, and regulatory compliance monitoring. These systems process millions of market events per second and must maintain microsecond-level latency requirements while ensuring complete accuracy and audit trails. The hash implementations must be optimized for specific hardware architectures and often employ custom FPGA or ASIC implementations for maximum performance.",
    "target_text": "Question: What performance requirements do algorithmic trading systems place on hash-based operations for financial market processing, and why do these systems often require custom hardware implementations to meet microsecond-level latency constraints?\nChoices:\na) Algorithmic trading systems require hash operations for customer service and user experience optimization, with custom hardware needed for interactive responsiveness and personalized trading interface performance enhancement\nb) Algorithmic trading systems need ultra-high performance hash operations for order management and risk assessment, requiring custom hardware to meet microsecond latency constraints for millions of events per second\nc) Algorithmic trading systems require hash operations for marketing and business development activities, with custom hardware needed for competitive analysis and market research processing performance optimization\nd) Algorithmic trading systems need hash operations for regulatory reporting and compliance documentation, with custom hardware required for audit trail generation and legal documentation processing performance\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based recommendation engines in e-commerce and entertainment platforms must process vast amounts of user interaction data, product catalogs, and preference signals to generate personalized recommendations in real-time. These systems employ collaborative filtering with hash-based similarity measures, content-based filtering with feature hashing, and hybrid approaches that combine multiple recommendation strategies. The scalability and accuracy of these systems directly impact user engagement and business revenue.",
    "target_text": "Question: How do hash-based recommendation engines process user data and product catalogs to generate personalized recommendations, and what is the relationship between recommendation system scalability, accuracy, and business impact in e-commerce platforms?\nChoices:\na) Hash-based recommendation engines process user data for legal compliance and privacy protection, with business impact related to regulatory adherence and data protection liability for enterprise risk management\nb) Hash-based engines use collaborative filtering, content-based filtering, and hybrid approaches with hash-based similarity measures, with scalability and accuracy directly impacting user engagement and revenue\nc) Hash-based recommendation engines process user data for system administration and infrastructure management, with business impact related to operational efficiency and technical maintenance costs for platform operations\nd) Hash-based engines utilize user data for security monitoring and fraud prevention, with business impact related to transaction safety and financial protection for secure commerce operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based genome analysis and bioinformatics applications must efficiently process and compare DNA sequences, protein structures, and genomic variations across massive biological databases. These systems use specialized hash functions optimized for biological sequences, k-mer hashing for sequence similarity detection, and hash-based indexing for rapid database searches. The computational demands of these applications often require distributed computing resources and specialized algorithms for handling the exponential growth of genomic data.",
    "target_text": "Question: How do hash-based algorithms address the computational challenges of genome analysis and sequence comparison in bioinformatics, and what specialized optimizations are required to handle the exponential growth of genomic data in distributed computing environments?\nChoices:\na) Hash-based genome analysis addresses computational challenges through user interface optimization and visualization enhancement, requiring specialized optimizations for scientific presentation and research communication in academic environments\nb) Hash-based algorithms use specialized hash functions for biological sequences, k-mer hashing for similarity detection, and distributed computing optimizations to handle exponential genomic data growth\nc) Hash-based genome analysis addresses computational challenges through regulatory compliance and data protection protocols, requiring specialized optimizations for privacy preservation and ethical research standards in medical applications\nd) Hash-based algorithms utilize computational challenges through commercial optimization and intellectual property management, requiring specialized optimizations for patent protection and technology licensing in biotechnology industries\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based weather forecasting and climate modeling systems process enormous amounts of atmospheric data from satellites, weather stations, and sensor networks to generate predictive models and real-time forecasts. These systems use hash-based spatial indexing for geographic data organization, temporal hashing for time-series analysis, and similarity hashing for pattern recognition in weather systems. The accuracy and timeliness of these predictions have critical implications for public safety, agriculture, and economic planning.",
    "target_text": "Question: How do weather forecasting and climate modeling systems utilize hash-based techniques for atmospheric data processing and prediction generation, and what are the critical implications of forecast accuracy and timeliness for public safety and economic sectors?\nChoices:\na) Weather forecasting systems utilize hash-based techniques for media communication and public outreach, with critical implications for information dissemination and public education about climate awareness and environmental consciousness\nb) Weather systems use hash-based spatial indexing, temporal hashing, and similarity hashing for atmospheric data processing, with forecast accuracy and timeliness having critical implications for public safety and economic planning\nc) Weather forecasting systems utilize hash-based techniques for research funding and academic collaboration, with critical implications for scientific advancement and international cooperation in climate research initiatives\nd) Weather systems employ hash-based techniques for equipment maintenance and infrastructure management, with critical implications for operational reliability and technology deployment in meteorological service operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based supply chain management systems track products, materials, and transactions across complex global networks involving multiple suppliers, manufacturers, distributors, and retailers. These systems use hash-based product identification, blockchain-style transaction recording, and hash signatures for authenticity verification. The transparency and traceability provided by these systems are essential for quality control, regulatory compliance, and consumer trust in modern supply chains.",
    "target_text": "Question: How do hash-based supply chain management systems provide transparency and traceability across global networks, and why are these capabilities essential for quality control, regulatory compliance, and consumer trust in modern commerce?\nChoices:\na) Hash-based supply chain systems provide transparency through marketing and brand management optimization, with capabilities essential for advertising effectiveness and consumer engagement in competitive retail markets\nb) Hash-based systems use product identification, blockchain transaction recording, and authenticity verification, with transparency and traceability essential for quality control, compliance, and consumer trust\nc) Hash-based supply chain systems provide transparency through financial management and cost optimization, with capabilities essential for profit maximization and expense reduction in supply chain operations\nd) Hash-based systems utilize transparency through employee management and workforce optimization, with capabilities essential for productivity improvement and human resource development in supply chain organizations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based energy grid management systems coordinate power generation, distribution, and consumption across smart grids with renewable energy sources, energy storage systems, and dynamic demand patterns. These systems use hash-based device identification, secure communication protocols, and real-time optimization algorithms that must balance supply and demand while maintaining grid stability. The complexity of these systems increases exponentially with the integration of distributed renewable energy sources and electric vehicle charging infrastructure.",
    "target_text": "Question: How do hash-based energy grid management systems coordinate complex power networks with renewable sources and dynamic demands, and what challenges arise from the exponential complexity increase with distributed renewable integration and electric vehicle infrastructure?\nChoices:\na) Hash-based energy grid systems coordinate power networks through customer service and billing optimization, with complexity challenges arising from pricing accuracy and payment processing in utility customer management\nb) Hash-based systems use device identification, secure protocols, and optimization algorithms for supply-demand balancing, with exponential complexity from renewable integration and EV infrastructure\nc) Hash-based energy grid systems coordinate power networks through regulatory compliance and environmental reporting, with complexity challenges arising from policy adherence and sustainability documentation\nd) Hash-based systems utilize power networks through research and development optimization, with complexity challenges arising from technology advancement and innovation management in energy sector development\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based disaster response and emergency management systems must rapidly process and coordinate information from multiple sources including emergency services, sensor networks, social media feeds, and satellite imagery during crisis situations. These systems use hash-based data fusion, real-time analytics, and resource allocation algorithms that must operate under extreme conditions with potentially degraded infrastructure. The effectiveness of these systems can directly impact human lives and disaster recovery outcomes.",
    "target_text": "Question: How do hash-based disaster response systems rapidly process and coordinate multi-source information during crisis situations, and why is system effectiveness under extreme conditions with degraded infrastructure critical for human lives and recovery outcomes?\nChoices:\na) Hash-based disaster response systems process information through media management and public relations coordination, with effectiveness critical for communication accuracy and public information dissemination during emergencies\nb) Hash-based systems use data fusion, real-time analytics, and resource allocation algorithms operating under extreme conditions, with effectiveness directly impacting human lives and disaster recovery outcomes\nc) Hash-based disaster response systems process information through insurance and financial recovery coordination, with effectiveness critical for economic restoration and financial assistance distribution during disasters\nd) Hash-based systems utilize information through research and documentation coordination, with effectiveness critical for academic study and historical analysis of disaster patterns and emergency response\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based space exploration and satellite systems manage vast amounts of telemetry data, scientific measurements, and communication protocols across distributed spacecraft networks with extreme latency and reliability constraints. These systems use hash-based error detection, data compression, and mission-critical communication protocols that must function autonomously for extended periods without ground intervention. The unique challenges of space environments require specialized hash implementations that can tolerate radiation, temperature extremes, and hardware failures.",
    "target_text": "Question: What unique challenges do space exploration systems face when implementing hash-based data management and communication protocols, and how do extreme environmental conditions and autonomy requirements influence the design of mission-critical hash algorithms?\nChoices:\na) Space exploration systems face challenges through commercial optimization and cost reduction requirements, with environmental conditions influencing design through economic efficiency and budget management for space mission development\nb) Space systems face challenges of extreme latency, reliability constraints, and autonomous operation, with radiation, temperature, and hardware failure tolerance requirements influencing hash algorithm design for mission-critical applications\nc) Space exploration systems face challenges through international cooperation and diplomatic coordination requirements, with environmental conditions influencing design through political considerations and international partnership management\nd) Space systems face challenges through public engagement and educational outreach requirements, with environmental conditions influencing design through communication effectiveness and scientific education for public space program support\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based virtual and augmented reality systems must process and render massive amounts of visual, audio, and spatial data in real-time while maintaining immersive user experiences with strict latency requirements. These systems use hash-based spatial indexing for 3D object management, content streaming optimization, and user interaction tracking. The computational demands of photorealistic rendering and real-time physics simulation require highly optimized hash implementations that can leverage parallel processing architectures.",
    "target_text": "Question: How do virtual and augmented reality systems employ hash-based techniques for real-time data processing and rendering, and what computational optimization strategies are required to meet strict latency requirements for immersive user experiences?\nChoices:\na) VR/AR systems employ hash-based techniques for user authentication and access control management, requiring optimization strategies focused on security verification and authorization processing for protected virtual environments\nb) VR/AR systems use hash-based spatial indexing, content streaming optimization, and interaction tracking, requiring highly optimized implementations leveraging parallel processing for strict latency requirements\nc) VR/AR systems employ hash-based techniques for marketing and user engagement analytics, requiring optimization strategies focused on data collection and user behavior analysis for commercial virtual environment applications\nd) VR/AR systems utilize hash-based techniques for regulatory compliance and safety monitoring, requiring optimization strategies focused on health protection and usage regulation for safe virtual reality experiences\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based digital preservation systems for libraries, museums, and archives must ensure long-term integrity and accessibility of cultural and historical materials across decades or centuries. These systems use cryptographic hash functions for integrity verification, hash-based metadata indexing for content discovery, and migration tracking for format preservation. The challenge lies in maintaining hash-based verification systems that can survive technological changes and institutional transitions over extremely long time periods.",
    "target_text": "Question: How do digital preservation systems for cultural institutions employ hash-based techniques to ensure long-term integrity and accessibility of historical materials, and what challenges arise when maintaining verification systems across decades of technological change?\nChoices:\na) Digital preservation systems employ hash-based techniques for visitor engagement and interactive experience enhancement, with challenges arising from technology updates and user interface modernization for museum accessibility\nb) Digital preservation systems use cryptographic hashing for integrity verification, metadata indexing, and migration tracking, facing challenges of maintaining verification across decades of technological and institutional changes\nc) Digital preservation systems employ hash-based techniques for funding and resource allocation management, with challenges arising from budget sustainability and financial planning for long-term institutional operations\nd) Digital preservation systems utilize hash-based techniques for legal compliance and copyright management, with challenges arising from intellectual property law changes and licensing requirement evolution over time\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based smart city infrastructure systems integrate data from traffic sensors, environmental monitors, public transportation, utility systems, and citizen services to optimize urban operations and quality of life. These systems use hash-based device management, real-time data fusion, and predictive analytics that must scale to support millions of connected devices and sensors. The integration challenges include interoperability between legacy systems, privacy protection for citizen data, and maintaining system resilience against both cyber attacks and physical infrastructure failures.",
    "target_text": "Question: How do smart city systems utilize hash-based techniques to integrate and manage massive IoT infrastructures for urban optimization, and what integration challenges must be addressed regarding interoperability, privacy, and system resilience in large-scale urban deployments?\nChoices:\na) Smart city systems utilize hash-based techniques for tourism and economic development promotion, with integration challenges regarding marketing effectiveness and business attraction for urban economic growth initiatives\nb) Smart city systems use hash-based device management, data fusion, and predictive analytics for millions of devices, facing challenges of legacy interoperability, privacy protection, and resilience against attacks and failures\nc) Smart city systems utilize hash-based techniques for political governance and citizen engagement, with integration challenges regarding democratic participation and public policy implementation for urban administration\nd) Smart city systems employ hash-based techniques for cultural preservation and community development, with integration challenges regarding heritage protection and social cohesion for urban cultural sustainability\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based personalized medicine and precision healthcare systems analyze individual genetic profiles, medical histories, lifestyle factors, and environmental exposures to provide customized treatment recommendations and drug therapies. These systems use hash-based patient identification, secure data sharing protocols, and privacy-preserving analytics that must comply with strict medical confidentiality requirements. The computational complexity of genomic analysis and drug interaction modeling requires sophisticated hash-based algorithms that can process multi-dimensional biological data efficiently.",
    "target_text": "Question: How do personalized medicine systems employ hash-based techniques for genetic analysis and customized treatment recommendations, and what computational and privacy challenges must be addressed when processing multi-dimensional biological data under strict medical confidentiality requirements?\nChoices:\na) Personalized medicine systems employ hash-based techniques for hospital administration and healthcare facility management, with challenges addressed through operational efficiency and cost optimization for medical service delivery\nb) Personalized medicine systems use hash-based patient identification, secure data sharing, and privacy-preserving analytics for genetic analysis, facing computational complexity and confidentiality challenges for multi-dimensional biological data\nc) Personalized medicine systems employ hash-based techniques for medical education and professional training, with challenges addressed through curriculum development and competency assessment for healthcare professional preparation\nd) Personalized medicine systems utilize hash-based techniques for pharmaceutical marketing and drug promotion, with challenges addressed through regulatory compliance and commercial effectiveness for medical product development\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Advanced hash table debugging and profiling techniques are essential for diagnosing performance issues in production systems where hash table behavior can significantly impact overall application performance. These techniques include collision rate analysis, load factor monitoring, distribution uniformity testing, cache hit ratio measurement, and probe sequence analysis. Modern debugging tools often provide visualization capabilities that help developers understand hash function effectiveness and identify optimization opportunities in real-world usage scenarios.",
    "target_text": "Question: What advanced debugging and profiling techniques are essential for diagnosing hash table performance issues in production systems, and how do modern visualization tools help developers identify optimization opportunities in real-world hash table usage scenarios?\nChoices:\na) Advanced hash table debugging techniques focus on user interface analysis and accessibility testing, with visualization tools helping developers identify design improvements and user experience optimization opportunities\nb) Advanced debugging includes collision analysis, load monitoring, distribution testing, and probe sequence analysis, with visualization tools helping developers understand hash effectiveness and identify optimization opportunities\nc) Advanced hash table debugging techniques focus on legal compliance and regulatory analysis, with visualization tools helping developers identify policy adherence and regulatory requirement optimization opportunities\nd) Advanced debugging utilizes financial analysis and cost optimization techniques, with visualization tools helping developers identify budget efficiency and resource allocation optimization opportunities\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based concurrent data structures for multi-threaded applications require sophisticated synchronization mechanisms to maintain consistency while maximizing parallelism. Lock-free hash tables use atomic compare-and-swap operations and hazard pointers to enable multiple threads to operate simultaneously without traditional locking overhead. Wait-free algorithms guarantee that every thread makes progress within a bounded number of steps, providing stronger guarantees than lock-free approaches but with increased implementation complexity and potential performance trade-offs.",
    "target_text": "Question: How do lock-free and wait-free hash table implementations enable concurrent access without traditional locking mechanisms, and what are the fundamental differences in progress guarantees and implementation complexity between these two approaches to concurrent hashing?\nChoices:\na) Lock-free and wait-free implementations enable concurrent access through user preference coordination and personalized access patterns, with differences in customization guarantees and interface complexity for multi-user applications\nb) Lock-free hash tables use atomic operations and hazard pointers for simultaneous access, while wait-free algorithms guarantee bounded progress for all threads with increased implementation complexity\nc) Lock-free and wait-free implementations enable concurrent access through security protocol coordination and encrypted communication patterns, with differences in protection guarantees and authentication complexity for secure applications\nd) Lock-free hash tables utilize resource optimization and cost management coordination, with differences in efficiency guarantees and economic complexity for budget-constrained applications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based data anonymization and privacy-preserving techniques are crucial for protecting sensitive information while maintaining data utility for analysis and research. Differential privacy mechanisms use hash-based noise injection to provide mathematical guarantees about individual privacy protection. k-anonymity and l-diversity techniques employ hash-based clustering and generalization to prevent re-identification attacks. These approaches must balance privacy protection strength with data utility preservation for legitimate analytical purposes.",
    "target_text": "Question: How do hash-based data anonymization techniques like differential privacy and k-anonymity protect sensitive information while preserving analytical utility, and what is the fundamental challenge of balancing privacy protection strength with data usefulness for research applications?\nChoices:\na) Hash-based anonymization techniques protect information through user interface obfuscation and presentation masking, with challenges of balancing visual privacy with accessibility for user-friendly applications\nb) Hash-based techniques use differential privacy noise injection and k-anonymity clustering to prevent re-identification while preserving analytical utility, balancing privacy strength with data usefulness\nc) Hash-based anonymization techniques protect information through network security and communication encryption, with challenges of balancing transmission privacy with connectivity for distributed applications\nd) Hash-based techniques utilize cost optimization and resource allocation masking, with challenges of balancing financial privacy with transparency for economic applications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based elastic computing and auto-scaling systems automatically adjust computational resources based on workload demands, cost optimization objectives, and performance requirements. These systems use hash-based workload characterization, predictive scaling algorithms, and resource allocation strategies that must respond rapidly to changing conditions while minimizing costs and maintaining service quality. The challenge lies in accurately predicting resource needs and avoiding both over-provisioning waste and under-provisioning performance degradation.",
    "target_text": "Question: How do hash-based elastic computing systems automatically adjust resources based on workload demands and optimization objectives, and what challenges arise when balancing rapid response to changing conditions with cost minimization and service quality maintenance?\nChoices:\na) Hash-based elastic computing systems adjust resources through user preference learning and interface customization, with challenges arising from personalization accuracy and user experience consistency across variable resource conditions\nb) Hash-based systems use workload characterization, predictive algorithms, and allocation strategies for resource adjustment, facing challenges of accurately predicting needs while avoiding over-provisioning and under-provisioning\nc) Hash-based elastic computing systems adjust resources through security monitoring and threat response protocols, with challenges arising from protection effectiveness and security policy enforcement across dynamic resource configurations\nd) Hash-based systems utilize resource adjustment through compliance monitoring and regulatory adherence, with challenges arising from policy consistency and legal requirement satisfaction across changing computational environments\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based digital forensics and cybersecurity investigation tools analyze system artifacts, network traffic, and digital evidence to reconstruct events and identify security incidents. These tools use cryptographic hashing for evidence integrity verification, hash-based signature matching for malware detection, and timeline analysis for incident reconstruction. The forensic process must maintain strict chain of custody requirements while providing admissible evidence that can withstand legal scrutiny in court proceedings.",
    "target_text": "Question: How do hash-based digital forensics tools analyze system artifacts and digital evidence for cybersecurity investigations, and what requirements must be met to maintain evidence integrity and legal admissibility throughout the forensic process?\nChoices:\na) Hash-based forensics tools analyze artifacts through user experience optimization and interface enhancement, with requirements focused on usability improvement and accessibility for investigative tool effectiveness\nb) Hash-based tools use cryptographic hashing for integrity verification, signature matching for malware detection, and timeline analysis, requiring strict chain of custody and legal admissibility standards\nc) Hash-based forensics tools analyze artifacts through cost optimization and resource management, with requirements focused on budget efficiency and economic sustainability for forensic laboratory operations\nd) Hash-based tools utilize artifact analysis through marketing research and competitive intelligence, with requirements focused on business development and commercial advantage for cybersecurity service providers\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based distributed ledger technologies beyond traditional blockchain, such as directed acyclic graphs (DAGs) and hashgraphs, offer alternative approaches to achieving consensus and maintaining distributed state. These systems use hash-based linking structures, gossip protocols for information propagation, and virtual voting mechanisms for consensus determination. The scalability and energy efficiency advantages of these approaches come with trade-offs in security assumptions and finality guarantees compared to traditional proof-of-work blockchain systems.",
    "target_text": "Question: How do alternative distributed ledger technologies like DAGs and hashgraphs use hash-based structures to achieve consensus differently from traditional blockchain, and what trade-offs exist between scalability advantages and security assumptions in these alternative approaches?\nChoices:\na) Alternative ledger technologies use hash-based structures for user interface consistency and presentation uniformity, with trade-offs between visual accessibility and design complexity for user-friendly distributed applications\nb) Alternative technologies like DAGs and hashgraphs use hash-based linking, gossip protocols, and virtual voting for consensus, trading scalability and efficiency gains for different security assumptions and finality guarantees\nc) Alternative ledger technologies use hash-based structures for cost optimization and resource allocation, with trade-offs between economic efficiency and financial transparency for budget-conscious distributed systems\nd) Alternative technologies utilize hash-based structures for compliance monitoring and regulatory reporting, with trade-offs between legal adherence and administrative overhead for regulated distributed applications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based quality assurance and testing methodologies for large-scale software systems employ automated test case generation, regression testing optimization, and performance benchmarking using hash-based test data management. These systems use hash functions to ensure test repeatability, detect test environment changes, and validate system behavior across different configurations. The effectiveness of these testing approaches directly impacts software reliability, security, and user satisfaction in production deployments.",
    "target_text": "Question: How do hash-based quality assurance methodologies enhance software testing through automated generation and performance benchmarking, and what is the relationship between testing effectiveness and software reliability, security, and user satisfaction in production systems?\nChoices:\na) Hash-based quality assurance methodologies enhance testing through marketing validation and brand reputation management, with relationships between testing effectiveness and customer perception for commercial software success\nb) Hash-based methodologies use automated test generation, regression optimization, and benchmarking with hash-based data management, with testing effectiveness directly impacting software reliability, security, and user satisfaction\nc) Hash-based quality assurance methodologies enhance testing through legal compliance and regulatory validation, with relationships between testing effectiveness and policy adherence for enterprise software deployment\nd) Hash-based methodologies utilize testing enhancement through financial optimization and cost reduction, with relationships between testing effectiveness and budget efficiency for software development economics\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based patent analysis and intellectual property management systems process vast databases of patent documents, technical publications, and invention disclosures to identify prior art, detect potential infringement, and support innovation strategies. These systems use hash-based document fingerprinting, similarity detection algorithms, and citation network analysis to map technological landscapes and competitive intelligence. The accuracy and completeness of these analyses can significantly impact business decisions, legal strategies, and research directions.",
    "target_text": "Question: How do hash-based patent analysis systems process technical documentation for intellectual property management and innovation strategy, and what impact do analysis accuracy and completeness have on business decisions, legal strategies, and research directions?\nChoices:\na) Hash-based patent analysis systems process documentation for employee training and workforce development, with impact on human resource management and professional skill development for technology companies\nb) Hash-based systems use document fingerprinting, similarity detection, and citation analysis for prior art identification and competitive intelligence, with accuracy impacting business decisions, legal strategies, and research directions\nc) Hash-based patent analysis systems process documentation for customer service and user support optimization, with impact on customer satisfaction and technical assistance effectiveness for product support operations\nd) Hash-based systems utilize documentation processing for facility management and infrastructure optimization, with impact on operational efficiency and resource utilization for research and development facilities\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based computational photography and image processing systems enhance digital imaging through noise reduction, super-resolution reconstruction, and content-aware editing capabilities. These systems use hash-based feature extraction, patch matching algorithms, and style transfer techniques that process millions of image patches and style elements. The computational demands of real-time image processing require highly optimized hash implementations that can leverage GPU parallelism and specialized image processing hardware.",
    "target_text": "Question: How do hash-based computational photography systems enhance digital imaging through advanced processing techniques, and what computational optimization strategies are required to achieve real-time performance for millions of image patches and style elements?\nChoices:\na) Hash-based computational photography systems enhance imaging through user preference learning and personalization algorithms, requiring optimization strategies for customization accuracy and individual user experience enhancement\nb) Hash-based systems use feature extraction, patch matching, and style transfer for noise reduction and super-resolution, requiring highly optimized implementations leveraging GPU parallelism for real-time processing\nc) Hash-based computational photography systems enhance imaging through security protection and watermarking techniques, requiring optimization strategies for intellectual property protection and image authentication\nd) Hash-based systems utilize imaging enhancement through cost optimization and resource management, requiring optimization strategies for budget efficiency and economic sustainability in image processing operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based federated learning systems enable collaborative machine learning across distributed organizations while preserving data privacy and regulatory compliance. These systems use hash-based model aggregation, secure multi-party computation protocols, and differential privacy mechanisms to train shared models without exposing sensitive training data. The challenge lies in maintaining model accuracy and convergence while providing strong privacy guarantees and handling the heterogeneity of data distributions across participating organizations.",
    "target_text": "Question: How do hash-based federated learning systems enable collaborative machine learning while preserving privacy and compliance across distributed organizations, and what challenges arise when maintaining model accuracy while providing privacy guarantees for heterogeneous data distributions?\nChoices:\na) Hash-based federated learning systems enable collaboration through user interface standardization and presentation consistency, with challenges arising from design uniformity and accessibility across diverse organizational interfaces\nb) Hash-based systems use model aggregation, secure computation, and differential privacy for collaborative learning, facing challenges of maintaining accuracy while providing privacy guarantees for heterogeneous data\nc) Hash-based federated learning systems enable collaboration through cost sharing and resource pooling, with challenges arising from financial coordination and economic efficiency across organizational boundaries\nd) Hash-based systems utilize collaborative learning through compliance coordination and regulatory harmonization, with challenges arising from policy consistency and legal requirement alignment across jurisdictions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based predictive maintenance systems for industrial equipment and infrastructure monitor sensor data, operational parameters, and environmental conditions to predict equipment failures before they occur. These systems use hash-based anomaly detection, pattern recognition algorithms, and prognostic modeling that must operate continuously in harsh industrial environments. The effectiveness of these systems directly impacts production uptime, maintenance costs, and worker safety in manufacturing and industrial operations.",
    "target_text": "Question: How do hash-based predictive maintenance systems monitor industrial equipment to prevent failures before they occur, and what is the direct relationship between system effectiveness and production uptime, maintenance costs, and worker safety in industrial operations?\nChoices:\na) Hash-based predictive maintenance systems monitor equipment for marketing research and customer satisfaction analysis, with relationships between effectiveness and brand reputation for industrial equipment manufacturers\nb) Hash-based systems use anomaly detection, pattern recognition, and prognostic modeling for failure prediction, with effectiveness directly impacting production uptime, maintenance costs, and worker safety\nc) Hash-based predictive maintenance systems monitor equipment for regulatory compliance and environmental reporting, with relationships between effectiveness and policy adherence for industrial regulatory requirements\nd) Hash-based systems utilize equipment monitoring for employee training and workforce development, with relationships between effectiveness and skill development for industrial workforce management\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based semantic web and knowledge graph systems organize and query vast networks of interconnected information using standardized ontologies and reasoning capabilities. These systems use hash-based entity resolution, relationship mapping, and semantic similarity measures to integrate information from heterogeneous sources and enable intelligent querying. The scalability challenges of these systems grow exponentially with the size and complexity of knowledge networks, requiring sophisticated optimization strategies for practical deployment.",
    "target_text": "Question: How do hash-based semantic web systems organize and query interconnected information networks using ontologies and reasoning, and what scalability challenges arise as knowledge networks grow in size and complexity requiring sophisticated optimization strategies?\nChoices:\na) Hash-based semantic web systems organize information for user interface personalization and experience customization, with scalability challenges arising from individualization complexity and preference management across diverse user bases\nb) Hash-based systems use entity resolution, relationship mapping, and semantic similarity for information integration and intelligent querying, with exponential scalability challenges requiring sophisticated optimization for practical deployment\nc) Hash-based semantic web systems organize information for financial management and cost optimization, with scalability challenges arising from economic complexity and resource allocation across expanding information networks\nd) Hash-based systems utilize information organization for legal compliance and regulatory management, with scalability challenges arising from policy complexity and requirement adherence across growing knowledge domains\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based augmented analytics and automated insight generation systems process business data to automatically discover patterns, anomalies, and actionable insights without requiring extensive data science expertise from users. These systems use hash-based pattern matching, statistical analysis algorithms, and natural language generation to translate complex analytical findings into understandable business recommendations. The democratization of advanced analytics through these systems can significantly impact organizational decision-making and competitive advantage.",
    "target_text": "Question: How do hash-based augmented analytics systems automatically generate business insights and recommendations without requiring extensive data science expertise, and what impact does analytics democratization have on organizational decision-making and competitive advantage?\nChoices:\na) Hash-based augmented analytics systems generate insights through employee satisfaction surveys and workplace optimization, with democratization impacting human resource management and organizational culture development\nb) Hash-based systems use pattern matching, statistical analysis, and natural language generation for automated insight discovery, with analytics democratization significantly impacting decision-making and competitive advantage\nc) Hash-based augmented analytics systems generate insights through facility management and infrastructure optimization, with democratization impacting operational efficiency and resource utilization across organizational facilities\nd) Hash-based systems utilize insight generation through compliance monitoring and regulatory reporting, with democratization impacting policy adherence and legal requirement satisfaction across organizational departments\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based digital twin systems create virtual representations of physical assets, processes, and systems that synchronize with real-world counterparts through continuous data exchange and simulation. These systems use hash-based state synchronization, model validation, and predictive simulation capabilities that enable optimization, testing, and planning without disrupting actual operations. The fidelity and real-time performance of these digital replicas directly impact their effectiveness for engineering design, operational optimization, and strategic planning.",
    "target_text": "Question: How do hash-based digital twin systems create and maintain virtual representations that synchronize with physical counterparts, and what is the relationship between replica fidelity, real-time performance, and effectiveness for engineering and operational applications?\nChoices:\na) Hash-based digital twin systems create representations for marketing visualization and customer engagement, with relationships between fidelity and brand presentation effectiveness for commercial product demonstration\nb) Hash-based systems use state synchronization, model validation, and predictive simulation for virtual representations, with fidelity and real-time performance directly impacting effectiveness for engineering and operational optimization\nc) Hash-based digital twin systems create representations for legal documentation and compliance reporting, with relationships between fidelity and regulatory adherence for administrative requirement satisfaction\nd) Hash-based systems utilize virtual representations for employee training and workforce development, with relationships between fidelity and educational effectiveness for professional skill development programs\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based edge intelligence and distributed AI systems deploy machine learning capabilities directly to IoT devices and edge computing nodes to reduce latency, preserve privacy, and minimize bandwidth usage. These systems use hash-based model compression, federated inference algorithms, and adaptive computation strategies that must operate within severe resource constraints while maintaining acceptable accuracy levels. The trade-offs between model sophistication and resource efficiency require careful optimization for different edge deployment scenarios.",
    "target_text": "Question: How do hash-based edge intelligence systems deploy machine learning to resource-constrained devices while maintaining performance goals, and what trade-offs must be balanced between model sophistication and resource efficiency in different edge deployment scenarios?\nChoices:\na) Hash-based edge intelligence systems deploy machine learning for user interface enhancement and accessibility improvement, with trade-offs between presentation sophistication and usability efficiency for diverse user interaction scenarios\nb) Hash-based systems use model compression, federated inference, and adaptive computation for edge deployment, balancing model sophistication against resource efficiency within severe constraint scenarios\nc) Hash-based edge intelligence systems deploy machine learning for cost optimization and financial management, with trade-offs between economic sophistication and budget efficiency for resource-constrained business scenarios\nd) Hash-based systems utilize machine learning deployment for compliance monitoring and regulatory adherence, with trade-offs between policy sophistication and administrative efficiency for distributed regulatory scenarios\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based evolutionary computation and genetic algorithms use hash functions for fitness evaluation, population diversity maintenance, and solution space exploration in optimization problems. These algorithms employ hash-based crowding mechanisms, niching strategies, and selection pressure controls to prevent premature convergence while efficiently exploring large solution spaces. The effectiveness of these approaches depends on balancing exploitation of promising regions with exploration of novel solutions across complex optimization landscapes.",
    "target_text": "Question: How do hash-based evolutionary algorithms use hash functions for optimization problem solving through fitness evaluation and diversity maintenance, and what balance must be achieved between exploitation of promising regions and exploration of novel solutions?\nChoices:\na) Hash-based evolutionary algorithms use hash functions for user preference optimization and interface customization, with balance achieved between personalization exploitation and design exploration for user experience enhancement\nb) Hash-based algorithms employ hash functions for fitness evaluation, diversity maintenance, and solution exploration, balancing exploitation of promising regions with exploration of novel solutions across optimization landscapes\nc) Hash-based evolutionary algorithms use hash functions for cost optimization and resource allocation, with balance achieved between budget exploitation and economic exploration for financial efficiency enhancement\nd) Hash-based algorithms utilize hash functions for compliance optimization and regulatory adherence, with balance achieved between policy exploitation and legal exploration for administrative requirement satisfaction\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based quantum-classical hybrid computing systems integrate quantum processors with classical computers using hash-based communication protocols, error correction mechanisms, and workload partitioning strategies. These systems must handle the unique characteristics of quantum computation including superposition, entanglement, and quantum decoherence while maintaining compatibility with classical data structures and algorithms. The development of these hybrid systems represents a crucial bridge toward practical quantum computing applications.",
    "target_text": "Question: How do hash-based quantum-classical hybrid systems integrate quantum processors with classical computers while handling unique quantum characteristics, and why do these hybrid systems represent a crucial bridge toward practical quantum computing applications?\nChoices:\na) Hash-based quantum-classical systems integrate processors for user interface consistency and presentation uniformity, representing bridges toward quantum user experience enhancement and accessibility improvement\nb) Hash-based systems use communication protocols, error correction, and workload partitioning to integrate quantum and classical processing while handling superposition and entanglement, bridging toward practical quantum applications\nc) Hash-based quantum-classical systems integrate processors for cost optimization and resource management, representing bridges toward quantum economic efficiency and budget optimization for computational applications\nd) Hash-based systems utilize processor integration for compliance monitoring and regulatory adherence, representing bridges toward quantum legal requirement satisfaction and policy compliance for regulated applications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash tables are data structures that implement an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. Ideally, the hash function will assign each key to a unique bucket, but most hash table designs employ an imperfect hash function, which might cause hash collisions where the hash function generates the same index for more than one key.",
    "target_text": "Question: What is the primary purpose of a hash function in a hash table data structure, and what happens when multiple keys produce the same hash value?\nChoices:\na) To sort keys in ascending order, and duplicate keys are rejected from the table\nb) To compute an index into an array of buckets for key-value storage, and hash collisions occur when multiple keys map to the same index\nc) To encrypt sensitive data before storage, and collisions result in data corruption\nd) To validate input data types, and collisions indicate invalid input that must be handled through exception throwing\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: The load factor of a hash table is defined as the ratio of the number of stored elements to the number of available slots in the hash table. This metric is crucial for understanding the performance characteristics of hash operations. A higher load factor means the hash table is more densely packed with data, which can lead to increased collision rates and potentially degraded performance. Most hash table implementations monitor the load factor and resize the table when it exceeds a certain threshold to maintain optimal performance.",
    "target_text": "Question: How is the load factor of a hash table calculated, and why is it important for maintaining optimal hash table performance in terms of collision management and operation efficiency?\nChoices:\na) Load factor equals the maximum number of elements divided by the minimum number of slots, and it helps determine memory allocation patterns\nb) Load factor equals the number of stored elements divided by the number of available slots, and it indicates collision density which affects performance\nc) Load factor equals the number of hash collisions divided by the total number of operations, and it measures algorithmic efficiency\nd) Load factor equals the size of the largest bucket divided by the average bucket size, and it determines the need for hash function replacement\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Collision resolution is a fundamental challenge in hash table implementation. When two or more keys hash to the same index, the hash table must have a strategy to handle this situation. The two main approaches are separate chaining and open addressing. Separate chaining maintains a list of all elements that hash to the same index, while open addressing finds an alternative location within the hash table itself for the colliding element using various probing strategies.",
    "target_text": "Question: What are the two primary collision resolution strategies used in hash table implementations, and how do they fundamentally differ in their approach to storing multiple elements that hash to the same index?\nChoices:\na) Linear probing and quadratic probing, where linear searches sequentially and quadratic uses mathematical formulas\nb) Separate chaining and open addressing, where chaining uses linked lists at each index and open addressing finds alternative locations within the table\nc) Binary search and interpolation search, where binary divides the search space and interpolation estimates positions\nd) Stack-based and queue-based resolution, where stack uses LIFO ordering and queue uses FIFO ordering for collision handling\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Separate chaining is a collision resolution technique where each slot in the hash table contains a pointer to a linked list of entries that hash to the same index. When a collision occurs, the new element is simply added to the linked list at that index. This approach allows for an unlimited number of elements to be stored in the hash table, limited only by available memory. The main advantages include simplicity of implementation and the ability to handle high load factors reasonably well.",
    "target_text": "Question: In the separate chaining collision resolution method, how are colliding elements stored and accessed, and what are the primary advantages of this approach compared to other collision resolution techniques?\nChoices:\na) Elements are stored in a balanced binary search tree at each index, providing O(log n) access time and guaranteed performance bounds\nb) Elements are stored in linked lists at each hash table index, allowing unlimited storage capacity and simple implementation with reasonable performance at high load factors\nc) Elements are redistributed to adjacent empty slots using a mathematical formula, ensuring even distribution and constant access time\nd) Elements are compressed and stored in a single slot using special encoding, reducing memory usage and eliminating the need for additional data structures\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Open addressing is a collision resolution method where all elements are stored directly in the hash table array itself. When a collision occurs, the algorithm probes other locations in the table until an empty slot is found. The sequence of locations probed is determined by a probing strategy. Linear probing checks consecutive slots, quadratic probing uses a quadratic function to determine the next slot, and double hashing uses a second hash function to calculate the probe sequence.",
    "target_text": "Question: How does open addressing handle collisions differently from separate chaining, and what are the three main probing strategies used to find alternative locations for colliding elements?\nChoices:\na) Open addressing uses external storage for overflow, with random probing, circular probing, and spiral probing as the main strategies\nb) Open addressing stores all elements directly in the table array and uses linear probing, quadratic probing, and double hashing to find empty slots\nc) Open addressing creates multiple hash tables for different data types, using type-based probing, size-based probing, and frequency-based probing\nd) Open addressing compresses colliding elements into single slots, using compression probing, encoding probing, and transformation probing techniques\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Linear probing is the simplest form of open addressing where, upon encountering a collision, the algorithm examines the next slot in the table. If that slot is also occupied, it continues to the next slot, and so on, until an empty slot is found. While simple to implement, linear probing can suffer from primary clustering, where consecutive occupied slots form clusters that increase the average probe distance for future insertions and searches.",
    "target_text": "Question: What is the primary mechanism of linear probing for collision resolution, and what is the main performance issue that can arise from this approach in terms of data clustering patterns?\nChoices:\na) Linear probing uses a mathematical formula to calculate optimal positions, but suffers from secondary clustering where distant elements interfere\nb) Linear probing examines consecutive slots until finding an empty one, but can create primary clustering where consecutive occupied slots increase probe distances\nc) Linear probing employs multiple hash functions simultaneously, but faces tertiary clustering when hash functions produce similar patterns\nd) Linear probing reorganizes the entire table after each insertion, but encounters clustering when reorganization creates uneven distributions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Quadratic probing is an open addressing collision resolution technique that attempts to reduce clustering by using a quadratic function to determine the probe sequence. Instead of checking consecutive slots like linear probing, quadratic probing examines slots at distances that follow a quadratic pattern (typically i², where i is the probe number). This approach helps to spread out the probe sequence and reduces primary clustering, though it can still experience secondary clustering under certain conditions.",
    "target_text": "Question: How does quadratic probing differ from linear probing in its approach to finding alternative slots during collision resolution, and what type of clustering problem does it help to mitigate?\nChoices:\na) Quadratic probing uses exponential distances between probes, eliminating all forms of clustering but requiring more complex mathematical calculations\nb) Quadratic probing examines slots at quadratic distances (like i²) rather than consecutive slots, reducing primary clustering while potentially causing secondary clustering\nc) Quadratic probing employs multiple quadratic equations simultaneously, preventing clustering but increasing the computational overhead significantly\nd) Quadratic probing reorganizes probe sequences based on table size, eliminating clustering by dynamically adjusting probe patterns according to current load\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Double hashing is a sophisticated open addressing technique that uses two independent hash functions to resolve collisions. The first hash function determines the initial position, and if a collision occurs, the second hash function determines the step size for probing. This approach provides excellent distribution of probe sequences and minimizes clustering effects. The step size from the second hash function must be relatively prime to the table size to ensure that all table positions can be reached.",
    "target_text": "Question: What distinguishes double hashing from other open addressing techniques, and why is it important that the step size produced by the second hash function be relatively prime to the table size?\nChoices:\na) Double hashing uses two identical hash functions for redundancy, and relative primality ensures that backup calculations produce consistent results\nb) Double hashing employs two independent hash functions where the second determines step size, and relative primality to table size ensures all positions are reachable\nc) Double hashing creates two separate hash tables for overflow handling, and relative primality prevents mathematical conflicts between table operations\nd) Double hashing applies hash functions twice to the same key for verification, and relative primality guarantees that verification calculations remain accurate\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: A good hash function should distribute keys uniformly across the hash table to minimize collisions and ensure optimal performance. Key characteristics of effective hash functions include determinism (the same key always produces the same hash value), uniform distribution (hash values are evenly spread across the table), and efficiency (fast computation). The hash function should also be sensitive to input changes, meaning that small changes in the key should result in significantly different hash values to avoid clustering.",
    "target_text": "Question: What are the essential characteristics that define a high-quality hash function for optimal hash table performance, and why is sensitivity to input changes particularly important for preventing clustering?\nChoices:\na) Randomness, complexity, and security, with sensitivity preventing unauthorized access to hash table contents and maintaining data integrity\nb) Determinism, uniform distribution, and efficiency, with sensitivity ensuring that similar keys don't cluster together by producing significantly different hash values\nc) Reversibility, predictability, and simplicity, with sensitivity allowing for easy debugging and performance analysis of hash table operations\nd) Stability, consistency, and reliability, with sensitivity providing error detection capabilities and ensuring data consistency across operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: The division method is one of the most common techniques for creating hash functions. It works by taking the key modulo the table size: h(k) = k mod m, where k is the key and m is the table size. The choice of table size m is crucial for the effectiveness of this method. Prime numbers are often preferred for the table size because they tend to provide better distribution of hash values and reduce the likelihood of systematic patterns that could lead to clustering.",
    "target_text": "Question: How does the division method calculate hash values, and why are prime numbers particularly effective choices for the table size when using this hashing technique?\nChoices:\na) Division method calculates h(k) = k / m with remainder handling, and prime numbers ensure mathematical accuracy in floating-point operations\nb) Division method uses h(k) = k mod m, and prime numbers provide better hash value distribution by reducing systematic patterns and clustering\nc) Division method employs h(k) = m / k with overflow protection, and prime numbers guarantee unique hash values for sequential key inputs\nd) Division method computes h(k) = k × m mod p, and prime numbers enable efficient modular arithmetic operations for large key values\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: The multiplication method for hash functions works by multiplying the key by a constant fractional value between 0 and 1, extracting the fractional part of the result, and then multiplying by the table size. The formula is h(k) = ⌊m × (kA mod 1)⌋, where A is a constant in the range (0, 1) and m is the table size. Donald Knuth suggested that A = (√5 - 1)/2 ≈ 0.6180339887 (related to the golden ratio) works particularly well in practice.",
    "target_text": "Question: What is the mathematical formula for the multiplication method of hash function design, and why is the golden ratio-related constant suggested by Knuth considered particularly effective for this technique?\nChoices:\na) h(k) = ⌊k × A⌋ mod m, and the golden ratio provides optimal mathematical properties for modular arithmetic operations in hash computations\nb) h(k) = ⌊m × (kA mod 1)⌋, and the golden ratio-related constant (≈ 0.618) has special mathematical properties that produce excellent hash value distribution\nc) h(k) = ⌊(k + A) × m⌋, and the golden ratio ensures that consecutive keys produce maximally separated hash values for clustering prevention\nd) h(k) = ⌊k / A⌋ × m, and the golden ratio-based constant guarantees that all possible hash values are equally likely for any input distribution\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Universal hashing is a technique that involves choosing a hash function randomly from a family of hash functions at runtime. This approach provides theoretical guarantees about the expected performance of hash operations, regardless of the input data. A family of hash functions is called universal if, for any two distinct keys, the probability that they collide is at most 1/m, where m is the number of slots in the hash table. This technique is particularly useful when dealing with adversarial inputs or when performance guarantees are critical.",
    "target_text": "Question: What is the fundamental principle behind universal hashing, and what theoretical guarantee does it provide regarding collision probability for any two distinct keys?\nChoices:\na) Universal hashing uses multiple hash functions simultaneously for redundancy, guaranteeing zero collisions for any input set smaller than the table size\nb) Universal hashing randomly selects from a family of hash functions, ensuring collision probability between any two distinct keys is at most 1/m\nc) Universal hashing adapts the hash function based on input patterns, providing guaranteed O(1) access time for all operations regardless of data distribution\nd) Universal hashing employs cryptographic techniques for security, ensuring that collision probability approaches zero as the table size increases exponentially\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Dynamic resizing is a crucial feature of modern hash table implementations that automatically adjusts the table size based on the current load factor. When the load factor becomes too high (typically around 0.75), the table is resized to maintain performance. The resizing process involves creating a new, larger table (usually double the size) and rehashing all existing elements into the new table. This operation has a high temporary cost but maintains the overall efficiency of hash operations.",
    "target_text": "Question: Why is dynamic resizing necessary in hash table implementations, and what is the typical process involved when the load factor threshold is exceeded?\nChoices:\na) Dynamic resizing prevents memory fragmentation by periodically compacting data, involving defragmentation and memory reorganization without changing table size\nb) Dynamic resizing maintains performance by expanding the table when load factor gets too high, requiring creation of a new larger table and rehashing all elements\nc) Dynamic resizing optimizes cache performance by adjusting element arrangement, involving reordering elements within the existing table structure for better locality\nd) Dynamic resizing ensures security by changing hash functions periodically, requiring re-encryption of all stored elements using updated cryptographic parameters\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Perfect hashing is a theoretical concept where a hash function maps all keys in a given set to unique hash values with no collisions. While perfect hash functions exist for any finite set of keys, they are typically only practical when the key set is known in advance and doesn't change. Minimal perfect hash functions go a step further by using exactly n slots for n keys, achieving both perfect hashing and optimal space utilization.",
    "target_text": "Question: What distinguishes perfect hashing from regular hashing techniques, and under what circumstances is perfect hashing practically achievable in real-world applications?\nChoices:\na) Perfect hashing eliminates all computational overhead by pre-calculating results, and is practical when infinite memory resources are available for storage\nb) Perfect hashing maps all keys to unique values with no collisions, and is practical when the key set is known in advance and remains static\nc) Perfect hashing guarantees constant-time operations for all data types, and is practical when advanced mathematical algorithms can predict all possible inputs\nd) Perfect hashing provides cryptographic security for sensitive data, and is practical when quantum computing resources are available for hash calculations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Consistent hashing is a specialized hashing technique commonly used in distributed systems and load balancing scenarios. Unlike traditional hashing, where adding or removing a server requires rehashing most keys, consistent hashing minimizes redistribution by mapping both keys and servers to points on a circular hash space. When a server is added or removed, only keys between that server and its predecessor need to be remapped, significantly reducing the amount of data movement required.",
    "target_text": "Question: How does consistent hashing differ from traditional hashing in distributed systems, and what advantage does it provide when servers are dynamically added or removed from the system?\nChoices:\na) Consistent hashing uses cryptographic techniques for security in distributed environments, providing data encryption and preventing unauthorized access to distributed data\nb) Consistent hashing maps keys and servers to a circular hash space, minimizing key redistribution by only affecting keys between changed server and its predecessor\nc) Consistent hashing employs multiple redundant hash functions for fault tolerance, ensuring that system failures don't result in complete data loss or service interruption\nd) Consistent hashing utilizes time-based hash calculations for synchronization, providing coordinated updates across distributed nodes and maintaining temporal consistency\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Cuckoo hashing is an advanced collision resolution scheme that guarantees worst-case constant time for lookup operations. It uses two hash tables and two hash functions, with each key being stored in one of two possible positions across the tables. When inserting a new key causes a collision, the existing key is 'kicked out' to its alternative position, potentially causing a chain reaction of displacements. If this process cycles, the tables are rebuilt with new hash functions.",
    "target_text": "Question: What is the fundamental mechanism of cuckoo hashing that enables it to guarantee worst-case constant time lookups, and how does it handle the insertion of keys that cause collisions?\nChoices:\na) Cuckoo hashing uses predictive algorithms to prevent collisions entirely, maintaining constant lookup time by calculating optimal positions for all keys in advance\nb) Cuckoo hashing employs two tables with two hash functions per key, handling collisions by displacing existing keys to alternative positions with potential table rebuilding\nc) Cuckoo hashing implements time-based rotation of hash functions, ensuring constant performance by periodically updating the hashing strategy to prevent clustering\nd) Cuckoo hashing utilizes compression techniques to fit multiple keys per slot, maintaining performance by reducing the effective table size through data encoding\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Robin Hood hashing is a variation of open addressing that aims to reduce variance in probe distances by moving elements around to minimize the maximum probe distance. When inserting an element, if it encounters an element that has traveled a shorter distance from its preferred position, the new element 'steals' that position and the displaced element continues searching. This approach leads to more uniform probe distances and better worst-case performance.",
    "target_text": "Question: What is the core principle behind Robin Hood hashing's approach to reducing probe distance variance, and how does it decide when one element should displace another during insertion?\nChoices:\na) Robin Hood hashing minimizes total memory usage by compacting elements together, displacing elements based on their size to optimize space utilization efficiency\nb) Robin Hood hashing reduces maximum probe distances by allowing elements to displace others that have traveled shorter distances from their preferred positions\nc) Robin Hood hashing equalizes access frequencies by rotating element positions, displacing elements based on their usage patterns to improve average performance\nd) Robin Hood hashing prevents clustering by randomizing element placement, displacing elements using probabilistic algorithms to ensure uniform distribution across table\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash tables provide average-case O(1) time complexity for search, insertion, and deletion operations when the hash function distributes keys uniformly and the load factor is kept reasonable. However, in the worst case (when all keys hash to the same location), these operations can degrade to O(n) time complexity. The performance heavily depends on the quality of the hash function and the collision resolution strategy employed.",
    "target_text": "Question: What are the average-case and worst-case time complexities for basic hash table operations, and what factors primarily determine whether performance approaches the average case or degrades toward the worst case?\nChoices:\na) Average case is O(log n) and worst case is O(n log n), determined by the sorting algorithm used for collision resolution and table organization\nb) Average case is O(1) and worst case is O(n), determined by hash function quality and collision resolution strategy effectiveness\nc) Average case is O(n) and worst case is O(n²), determined by the size of the input dataset and available memory resources\nd) Average case is O(√n) and worst case is O(2ⁿ), determined by the mathematical complexity of the hash function and key distribution patterns\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Cryptographic hash functions serve a different purpose than hash functions used in hash tables. While hash table functions prioritize speed and uniform distribution, cryptographic hash functions focus on security properties such as being one-way (infeasible to reverse), collision-resistant (hard to find two inputs that produce the same output), and avalanche effect (small input changes cause large output changes). Examples include SHA-256, MD5, and SHA-3.",
    "target_text": "Question: How do cryptographic hash functions differ from hash table hash functions in their design goals and properties, and what are the key security characteristics that cryptographic hash functions must possess?\nChoices:\na) Cryptographic hash functions prioritize speed and simplicity like hash table functions, but add basic password protection and user authentication capabilities\nb) Cryptographic hash functions focus on security properties like being one-way, collision-resistant, and having avalanche effect, rather than just speed and distribution\nc) Cryptographic hash functions use more complex mathematical operations than hash table functions, but serve the same fundamental purpose of data organization\nd) Cryptographic hash functions employ multiple hash table functions in sequence, providing enhanced performance and better collision resolution for sensitive data\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Bloom filters are space-efficient probabilistic data structures used to test whether an element is a member of a set. They can have false positives (indicating an element is in the set when it's not) but never false negatives (missing an element that is actually in the set). Bloom filters use multiple hash functions to set bits in a bit array. The trade-off between space efficiency and false positive rate makes them valuable for applications where some uncertainty is acceptable.",
    "target_text": "Question: What is the fundamental trade-off inherent in Bloom filter design, and why are false positives possible while false negatives are impossible in this probabilistic data structure?\nChoices:\na) Bloom filters trade computational speed for memory efficiency, with false positives occurring due to hash function approximations and false negatives prevented by redundant storage\nb) Bloom filters trade space efficiency for some uncertainty, with false positives possible when multiple elements set the same bits but false negatives impossible since all bits for present elements are set\nc) Bloom filters trade accuracy for simplicity of implementation, with false positives resulting from mathematical rounding errors and false negatives avoided through error checking\nd) Bloom filters trade deterministic results for probabilistic performance, with false positives caused by network delays and false negatives prevented by synchronization mechanisms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: String hashing presents unique challenges and opportunities in hash function design. Strings of varying lengths need to be mapped to fixed-size hash values efficiently. Common approaches include polynomial rolling hash (where each character is treated as a coefficient in a polynomial), djb2 hash (a simple multiplicative hash), and cryptographic hashes for security-sensitive applications. The choice depends on the specific requirements for speed, distribution quality, and collision resistance.",
    "target_text": "Question: What are the primary challenges in designing hash functions specifically for string data, and what are the main approaches used to address the variable-length nature of string inputs?\nChoices:\na) String hashing challenges include character encoding compatibility and international language support, addressed through Unicode normalization and character set standardization\nb) String hashing challenges include mapping variable-length strings to fixed-size values efficiently, addressed through polynomial rolling hash, multiplicative methods, or cryptographic approaches\nc) String hashing challenges include memory alignment and cache optimization for string storage, addressed through padding algorithms and memory management techniques\nd) String hashing challenges include concurrent access and thread safety for shared strings, addressed through locking mechanisms and atomic string operations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based data structures extend beyond simple hash tables to include various specialized implementations. Hash sets provide efficient membership testing, hash maps (or dictionaries) store key-value pairs, and hash multisets allow duplicate elements. Each variant optimizes for specific use cases while maintaining the fundamental O(1) average-case performance for basic operations. The underlying hash table provides the foundation for all these abstractions.",
    "target_text": "Question: What are the main variants of hash-based data structures and how do they differ in their functionality and use cases while maintaining similar underlying performance characteristics?\nChoices:\na) Hash variants include encrypted hashes for security, compressed hashes for storage, and distributed hashes for networking, each optimizing for different system requirements\nb) Hash variants include hash sets for membership testing, hash maps for key-value storage, and hash multisets for duplicates, all providing O(1) average performance\nc) Hash variants include static hashes for fixed data, dynamic hashes for changing data, and hybrid hashes for mixed workloads, each suited for different data patterns\nd) Hash variants include linear hashes for sequential access, random hashes for arbitrary access, and sorted hashes for ordered data, each optimizing different access patterns\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash table implementations must handle deletion carefully, especially when using open addressing collision resolution. Simply removing an element and marking its slot as empty can break the probe sequence for other elements, making them unreachable. Common solutions include lazy deletion (marking slots as 'deleted' rather than 'empty') or using tombstones that indicate a slot was previously occupied but is now available for insertion.",
    "target_text": "Question: Why does deletion in open addressing hash tables require special handling compared to separate chaining, and what are the common strategies used to maintain probe sequence integrity after element removal?\nChoices:\na) Deletion requires special handling due to memory fragmentation concerns, addressed through defragmentation algorithms and memory compaction techniques\nb) Deletion requires special handling because removing elements can break probe sequences, addressed through lazy deletion or tombstone markers\nc) Deletion requires special handling due to concurrent access conflicts, addressed through locking mechanisms and transaction-based removal operations\nd) Deletion requires special handling because of cache invalidation issues, addressed through cache coherency protocols and memory barrier instructions\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Locality-sensitive hashing (LSH) is a technique used in approximate nearest neighbor search and data mining applications. Unlike traditional hash functions that aim to distribute similar inputs across different hash values, LSH is designed so that similar items have a high probability of being mapped to the same hash bucket. This property makes it valuable for applications like duplicate detection, clustering, and similarity search in high-dimensional spaces.",
    "target_text": "Question: How does locality-sensitive hashing differ from traditional hash functions in its design goals, and what types of applications benefit from this alternative approach to hash value distribution?\nChoices:\na) LSH differs by prioritizing computational efficiency over uniform distribution, benefiting applications that require real-time processing and low-latency response times\nb) LSH differs by ensuring similar items map to the same hash buckets rather than different ones, benefiting similarity search, clustering, and duplicate detection applications\nc) LSH differs by providing cryptographic security for sensitive data, benefiting applications that require data protection and privacy preservation in distributed systems\nd) LSH differs by optimizing for memory usage rather than speed, benefiting applications with limited storage capacity and constrained computational resources\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash tables are fundamental to many higher-level data structures and algorithms. They serve as the underlying implementation for programming language features like dictionaries in Python, objects in JavaScript, and maps in Java. They're also crucial components in database indexing, caching systems, symbol tables in compilers, and distributed systems for consistent hashing and load balancing.",
    "target_text": "Question: In what ways do hash tables serve as foundational components in both programming language features and system-level applications, and why are they particularly well-suited for these diverse use cases?\nChoices:\na) Hash tables provide foundational components through their sorting capabilities and ordered access patterns, making them ideal for maintaining sequential data relationships\nb) Hash tables serve as foundations for dictionaries, database indices, caches, and distributed systems due to their O(1) average access time and key-value mapping capabilities\nc) Hash tables provide foundational components through their tree-like hierarchical structure, making them suitable for representing complex nested data relationships\nd) Hash tables serve as foundations through their mathematical precision and deterministic behavior, making them essential for scientific computing and numerical analysis\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: The birthday paradox has important implications for hash function design and collision analysis. It states that in a group of just 23 people, there's a greater than 50% chance that two people share the same birthday. Applied to hashing, this means that collisions occur much more frequently than intuition suggests. For a hash table with n slots, collisions become likely after inserting only about √n elements, which influences decisions about table sizing and collision handling strategies.",
    "target_text": "Question: How does the birthday paradox apply to hash table collision analysis, and what practical implications does this mathematical principle have for hash table design and sizing decisions?\nChoices:\na) The birthday paradox applies to hash tables by predicting optimal insertion orders, implying that elements should be inserted in specific sequences to minimize collision probability\nb) The birthday paradox shows that collisions become likely after inserting √n elements in an n-slot table, implying that collision handling must be robust and table sizing conservative\nc) The birthday paradox applies to hash deletion patterns by modeling removal sequences, implying that deletion order affects future collision probabilities and performance\nd) The birthday paradox predicts hash function lifespan and replacement cycles, implying that hash functions should be updated periodically to maintain optimal distribution properties\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Distributed hash tables (DHTs) extend the hash table concept to distributed systems where data is spread across multiple nodes in a network. Each node is responsible for a range of hash values, and the system automatically routes requests to the appropriate node. DHTs provide scalability, fault tolerance, and load distribution. Examples include Chord, Pastry, and Kademlia, which are used in peer-to-peer networks and distributed storage systems.",
    "target_text": "Question: How do distributed hash tables extend traditional hash table concepts to work across multiple networked nodes, and what are the key benefits this architecture provides for large-scale distributed systems?\nChoices:\na) DHTs extend hash tables by replicating entire tables across all nodes for redundancy, providing benefits through complete data availability and simplified routing mechanisms\nb) DHTs extend hash tables by distributing hash value ranges across network nodes with automatic routing, providing scalability, fault tolerance, and load distribution\nc) DHTs extend hash tables by using specialized network protocols for data synchronization, providing benefits through guaranteed consistency and real-time updates across nodes\nd) DHTs extend hash tables by implementing hierarchical node structures for organization, providing benefits through improved security and centralized management capabilities\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Count-Min Sketch is a probabilistic data structure that uses multiple hash functions and a two-dimensional array to estimate the frequency of events in a data stream. It provides space-efficient approximate counting with guarantees on the error bounds. The structure can overestimate counts but never underestimate them, making it useful for applications like network monitoring, database query optimization, and real-time analytics where approximate counts are sufficient.",
    "target_text": "Question: What is the fundamental design principle of the Count-Min Sketch data structure, and what type of error characteristics does it exhibit when providing frequency estimates for streaming data?\nChoices:\na) Count-Min Sketch uses single hash functions with complex mathematical formulas, exhibiting symmetric errors that can both overestimate and underestimate counts equally\nb) Count-Min Sketch employs multiple hash functions with a 2D array to estimate frequencies, exhibiting one-sided errors that can overestimate but never underestimate counts\nc) Count-Min Sketch utilizes temporal hash functions that change over time, exhibiting decreasing errors as more data is processed through adaptive learning mechanisms\nd) Count-Min Sketch implements recursive hash calculations with nested structures, exhibiting logarithmic errors that decrease proportionally with the size of the input stream\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: MinHash is a technique used for quickly estimating the similarity between sets, commonly applied in document similarity analysis, duplicate detection, and recommendation systems. It works by creating a signature for each set using multiple hash functions and taking the minimum hash value for each function. The Jaccard similarity between two sets can be approximated by the fraction of positions where their MinHash signatures agree, providing an efficient way to compare large sets without examining all elements.",
    "target_text": "Question: How does the MinHash technique estimate set similarity without directly comparing all elements, and what mathematical principle allows it to approximate Jaccard similarity through signature comparison?\nChoices:\na) MinHash estimates similarity by sorting set elements and comparing sorted sequences, with Jaccard similarity approximated through positional matching algorithms\nb) MinHash creates signatures using minimum hash values from multiple hash functions, with Jaccard similarity approximated by the fraction of matching signature positions\nc) MinHash employs statistical sampling techniques with random element selection, with Jaccard similarity estimated through probabilistic analysis of sample overlaps\nd) MinHash uses compression algorithms to encode set contents efficiently, with Jaccard similarity calculated through decompression and direct element comparison\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: HyperLogLog is a probabilistic algorithm that estimates the cardinality (number of distinct elements) in a dataset using a remarkably small amount of memory. It uses hash functions to map elements to binary strings and analyzes the patterns of leading zeros to estimate cardinality. Despite using only a few kilobytes of memory, it can estimate cardinalities of billions of elements with typical errors of 2% or less, making it valuable for big data analytics and database optimization.",
    "target_text": "Question: What is the core mechanism by which HyperLogLog estimates cardinality using minimal memory, and what makes this approach so memory-efficient compared to exact counting methods?\nChoices:\na) HyperLogLog uses sampling techniques to select representative subsets of data, achieving memory efficiency through statistical extrapolation from small sample sizes\nb) HyperLogLog analyzes leading zero patterns in hash values to estimate cardinality, achieving efficiency by storing only pattern summaries rather than actual elements\nc) HyperLogLog employs compression algorithms to encode distinct elements efficiently, achieving memory savings through advanced data compression and deduplication techniques\nd) HyperLogLog utilizes mathematical approximation formulas based on dataset characteristics, achieving efficiency through algorithmic estimation rather than explicit counting\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Rolling hash functions, also known as sliding window hash functions, are designed to efficiently compute hash values for overlapping substrings or subarrays. Instead of recalculating the entire hash for each position, rolling hashes update incrementally by removing the contribution of the element leaving the window and adding the contribution of the new element entering the window. This technique is fundamental to algorithms like Rabin-Karp string matching.",
    "target_text": "Question: What is the key advantage of rolling hash functions over traditional hash functions when processing overlapping substrings, and how do they achieve efficient incremental updates?\nChoices:\na) Rolling hashes provide better collision resistance through multiple hash calculations, achieving efficiency by using parallel processing techniques for simultaneous hash computations\nb) Rolling hashes enable incremental updates by removing departing elements and adding new elements to the hash calculation, avoiding complete recalculation for each window position\nc) Rolling hashes offer improved memory usage by storing intermediate hash results, achieving efficiency through caching mechanisms and result reuse strategies\nd) Rolling hashes deliver enhanced security through time-based hash modifications, achieving efficiency by limiting hash function complexity and computational overhead\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Extendible hashing is a dynamic hashing scheme designed for external storage where the hash table can grow and shrink gracefully without requiring complete reorganization. It uses a directory structure that points to buckets, and when a bucket overflows, the directory can be doubled and buckets split incrementally. This approach minimizes the amount of data that needs to be moved during expansion, making it suitable for database indexing and file systems.",
    "target_text": "Question: How does extendible hashing achieve efficient dynamic resizing compared to traditional hash tables, and what role does the directory structure play in minimizing data movement during expansion?\nChoices:\na) Extendible hashing achieves efficiency through predictive algorithms that anticipate growth patterns, with the directory serving as a cache for frequently accessed elements\nb) Extendible hashing uses a directory pointing to buckets that can be split incrementally, minimizing data movement by only reorganizing overflowing buckets rather than the entire table\nc) Extendible hashing employs compression techniques to reduce storage requirements during expansion, with the directory managing compressed data blocks and decompression processes\nd) Extendible hashing utilizes parallel processing for simultaneous bucket operations, with the directory coordinating distributed hash calculations across multiple storage devices\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Linear hashing is another dynamic hashing technique that grows the hash table incrementally without requiring a directory structure like extendible hashing. It uses a split pointer that moves through the table, splitting buckets one at a time in a predetermined order. When the load factor exceeds a threshold, the table begins expanding by splitting the bucket pointed to by the split pointer, regardless of whether that particular bucket is overflowing.",
    "target_text": "Question: What distinguishes linear hashing from extendible hashing in terms of its expansion strategy, and how does the split pointer mechanism control the incremental growth process?\nChoices:\na) Linear hashing differs by using random bucket selection for splitting operations, with the split pointer serving as a randomization seed for unpredictable expansion patterns\nb) Linear hashing expands by splitting buckets in predetermined order using a split pointer, growing incrementally without requiring a directory structure for bucket management\nc) Linear hashing differs by employing time-based expansion triggers instead of load factors, with the split pointer coordinating temporal aspects of bucket splitting operations\nd) Linear hashing utilizes mathematical formulas to calculate optimal split locations, with the split pointer implementing complex algorithms for minimizing hash collision rates\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Concurrent hashing presents significant challenges in multi-threaded environments where multiple threads may simultaneously access and modify the hash table. Traditional locking approaches can create bottlenecks, so modern implementations use techniques like lock-free algorithms, optimistic concurrency control, and fine-grained locking strategies. Some approaches segment the hash table into multiple independent sections, each with its own lock, to improve parallelism.",
    "target_text": "Question: What are the primary challenges of implementing hash tables in concurrent environments, and what strategies are employed to maintain both correctness and performance when multiple threads access the same hash table?\nChoices:\na) Concurrent hashing faces challenges from memory bandwidth limitations and cache coherency issues, addressed through specialized hardware support and custom memory architectures\nb) Concurrent hashing must handle simultaneous access while maintaining correctness and performance, using techniques like lock-free algorithms, fine-grained locking, and table segmentation\nc) Concurrent hashing encounters difficulties with thread synchronization and scheduling conflicts, resolved through priority-based thread management and real-time operating system features\nd) Concurrent hashing struggles with data consistency and network latency in distributed systems, managed through consensus protocols and distributed transaction mechanisms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Cache-conscious hashing designs aim to optimize hash table performance by considering the memory hierarchy and cache behavior of modern processors. Techniques include arranging data to improve spatial locality, minimizing cache misses during probe sequences, and organizing hash table entries to fit cache line boundaries efficiently. These optimizations can significantly improve performance, especially for large hash tables that don't fit entirely in processor cache.",
    "target_text": "Question: What is the motivation behind cache-conscious hashing design, and what specific techniques are employed to optimize hash table performance with respect to modern processor memory hierarchies?\nChoices:\na) Cache-conscious hashing optimizes for network latency in distributed systems, employing techniques like data replication and geographical distribution to minimize access times\nb) Cache-conscious hashing improves performance by optimizing for processor cache behavior, using techniques like spatial locality optimization and cache line boundary alignment\nc) Cache-conscious hashing focuses on reducing computational complexity of hash functions, employing techniques like algorithmic simplification and mathematical optimization for faster calculations\nd) Cache-conscious hashing enhances security through cache-based encryption methods, employing techniques like cache key management and secure memory access protocols\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based algorithms play crucial roles in various applications beyond simple data storage and retrieval. They're fundamental to blockchain technology for mining and verification, used in digital signatures and certificate validation, essential for password storage and authentication systems, and critical for data deduplication in storage systems. Each application leverages different properties of hash functions, from collision resistance to uniform distribution.",
    "target_text": "Question: How do hash-based algorithms serve different purposes across various applications like blockchain, authentication, and data deduplication, and what specific hash function properties are most important for each use case?\nChoices:\na) Hash algorithms serve applications through data compression capabilities, with speed being most important for blockchain, accuracy for authentication, and simplicity for deduplication\nb) Hash algorithms support different applications by leveraging properties like collision resistance for blockchain, one-way functions for authentication, and uniform distribution for deduplication\nc) Hash algorithms function across applications through mathematical precision, with determinism being critical for blockchain, randomness for authentication, and reversibility for deduplication\nd) Hash algorithms enable applications through network optimization features, with bandwidth efficiency important for blockchain, latency reduction for authentication, and scalability for deduplication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Fuzzy hashing, also known as similarity hashing or context-triggered piecewise hashing (CTPH), is designed to identify similar files or documents even when they've been slightly modified. Unlike cryptographic hashes that produce completely different outputs for small input changes, fuzzy hashes produce similar outputs for similar inputs. This property makes them valuable for malware detection, plagiarism detection, and version control systems.",
    "target_text": "Question: How does fuzzy hashing differ from traditional cryptographic hashing in its response to input modifications, and what applications benefit from this alternative behavior?\nChoices:\na) Fuzzy hashing differs by providing faster computation speeds for large inputs, benefiting applications that require real-time processing and immediate hash value generation\nb) Fuzzy hashing produces similar outputs for similar inputs unlike cryptographic hashes, benefiting malware detection, plagiarism detection, and version control applications\nc) Fuzzy hashing differs by offering better security through multiple hash layers, benefiting applications that require enhanced protection against sophisticated attack vectors\nd) Fuzzy hashing provides deterministic results across different computing platforms, benefiting applications that require consistent hash values in distributed computing environments\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Rendezvous hashing, also known as highest random weight (HRW) hashing, is a distributed hashing algorithm that provides excellent load balancing and minimal disruption when nodes are added or removed from a distributed system. For each key, it computes a hash value for every available node and assigns the key to the node with the highest hash value. This approach ensures that load is distributed evenly and that only K/N keys need to be remapped when the number of nodes changes.",
    "target_text": "Question: What is the fundamental principle behind rendezvous hashing's approach to distributed key assignment, and how does it achieve minimal disruption when the node configuration changes?\nChoices:\na) Rendezvous hashing assigns keys based on geographic proximity to nodes, achieving minimal disruption through location-based routing that maintains regional data locality\nb) Rendezvous hashing assigns each key to the node with highest hash value among all nodes, achieving minimal disruption by only remapping K/N keys when nodes change\nc) Rendezvous hashing uses time-based rotation of key assignments across nodes, achieving minimal disruption through predictable scheduling that maintains temporal consistency\nd) Rendezvous hashing employs load monitoring to assign keys to least busy nodes, achieving minimal disruption through dynamic balancing that responds to real-time usage patterns\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Perfect hash function construction is a specialized area of computer science that deals with creating hash functions for known static sets of keys. The FKS (Fredman, Komlós, and Szemerédi) scheme is a classic approach that constructs perfect hash functions in two levels: a primary hash function that may have collisions, and secondary hash functions for each bucket that resolve collisions perfectly. This construction guarantees O(1) worst-case lookup time.",
    "target_text": "Question: How does the FKS scheme construct perfect hash functions for static key sets, and what guarantee does this two-level approach provide for lookup performance?\nChoices:\na) FKS scheme constructs perfect hash functions through statistical analysis of key patterns, providing probabilistic guarantees that approach O(1) performance for most practical datasets\nb) FKS scheme uses two levels with primary hash functions that may collide and secondary functions that resolve collisions perfectly, guaranteeing O(1) worst-case lookup time\nc) FKS scheme constructs perfect hash functions through iterative refinement of hash parameters, providing adaptive performance that improves over time with usage pattern analysis\nd) FKS scheme employs mathematical optimization to minimize hash function complexity, providing computational guarantees that balance performance with implementation simplicity\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Zobrist hashing is a technique commonly used in game programming, particularly for board games like chess and Go, to create hash values for game positions. It works by assigning random values to each possible piece-square combination and computing the position hash by XORing together the values for all pieces on the board. This allows for incremental updates when moves are made, making it efficient for applications like transposition tables in game search algorithms.",
    "target_text": "Question: What is the mechanism behind Zobrist hashing for game position representation, and what advantage does it provide for incremental updates when game moves are executed?\nChoices:\na) Zobrist hashing uses sequential numbering of board positions with mathematical transformations, providing advantages through predictable position encoding that simplifies move validation\nb) Zobrist hashing assigns random values to piece-square combinations and XORs them together, enabling efficient incremental updates by XORing piece movements in and out\nc) Zobrist hashing employs compression algorithms to encode board states efficiently, providing advantages through reduced memory usage and faster position comparison operations\nd) Zobrist hashing utilizes pattern recognition to identify similar game positions, providing advantages through position clustering that accelerates similarity-based game analysis\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Consistent hashing with virtual nodes (also called vnodes) enhances the basic consistent hashing algorithm by having each physical node in the system correspond to multiple virtual nodes distributed around the hash ring. This approach improves load balancing by ensuring that when a node joins or leaves, its load is distributed among many other nodes rather than just its immediate neighbors, leading to more uniform distribution and better fault tolerance.",
    "target_text": "Question: How do virtual nodes enhance the basic consistent hashing algorithm, and what specific improvements do they provide in terms of load distribution and system resilience?\nChoices:\na) Virtual nodes enhance consistent hashing by providing backup copies of data for redundancy, improving system resilience through automatic failover and data recovery mechanisms\nb) Virtual nodes map each physical node to multiple positions on the hash ring, improving load distribution by spreading node responsibilities and enhancing fault tolerance\nc) Virtual nodes enhance consistent hashing through predictive algorithms that anticipate node failures, improving system resilience through proactive load redistribution strategies\nd) Virtual nodes provide enhanced security by encrypting data transfers between nodes, improving system resilience through protected communication channels and authenticated access\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Distributed hash tables (DHTs) face several challenges in real-world deployments, including node churn (frequent joining and leaving), network partitions, and maintaining data consistency. Various DHT implementations like Chord, Pastry, and Kademlia address these challenges through different approaches to routing, replication, and failure recovery. The choice of DHT algorithm depends on the specific requirements for consistency, availability, and partition tolerance.",
    "target_text": "Question: What are the primary challenges faced by distributed hash tables in practical deployments, and how do different DHT algorithms like Chord, Pastry, and Kademlia address these challenges through their design choices?\nChoices:\na) DHT challenges include computational complexity and algorithm efficiency, addressed through mathematical optimization and simplified routing protocols in different implementations\nb) DHT challenges include node churn, network partitions, and consistency maintenance, addressed through different approaches to routing, replication, and failure recovery\nc) DHT challenges include security vulnerabilities and data protection concerns, addressed through encryption protocols and authentication mechanisms in various DHT designs\nd) DHT challenges include scalability limitations and performance bottlenecks, addressed through hardware acceleration and specialized network infrastructure in different systems\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based message authentication codes (HMACs) combine hash functions with secret keys to provide both data integrity and authentication. The HMAC construction uses two passes of a hash function with inner and outer padding to create a message authentication code that is secure against various cryptographic attacks. HMACs are widely used in network protocols, API authentication, and secure communication systems.",
    "target_text": "Question: How do HMACs combine hash functions with secret keys to provide message authentication, and what makes the two-pass construction with inner and outer padding cryptographically secure?\nChoices:\na) HMACs combine hash functions with keys through simple concatenation methods, with two-pass construction providing security through redundant calculation and error detection\nb) HMACs use two passes of hash functions with inner and outer padding around secret keys, providing security against cryptographic attacks through this specific construction\nc) HMACs combine hash functions with keys through time-based rotation algorithms, with two-pass construction providing security through temporal variance and unpredictable timing\nd) HMACs use hash functions with encrypted keys for enhanced protection, with two-pass construction providing security through double encryption and layered authentication\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Merkle trees, also known as hash trees, are binary tree structures where each leaf node represents a hash of a data block, and each internal node represents a hash of its child nodes. This structure allows for efficient verification of large amounts of data with minimal computational and bandwidth overhead. Merkle trees are fundamental to blockchain technology, distributed version control systems like Git, and peer-to-peer file sharing protocols.",
    "target_text": "Question: What is the structural organization of Merkle trees and how do they enable efficient verification of large datasets with minimal computational overhead?\nChoices:\na) Merkle trees organize data in linear chains with sequential hash calculations, enabling efficient verification through parallel processing and distributed computation across multiple nodes\nb) Merkle trees use binary structure where leaves are data hashes and internal nodes hash their children, enabling efficient verification by checking only logarithmic number of hashes\nc) Merkle trees arrange data in circular structures with recursive hash relationships, enabling efficient verification through pattern recognition and predictive hash validation algorithms\nd) Merkle trees organize data in hierarchical clusters with weighted hash functions, enabling efficient verification through statistical sampling and probabilistic validation techniques\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash-based proof-of-work systems, like those used in Bitcoin mining, require miners to find input values that produce hash outputs with specific properties, typically a certain number of leading zeros. The difficulty of this task can be adjusted by changing the required number of leading zeros, making it a tunable computational puzzle. This mechanism provides security by making it computationally expensive to alter historical records.",
    "target_text": "Question: How do hash-based proof-of-work systems create computational puzzles for miners, and what security property does this mechanism provide for blockchain networks?\nChoices:\na) Proof-of-work systems create puzzles through mathematical optimization problems that require specialized algorithms, providing security through intellectual property protection and algorithm complexity\nb) Proof-of-work systems require finding inputs that produce hashes with specific properties like leading zeros, providing security by making historical record alteration computationally expensive\nc) Proof-of-work systems create puzzles through statistical analysis of network patterns that require big data processing, providing security through predictive analysis and anomaly detection\nd) Proof-of-work systems require solving encryption challenges that demand cryptographic expertise, providing security through access control and authentication verification mechanisms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Skip lists with hashing combine the probabilistic structure of skip lists with hash-based key comparison to create hybrid data structures that support both ordered operations and hash-based lookup. This combination allows for efficient range queries while maintaining the fast average-case performance of hash tables for point queries. The integration requires careful coordination between the hash function and the skip list levels.",
    "target_text": "Question: How do skip lists with hashing combine the advantages of both data structures, and what coordination is required between the hash function and skip list levels for effective integration?\nChoices:\na) Skip lists with hashing combine structures through parallel implementation where skip lists and hash tables operate independently, requiring coordination through synchronization protocols and shared memory management\nb) Skip lists with hashing integrate hash-based key comparison with probabilistic skip list structure, requiring careful coordination between hash functions and level organization for both ordered and point queries\nc) Skip lists with hashing combine structures through temporal rotation where different operations use different structures, requiring coordination through time-based scheduling and operation queue management\nd) Skip lists with hashing integrate through spatial partitioning where different data ranges use different structures, requiring coordination through boundary management and range-based routing algorithms\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Geohashing is a geocoding system that represents geographic coordinates as short alphanumeric strings with the property that strings with longer common prefixes represent locations that are closer together. It uses a hash-like algorithm to interleave latitude and longitude bits alternately, creating a hierarchical spatial index. This encoding is useful for location-based services, spatial databases, and proximity searches.",
    "target_text": "Question: What is the fundamental principle behind geohashing's encoding of geographic coordinates, and what spatial property does the resulting string representation provide for location-based applications?\nChoices:\na) Geohashing encodes coordinates through mathematical transformation using trigonometric functions, providing spatial properties through angular relationships and distance calculations for navigation systems\nb) Geohashing interleaves latitude and longitude bits alternately to create strings where longer common prefixes indicate closer geographic proximity for location-based indexing\nc) Geohashing encodes coordinates through statistical clustering using machine learning algorithms, providing spatial properties through pattern recognition and automated geographic classification systems\nd) Geohashing uses compression techniques to reduce coordinate storage requirements, providing spatial properties through efficient data representation and reduced bandwidth usage for mobile applications\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Probabilistic data structures that use hashing, such as Bloom filters, Count-Min Sketch, and HyperLogLog, trade perfect accuracy for significant space and time efficiency gains. These structures are particularly valuable in big data applications where exact results are not always necessary, and approximate answers with known error bounds are acceptable. They enable processing of massive datasets that would be impractical with exact algorithms.",
    "target_text": "Question: What fundamental trade-off do probabilistic hashing-based data structures make, and why are they particularly valuable for big data applications where perfect accuracy may not be essential?\nChoices:\na) Probabilistic structures trade computational speed for enhanced security features, making them valuable for big data applications that require real-time fraud detection and security monitoring\nb) Probabilistic structures trade perfect accuracy for significant space and time efficiency, making them valuable for big data applications where approximate results with known error bounds are acceptable\nc) Probabilistic structures trade simplicity for advanced functionality features, making them valuable for big data applications that require complex analytical capabilities and sophisticated processing\nd) Probabilistic structures trade deterministic behavior for adaptive learning capabilities, making them valuable for big data applications that require machine learning integration and intelligent automation\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Modern hash table implementations often employ sophisticated techniques like Robin Hood hashing, hopscotch hashing, and cuckoo hashing to minimize worst-case performance and improve cache efficiency. These advanced schemes go beyond simple collision resolution to actively reorganize elements for better performance characteristics. They represent the evolution of hash table design from basic functionality to high-performance, cache-aware implementations.",
    "target_text": "Question: How do modern advanced hashing schemes like Robin Hood, hopscotch, and cuckoo hashing improve upon traditional collision resolution methods, and what performance characteristics do they optimize for contemporary computing environments?\nChoices:\na) Advanced hashing schemes improve traditional methods through parallel processing capabilities and multi-threaded optimization, focusing on performance characteristics like concurrent access and thread safety\nb) Advanced hashing schemes actively reorganize elements beyond simple collision resolution to minimize worst-case performance and improve cache efficiency for modern computing architectures\nc) Advanced hashing schemes improve traditional methods through mathematical precision and algorithmic complexity, focusing on performance characteristics like computational accuracy and numerical stability\nd) Advanced hashing schemes enhance traditional methods through security features and encryption integration, focusing on performance characteristics like data protection and access control\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Hash table testing and debugging present unique challenges because hash function behavior can vary significantly with different input distributions, and performance issues may only manifest under specific load conditions or key patterns. Testing strategies must include collision analysis, load factor monitoring, distribution uniformity checks, and performance profiling under various scenarios to ensure robust hash table implementations.",
    "target_text": "Question: What unique challenges does hash table testing present compared to other data structures, and what comprehensive testing strategies are necessary to ensure robust hash table performance across different usage scenarios?\nChoices:\na) Hash table testing challenges include memory management complexity and garbage collection issues, requiring strategies focused on memory leak detection and resource utilization optimization\nb) Hash table testing faces challenges from varying hash function behavior and load-dependent performance, requiring collision analysis, distribution checks, and scenario-based profiling\nc) Hash table testing challenges include concurrent access conflicts and thread synchronization issues, requiring strategies focused on race condition detection and parallel execution validation\nd) Hash table testing faces challenges from security vulnerabilities and attack resistance, requiring strategies focused on penetration testing and cryptographic validation of hash implementations\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: Educational approaches to teaching hashing concepts often benefit from visualization tools that demonstrate hash function behavior, collision patterns, and the effects of different resolution strategies. Interactive simulations can help students understand load factor impacts, probe sequences in open addressing, and the trade-offs between different hashing techniques. These tools make abstract concepts more concrete and intuitive.",
    "target_text": "Question: Why are visualization tools and interactive simulations particularly effective for teaching hashing concepts, and what specific aspects of hash table behavior do these educational tools help students understand more intuitively?\nChoices:\na) Visualization tools are effective because they simplify complex mathematical formulas into basic arithmetic, helping students understand computational complexity and algorithmic efficiency through numerical examples\nb) Visualization tools make abstract hashing concepts concrete by demonstrating hash function behavior, collision patterns, probe sequences, and trade-offs between different techniques\nc) Visualization tools are effective because they provide real-time performance monitoring capabilities, helping students understand system optimization and hardware utilization through benchmarking exercises\nd) Visualization tools enhance learning through gamification and competitive programming elements, helping students understand algorithmic implementation and coding best practices through interactive challenges\nAnswer: b"
  },
  {
    "input_text": "Generate a data structure MCQ | Topic: Hashing | Context: The study of hash functions and hash tables provides foundational knowledge for understanding many advanced computer science concepts including cryptography, distributed systems, database indexing, and algorithm analysis. Mastering hashing principles enables students to tackle complex problems in areas like data mining, network security, and large-scale system design where efficient data organization and retrieval are critical.",
    "target_text": "Question: How does mastering hash table concepts and principles provide a foundation for understanding advanced computer science domains, and what complex problem-solving capabilities does this knowledge enable for students pursuing specialized areas?\nChoices:\na) Hashing mastery provides foundation through mathematical rigor and proof techniques, enabling students to tackle theoretical computer science problems and formal verification challenges in academic research\nb) Hashing knowledge enables understanding of cryptography, distributed systems, databases, and algorithm analysis, providing capabilities for data mining, security, and large-scale system design\nc) Hashing concepts provide foundation through programming language design and compiler optimization, enabling students to tackle software engineering problems and system development challenges in industry applications\nd) Hashing principles enable understanding through hardware architecture and computer engineering, providing capabilities for embedded systems design and performance optimization in specialized computing environments\nAnswer: b"
  }
]