[
    {
        "question_number": "Question 1",
        "question_title": "What does the following function do for a given Linked List with first node as head?",
        "code": "void fun1(struct node* head)\n{\n  if(head == NULL)\n    return;\n  \n  fun1(head->next);\n  printf(\"%d  \", head->data);\n}",
        "choices": [
            "A\nPrints all nodes of linked lists",
            "B\nPrints all nodes of linked list in reverse order",
            "C\nPrints alternate nodes of Linked List",
            "D\nPrints alternate nodes in reverse order"
        ]
    },
    {
        "question_number": "Question 2",
        "question_title": "Which of the following points is/are true about Linked List data structure when it is compared with array?",
        "code": "",
        "choices": [
            "A\nArrays have better cache locality that can make them better in terms of performance.",
            "B\nIt is easy to insert and delete elements in Linked List",
            "C\nRandom access is not allowed in a typical implementation of Linked Lists",
            "D\nThe size of array has to be pre-decided, linked lists can change their size any time.",
            "E\nAll of the above"
        ]
    },
    {
        "question_number": "Question 3",
        "question_title": "Consider the following function that takes reference to head of a Doubly Linked List as parameter. Assume that a node of doubly linked list has previous pointer as prev and next pointer as next. ",
        "code": "void fun(struct node **head_ref) {\n    struct node *temp = NULL;\n    struct node *current = *head_ref;\n\n    while (current != NULL) {\n        temp = current->prev;\n        current->prev = current->next;\n        current->next = temp;\n        current = current->prev;\n    }\n\n    if (temp != NULL)\n        *head_ref = temp->prev;\n}",
        "choices": [
            "A\n2 <--> 1 <--> 4 <--> 3 <--> 6 <-->5",
            "B\n5 <--> 4 <--> 3 <--> 2 <--> 1 <-->6.",
            "C\n6 <--> 5 <--> 4 <--> 3 <--> 2 <--> 1.",
            "D\n6 <--> 5 <--> 4 <--> 3 <--> 1 <--> 2"
        ]
    },
    {
        "question_number": "Question 4",
        "question_title": "The following function reverse() is supposed to reverse a singly linked list. There is one line missing at the end of the function. ",
        "code": "// Link list node\nstruct node\n{\n    int data;\n    struct node* next;\n};\n\n// head_ref is a double pointer which points to head (or start) pointer \nof linked list\nstatic void reverse(struct node** head_ref)\n{\n    struct node* prev   = NULL;\n    struct node* current = *head_ref;\n    struct node* next;\n    while (current != NULL)\n    {\n        next  = current->next;  \n        current->next = prev;   \n        prev = current;\n        current = next;\n    }\n     // MISSING STATEMENT HERE\n}",
        "choices": [
            "A\nSet the value of head_ref to prev;",
            "B\nSet the value of head_ref to current;",
            "C\nSet the value of head_ref to next;",
            "D\nSet the value of head_ref to NULL;"
        ]
    },
    {
        "question_number": "Question 5",
        "question_title": "What is the output of following function in which start is pointing to the first node of the following linked list 1->2->3->4->5->6 ?",
        "code": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n    Node() { data = 0; next = nullptr; } \n};\n\nvoid fun(Node* start) {\n    if (start == nullptr)\n        return;\n    cout << start->data << \"  \";\n    \n    if (start->next != nullptr)\n        fun(start->next->next);\n    cout << start->data << \"  \";\n}",
        "choices": [
            "A\n1 4 6 6 4 1",
            "B\n1 3 5 1 3 5",
            "C\n1 2 3 5",
            "D\n1 3 5 5 3 1"
        ]
    },
    {
        "question_number": "Question 6",
        "question_title": "The following C function takes a simply-linked list as input argument. It modifies the list by moving the last element to the front of the list and returns the modified list. Some part of the code is left blank. Choose the correct alternative that contain the correct pseudocode for the blank line. ",
        "code": "#include <iostream>\nstruct Node {\n    int value;\n    Node *next;\n};\n\nNode* move_to_front(Node *head) {\n    Node *p, *q;\n    if (head == NULL || head->next == NULL)\n        return head;\n    q = NULL; p = head;\n    while (p->next != NULL) {\n        q = p;\n        p = p->next;\n    }\n    __________________________________\n    return head;\n}",
        "choices": [
            "A\nq = NULL; next of p = head; head = p;",
            "B\nnext of q = NULL; head = p; next of p = head;",
            "C\nhead = p; next of p = q; next of q = NULL;",
            "D\nnext of q = NULL; next of p = head; head = p;"
        ]
    },
    {
        "question_number": "Question 7",
        "question_title": "The following  function takes a single-linked list of integers as a parameter and rearranges the elements of the list. The function is called with the list containing the integers 1, 2, 3, 4, 5, 6, 7 in the given order. What will be the contents of the list after the function completes execution? ",
        "code": "class Node {\npublic:\n    int value;\n    Node* next;\n};\n\nvoid rearrange(Node* list) {\n    Node* p;\n    Node* q;\n    int temp;\n    if (list == nullptr || list->next == nullptr) {\n        return;\n    }\n    p = list;\n    q = list->next;\n    while (q != nullptr) {\n        temp = p->value;\n        p->value = q->value;\n        q->value = temp;\n        p = q->next;\n        q = (p != nullptr) ? p->next : nullptr;\n    }\n}",
        "choices": [
            "A\n1,2,3,4,5,6,7",
            "B\n2,1,4,3,6,5,7",
            "C\n1,3,2,5,4,7,6",
            "D\n2,3,4,5,6,7,1"
        ]
    },
    {
        "question_number": "Question 8",
        "question_title": "Suppose each set is represented as a linked list with elements in arbitrary order. Which of the operations among union, intersection, membership, cardinality will be the slowest? (GATE CS 2004)",
        "code": "",
        "choices": [
            "A\nunion ",
            "B\n membership",
            "C\ncardinality",
            "D\n union, intersection"
        ]
    },
    {
        "question_number": "Question 9",
        "question_title": "Consider the function f defined below. ",
        "code": "#include <iostream>\n\nstruct item {\n    int data;\n    struct item *next;\n};\n\nint f(struct item *p) {\n    return (\n        (p == NULL) || \n        (p->next == NULL) || \n        ((p->data <= p->next->data) && f(p->next))\n    );\n}",
        "choices": [
            "A\nnot all elements in the list have the same data value.",
            "B\nthe elements in the list are sorted in non-decreasing order of data value",
            "C\nthe elements in the list are sorted in non-increasing order of data value",
            "D\nNone of them"
        ]
    },
    {
        "question_number": "Question 10",
        "question_title": "A circularly linked list is used to represent a Queue. A single variable p is used to access the Queue. To which node should p point such that both the operations enQueue and deQueue can be performed in constant time? (GATE 2004) ",
        "code": "",
        "choices": [
            "A\nrear node",
            "B\nfront node",
            "C\nnot possible with a single pointer",
            "D\nnode next to front"
        ]
    },
    {
        "question_number": "Question 11",
        "question_title": "What are the time complexities of finding 8th element from beginning and 8th element from end in a singly linked list? Let n be the number of nodes in linked list, you may assume that n > 8.",
        "code": "",
        "choices": [
            "A\nO(1) and O(n)",
            "B\nO(1) and O(1)",
            "C\nO(n) and O(1)",
            "D\nO(n) and O(n)"
        ]
    },
    {
        "question_number": "Question 12",
        "question_title": "Is it possible to create a doubly linked list using only one pointer with every node.",
        "code": "",
        "choices": [
            "A\nNot Possible",
            "B\nYes, possible by storing XOR of addresses of previous and next nodes.",
            "C\nYes, possible by storing XOR of current node and next node",
            "D\nYes, possible by storing XOR of current node and previous node"
        ]
    },
    {
        "question_number": "Question 13",
        "question_title": "Given pointer to a node X in a singly linked list. Only one pointer is given, pointer to head node is not given, can we delete the node X from given linked list?",
        "code": "",
        "choices": [
            "A\nPossible if X is not last node. Use following two steps (a) Copy the data of next of X to X. (b)Update the pointer of node X to the node after the next node. Delete next of X.",
            "B\nPossible if size of linked list is even.",
            "C\nPossible if size of linked list is odd",
            "D\nPossible if X is not first node. Use following two steps (a) Copy the data of next of X to X. (b) Delete next of X."
        ]
    },
    {
        "question_number": "Question 14",
        "question_title": "Which of the following is an application of XOR-linked lists?",
        "code": "",
        "choices": [
            "A\nImplementing stacks",
            "B\nImplementing queues",
            "C\nMemory-efficient linked list representation",
            "D\nCaching data structures"
        ]
    },
    {
        "question_number": "Question 15",
        "question_title": "Consider the following function to traverse a linked list. ",
        "code": "// C++ version of traverse function\nvoid traverse(Node *head) {\n    while (head != NULL) {\n        printf(\"%d  \", head->data);\n        head = head->next;\n    }\n}",
        "choices": [
            "A\nThe function may crash when the linked list is empty",
            "B\nThe function doesn't print the last node when the linked list is not empty",
            "C\nThe function is implemented incorrectly because it changes head",
            "D\nNone of the above"
        ]
    },
    {
        "question_number": "Question 16",
        "question_title": "N items are stored in a sorted doubly linked list. For a delete operation, a pointer is provided to the record to be deleted. For a decrease-key operation, a pointer is provided to the record on which the operation is to be performed. An algorithm performs the following operations on the list in this order: Θ(N) delete, O(log N) insert, O(log N) find, and Θ(N) decrease-key What is the time complexity of all these operations put together?",
        "code": "",
        "choices": [
            "A\nO(Log2N)",
            "B\nO(N)",
            "C\nO(N Log N)",
            "D\nΘ(N2 Log N)"
        ]
    },
    {
        "question_number": "Question 17",
        "question_title": "What are the application(s) of linked list?",
        "code": "",
        "choices": [
            "A\nImplementation of stacks and queues.",
            "B\nMaintaining a directory of names",
            "C\nNone of the above",
            "D\nBoth a and b"
        ]
    },
    {
        "question_number": "Question 18",
        "question_title": "The concatenation of two lists is to be performed in O(1) time. Which of the following implementations of a list should be used?",
        "code": "",
        "choices": [
            "A\nsingly linked list",
            "B\ndoubly linked list",
            "C\ncircular doubly linked list",
            "D\narray implementation of lists"
        ]
    },
    {
        "question_number": "Question 19",
        "question_title": "Consider the following piece of 'C' code fragment that removes duplicates from an ordered list of integers.",
        "code": "#include <stdio.h>\n\nNode *remove_duplicates(Node *head, int *j) {\n    Node *t1, *t2;\n    *j = 0;\n    t1 = head;\n    if (t1 != NULL) t2 = t1->next;\n    else return head;\n    *j = 1;\n    if (t2 == NULL)\n        return head;\n    while (t2 != NULL) {\n        if (t1->val != t2->val) { // S1\n            (*j)++; t1->next = t2; t1 = t2; // S2\n        }\n        t2 = t2->next;\n    }\n    t1->next = NULL;\n    return head;\n}",
        "choices": [
            "A\n(a). n-1 times, since comparison is pairwise for n elements.\n(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.\n(C). j keeps count of distinct nodes in the list.",
            "(a). n-1 times, since comparison is pairwise for n elements.",
            "(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.",
            "(C). j keeps count of distinct nodes in the list.",
            "B\n(a). n times, since comparison is pairwise for n elements.\n(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.\n(C). j keeps count of distinct nodes in the list.",
            "(a). n times, since comparison is pairwise for n elements.",
            "(b). maximum : n-1 for all distinct elements, minimum: 0 for all same elements.",
            "(C). j keeps count of distinct nodes in the list.",
            "C\n(a). n-1 times, since comparison is pairwise for n elements.\n(b). maximum : n-1 for all distinct elements, minimum: 1 for all same elements.\n(C). j keeps count of distinct nodes in the list.",
            "(a). n-1 times, since comparison is pairwise for n elements.",
            "(b). maximum : n-1 for all distinct elements, minimum: 1 for all same elements.",
            "(C). j keeps count of distinct nodes in the list.",
            "D\nNone of the above"
        ]
    },
    {
        "question_number": "Question 20",
        "question_title": "Suppose there are two singly linked lists both of which intersect at some point and become a single linked list. The head or start pointers of both the lists are known, but the intersecting node and lengths of lists are not known. What is worst case time complexity of optimal algorithm to find intersecting node from two intersecting linked lists?",
        "code": "",
        "choices": [
            "A\nΘ(n*m), where m, n are lengths of given lists",
            "B\nΘ(n^2), where m>n and m, n are lengths of given lists",
            "C\nΘ(m+n), where m, n are lengths of given lists",
            "D\nΘ(min(n, m)), where m, n are lengths of given lists"
        ]
    }
]